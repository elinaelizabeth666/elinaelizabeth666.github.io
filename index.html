<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>咸鱼的小茶馆</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- 字体导入 -->
  <style>
    /* 寒蝉团圆体 */
    @import url("https://fontsapi.zeoseven.com/66/main/result.css");
    
    /* 呆萌手写体 */
    @import url("https://fontsapi.zeoseven.com/638/main/result.css");
    
    /* 缝合像素字体 */
    @import url("https://fontsapi.zeoseven.com/570/main/result.css");
    
    /* Permanent Marker字体 */
    @font-face {
        font-family: "ZSFT-dr";
        src: url("https://fontsapi.zeoseven.com/dr/main.woff2") format('woff2'),
            url("https://fontsapi-storage.zeoseven.com/dr/main.woff2") format('woff2');
        font-display: swap;
    }
    
    /* 平方星辰体 */
    @import url("https://fontsapi.zeoseven.com/512/main/result.css");
    
    /* 黄凯桦律师手写体 */
    @import url("https://fontsapi.zeoseven.com/223/main/result.css");
  </style>
  <style>
    body { background: #ededed; font-family: "微软雅黑", Arial, sans-serif; margin: 0; -webkit-user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; }
    
    /* 主容器 */
    .app-container { max-width: 420px; margin: 10px auto; background: #f5f5f5; border-radius: 10px; box-shadow: 0 2px 8px #ccc; display: flex; flex-direction: column; height: calc(100vh - 20px); min-height: 600px; }
    @media (max-width: 480px) {
      .app-container { margin: 5px; max-width: none; height: calc(100vh - 10px); border-radius: 0; }
    }
    
    /* 聊天列表界面 */
    .chat-list-view { display: none; flex-direction: column; height: 100%; }
    .chat-list-view.active { display: flex; }
    .chat-list-header { background: #6DA3BD; color: #fff; padding: 16px; border-radius: 10px 10px 0 0; font-size: 20px; display: flex; justify-content: space-between; align-items: center; }
    .header-buttons { display: flex; gap: 10px; }
    .header-btn { background: rgba(255,255,255,0.2); border: none; color: #fff; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 16px; -webkit-tap-highlight-color: transparent; }
    .header-btn:hover { background: rgba(255,255,255,0.3); }
    .header-btn:active { background: rgba(255,255,255,0.4); }
    
    /* AI回复设置面板样式 */
    .ai-settings-panel { background: #fff; padding: 20px; border-bottom: 1px solid #ddd; display: none; max-height: calc(100vh - 200px); overflow-y: auto; }
    .ai-settings-panel.show { display: block; }
    .context-setting { margin-bottom: 20px; }
    .context-input { width: 80px; }
    .setting-textarea { width: 100%; min-height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 6px; resize: vertical; font-family: inherit; font-size: 14px; line-height: 1.5; outline: none; box-sizing: border-box; }
    .setting-textarea:focus { border-color: #6DA3BD; box-shadow: 0 0 0 2px rgba(109, 163, 189, 0.2); }
    
    /* 聊天气泡操作菜单样式 */
          .msg-menu { position: absolute; background: #000; border-radius: 8px; padding: 8px 0; z-index: 1000; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 120px; --arrow-position: 50%; }
.msg-menu::before { content: ''; position: absolute; bottom: -6px; left: var(--arrow-position, 50%); transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid #000; }
    .msg-menu-item { padding: 12px 16px; color: #fff; cursor: pointer; white-space: nowrap; font-size: 14px; text-align: center; }
    .msg-menu-item:hover { background: rgba(255,255,255,0.1); }
    .msg-menu-item.danger { color: #ff4d4f; }
.msg-menu-item.regenerate { color: #52c41a; }
    
    /* 移动端优化 */
    @media (max-width: 768px) {
      .msg-menu { min-width: 140px; font-size: 16px; }
      .msg-menu-item { padding: 14px 20px; }
    }
    
    /* 气泡选中状态 */
    .msg.selected .bubble { background: rgba(26, 136, 230, 0.1) !important; }
    
    /* 消息多选模式样式 */
    .multi-select-mode .msg { cursor: pointer; }
    .multi-select-mode .msg:hover { background: rgba(26, 136, 230, 0.05); }
    .multi-select-mode .msg.selected .bubble { 
      background: rgba(26, 136, 230, 0.1) !important; 
      border: 2px solid #1890ff !important;
    }
    .multi-select-mode .msg-menu { display: none !important; } /* 多选模式下隐藏单个菜单 */
    
    /* 多选工具栏样式 */
    .multi-select-toolbar {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 12px 12px 0 0;
      padding: 16px;
      box-shadow: 0 -2px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      display: none;
      min-width: 300px;
      text-align: center;
    }
    
    .multi-select-toolbar.show {
      display: block;
    }
    
    .multi-select-info {
      color: #666;
      font-size: 14px;
      margin-bottom: 12px;
    }
    
    .multi-select-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .multi-select-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .multi-select-btn.forward {
      background: #1890ff;
      color: white;
    }
    
    .multi-select-btn.forward:hover {
      background: #0e7abe;
    }
    
    .multi-select-btn.cancel {
      background: #f5f5f5;
      color: #666;
    }
    
    .multi-select-btn.cancel:hover {
      background: #e8e8e8;
    }
    
    .multi-select-btn.delete {
      background: #ff4d4f;
      color: white;
    }
    
    .multi-select-btn.delete:hover {
      background: #d32f2f;
    }
    
    @media (max-width: 480px) {
      .multi-select-toolbar {
        left: 8px;
        right: 8px;
        transform: none;
        min-width: unset;
        width: calc(100% - 16px);
      }
    }
    
    /* 回复消息样式 */
    .reply-reference { background: rgba(0,0,0,0.05); border-left: 3px solid #1890ff; padding: 8px 12px; margin-bottom: 8px; border-radius: 4px; font-size: 12px; color: #666; max-height: 60px; overflow: hidden; }
    .reply-reference .reply-from { color: #1890ff; font-weight: bold; margin-bottom: 2px; }
    .reply-reference .reply-content { line-height: 1.4; }
    
    /* 转发消息样式 */
    .forward-message { border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; margin: 4px 0; background: #fafafa; }
    .forward-header { display: flex; align-items: center; margin-bottom: 8px; color: #666; font-size: 12px; }
    .forward-header .icon { margin-right: 4px; }
    .forward-content { color: #333; font-size: 14px; line-height: 1.4; }
    .forward-from { color: #1890ff; font-weight: bold; margin-bottom: 4px; font-size: 12px; }
    
    /* 聊天记录样式 */
    .chat-record { 
      border: 1px solid #e0e0e0; 
      border-radius: 8px; 
      padding: 0; 
      margin: 4px 0; 
      background: #fafafa; 
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .chat-record:hover { background: #f0f0f0; }
    
    .chat-record-header {
      padding: 12px;
      border-bottom: 1px solid #e8e8e8;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .chat-record-title {
      display: flex;
      align-items: center;
      color: #666;
      font-size: 13px;
    }
    
    .chat-record-title .icon {
      margin-right: 6px;
      font-size: 14px;
    }
    
    .chat-record-count {
      color: #999;
      font-size: 12px;
    }
    
    .chat-record-preview {
      padding: 8px 12px;
      max-height: 60px;
      overflow: hidden;
    }
    
    .chat-record-item {
      display: flex;
      align-items: flex-start;
      margin-bottom: 4px;
      font-size: 12px;
      line-height: 1.4;
    }
    
    .chat-record-item:last-child {
      margin-bottom: 0;
    }
    
    .chat-record-sender {
      color: #1890ff;
      font-weight: bold;
      margin-right: 6px;
      min-width: 0;
      white-space: nowrap;
    }
    
    .chat-record-text {
      color: #666;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* 聊天记录展开模态框 */
    .chat-record-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 3000;
      display: none;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .chat-record-modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .chat-record-modal-content {
      background: #fff;
      border-radius: 12px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .chat-record-modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f7f7f7;
    }
    
    .chat-record-modal-title {
      font-size: 16px;
      font-weight: bold;
      color: #333;
    }
    
    .chat-record-modal-close {
      background: none;
      border: none;
      font-size: 20px;
      color: #666;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .chat-record-modal-close:hover {
      background: #e8e8e8;
    }
    
    .chat-record-modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }
    
    .chat-record-detail-item {
      display: flex;
      align-items: flex-start;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .chat-record-detail-item:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .chat-record-detail-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      margin-right: 10px;
      object-fit: cover;
      flex-shrink: 0;
    }
    
    .chat-record-detail-content {
      flex: 1;
      min-width: 0;
    }
    
    .chat-record-detail-sender {
      color: #1890ff;
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 4px;
    }
    
    .chat-record-detail-text {
      color: #333;
      font-size: 14px;
      line-height: 1.4;
      word-wrap: break-word;
    }
    
    .chat-record-detail-time {
      color: #999;
      font-size: 11px;
      margin-top: 4px;
    }
    
    @media (max-width: 480px) {
      .chat-record-modal {
        padding: 10px;
      }
      
      .chat-record-modal-content {
        max-height: 90vh;
      }
      
      .chat-record-modal-header {
        padding: 12px 16px;
      }
      
      .chat-record-modal-body {
        padding: 12px 16px;
      }
    }
    
    /* 转发选择界面样式 */
    .forward-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: none; }
    .forward-modal.show { display: flex; align-items: center; justify-content: center; }
    .forward-content-wrapper { background: #fff; border-radius: 12px; width: 90%; max-width: 400px; max-height: 80%; overflow: hidden; }
    .forward-header-bar { background: #f7f7f7; padding: 16px; border-bottom: 1px solid #e0e0e0; text-align: center; position: relative; }
    .forward-title { font-size: 16px; font-weight: bold; color: #333; }
    .forward-close { position: absolute; right: 16px; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 18px; color: #666; cursor: pointer; }
    .forward-search { padding: 12px 16px; border-bottom: 1px solid #e0e0e0; }
    .forward-search input { width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 20px; outline: none; font-size: 14px; background: #f5f5f5; }
    .forward-chat-list { max-height: 300px; overflow-y: auto; }
    .forward-chat-item { display: flex; align-items: center; padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f0f0f0; }
    .forward-chat-item:hover { background: #f5f5f5; }
    .forward-chat-item.selected { background: #e6f3ff; }
    .forward-chat-avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 12px; object-fit: cover; }
    .forward-chat-info { flex: 1; }
    .forward-chat-name { font-size: 14px; color: #333; margin-bottom: 2px; }
    .forward-chat-desc { font-size: 12px; color: #999; }
    .forward-checkbox { width: 18px; height: 18px; border: 2px solid #ddd; border-radius: 50%; position: relative; }
    .forward-checkbox.checked { background: #1890ff; border-color: #1890ff; }
    .forward-checkbox.checked::after { content: '✓'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 12px; font-weight: bold; }
    .forward-actions { padding: 16px; border-top: 1px solid #e0e0e0; display: flex; gap: 12px; }
    .forward-btn { flex: 1; padding: 10px; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; }
    .forward-cancel { background: #f5f5f5; color: #666; }
    .forward-confirm { background: #1890ff; color: white; }
    .forward-confirm:disabled { background: #d9d9d9; cursor: not-allowed; }
    
    /* 消息预览样式 */
    .forward-preview { padding: 16px; border-bottom: 1px solid #e0e0e0; }
    .forward-preview-title { font-size: 14px; color: #666; margin-bottom: 8px; }
    .forward-preview-content { background: #f9f9f9; padding: 12px; border-radius: 8px; font-size: 13px; color: #333; max-height: 100px; overflow: hidden; }
    
    /* 等待指示器动画 */
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.6; }
      100% { opacity: 1; }
    }
    
    .waiting-indicator {
      animation: pulse 1.5s infinite;
    }
    
    /* 回复状态和等待指示器样式优化 */
    .reply-status, .waiting-indicator {
      margin: 0 12px 8px 12px !important; /* 与chat-footer保持一致的左右边距 */
      border-radius: 8px !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }
    
    @media (max-width: 480px) {
      .reply-status, .waiting-indicator {
        margin: 0 8px 8px 8px !important; /* 移动端减少边距 */
        padding: 10px 12px !important;
        font-size: 11px !important;
      }
    }
    
    .chat-list-body { flex: 1; overflow-y: auto; background: #fff; }
    .chat-item { display: flex; align-items: center; padding: 16px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; }
    .chat-item:hover { background: #f5f5f5; }
    .chat-item:active { background: #eee; }
    .chat-item:last-child { border-bottom: none; }
    
    .chat-item-avatar { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-right: 12px; flex-shrink: 0; }
    .chat-item-content { flex: 1; min-width: 0; }
    .chat-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .chat-item-name { font-weight: bold; font-size: 16px; color: #333; }
    .chat-item-time { font-size: 12px; color: #999; }
    .chat-item-preview { font-size: 14px; color: #666; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
    .chat-item-actions { display: flex; flex-direction: column; gap: 5px; margin-left: 8px; }
    .chat-item-btn { background: #6DA3BD; color: #fff; border: none; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer; min-width: 40px; }
    .chat-item-btn.delete { background: #e74c3c; }
    .chat-item-btn:hover { opacity: 0.8; }
    
    .empty-chat-list { text-align: center; padding: 60px 20px; color: #999; }
    .empty-chat-list .icon { font-size: 60px; margin-bottom: 20px; }
    .empty-chat-list .text { font-size: 16px; margin-bottom: 20px; }
    
    .new-chat-btn { background: #6DA3BD; color: #fff; border: none; border-radius: 25px; padding: 12px 24px; font-size: 16px; cursor: pointer; margin: 0 auto; }
    .new-chat-btn:hover { background: #5a8ba0; }
    
    /* 聊天界面 */
    .chat-view { display: none; flex-direction: column; height: 100%; }
    .chat-view.active { display: flex; }
    
    .chat-container { display: flex; flex-direction: column; height: 100%; }
    .chat-header { background: #6DA3BD; color: #fff; padding: 16px; border-radius: 10px 10px 0 0; font-size: 20px; text-align: center; position: relative; }
    
    /* 聊天标题编辑样式 */
    .chat-title { 
      cursor: pointer; 
      padding: 4px 8px; 
      border-radius: 4px; 
      transition: background-color 0.2s; 
      display: inline-block;
      min-width: 100px;
      max-width: 200px;
      word-break: break-all;
    }
    .chat-title:hover { 
      background-color: rgba(255,255,255,0.1); 
    }
    .chat-title:hover::after {
      content: " ✏️";
      font-size: 14px;
      opacity: 0.7;
    }
    /* 自定义标题标识 */
    .chat-title.custom-title::before {
      content: "📝 ";
      font-size: 12px;
      opacity: 0.6;
    }
    .chat-title-input { 
      background: rgba(255,255,255,0.9); 
      color: #333; 
      border: none; 
      padding: 4px 8px; 
      border-radius: 4px; 
      font-size: 20px; 
      text-align: center; 
      min-width: 100px;
      max-width: 200px;
      outline: none;
    }
    
    /* 标题编辑容器样式 */
    .chat-title-edit-container {
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      animation: titleEditSlideIn 0.3s ease-out;
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 8px;
      z-index: 1000;
    }
    
    @keyframes titleEditSlideIn {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0) scale(1);
      }
    }
    
    .chat-title-edit-container input:focus {
      outline: none;
      border-color: #07c160 !important;
      box-shadow: 0 0 0 3px rgba(7, 193, 96, 0.2);
    }
    
    .chat-title-edit-container button:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    .chat-title-edit-container button:active {
      transform: scale(0.98);
    }
    
    /* 为了确保编辑容器不被遮挡，给聊天标题一个相对定位 */
    .chat-title {
      position: relative;
    }
    .back-btn { position: absolute; left: 16px; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); border: none; color: #fff; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 16px; -webkit-tap-highlight-color: transparent; display: flex; align-items: center; justify-content: center; }
    .back-btn:hover { background: rgba(255,255,255,0.3); }
    .back-btn:active { background: rgba(255,255,255,0.4); }
    .back-btn svg { flex-shrink: 0; }
    
    .settings-btn { position: absolute; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); border: none; color: #fff; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 16px; -webkit-tap-highlight-color: transparent; }
    .settings-btn:hover { background: rgba(255,255,255,0.3); }
    .settings-btn:active { background: rgba(255,255,255,0.4); }
    #themeBtn { right: 104px; }
    #userBtn { right: 60px; }
    #roleBtn { right: 16px; }
    @media (max-width: 480px) {
      .settings-btn { width: 36px; height: 36px; font-size: 18px; }
      .back-btn { width: 36px; height: 36px; }
      #themeBtn { right: 96px; }
      #userBtn { right: 56px; }
      #roleBtn { right: 12px; }
    }
    .settings-panel { 
      background: #fff; 
      padding: 20px; 
      border-bottom: 1px solid #ddd; 
      display: none; 
      max-height: calc(100vh - 200px); 
      overflow-y: auto;
      padding-right: 15px;
      margin-right: 5px;
    }
    .settings-panel.show { display: block; }
    
    /* 用户设定和角色设定面板滚动样式 */
    #userPanel, #rolePanel {
      max-height: calc(100vh - 200px);
      overflow-y: auto;
      padding-right: 15px;
      margin-right: 5px;
    }
    
    /* 移动端优化 */
    @media (max-width: 480px) {
      #userPanel, #rolePanel, #settingsPanel, #emojiPanel {
        max-height: calc(100vh - 150px);
        padding-right: 10px;
        margin-right: 0px;
      }
    }
    
    /* 滚动条样式优化 */
    #userPanel::-webkit-scrollbar, #rolePanel::-webkit-scrollbar, #settingsPanel::-webkit-scrollbar, #emojiPanel::-webkit-scrollbar, #userEmojiPanel::-webkit-scrollbar {
      width: 6px;
    }
    
    #userPanel::-webkit-scrollbar-track, #rolePanel::-webkit-scrollbar-track, #settingsPanel::-webkit-scrollbar-track, #emojiPanel::-webkit-scrollbar-track, #userEmojiPanel::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    #userPanel::-webkit-scrollbar-thumb, #rolePanel::-webkit-scrollbar-thumb, #settingsPanel::-webkit-scrollbar-thumb, #emojiPanel::-webkit-scrollbar-thumb, #userEmojiPanel::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
      transition: background 0.3s ease;
    }
    
    #userPanel::-webkit-scrollbar-thumb:hover, #rolePanel::-webkit-scrollbar-thumb:hover, #settingsPanel::-webkit-scrollbar-thumb:hover, #emojiPanel::-webkit-scrollbar-thumb:hover, #userEmojiPanel::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }
    
    /* 为Firefox浏览器添加滚动条样式 */
    #userPanel, #rolePanel, #settingsPanel, #emojiPanel, #userEmojiPanel {
      scrollbar-width: thin;
      scrollbar-color: #c1c1c1 #f1f1f1;
      scroll-behavior: smooth;
    }
    .setting-group { margin-bottom: 15px; }
    .setting-label { display: block; margin-bottom: 5px; font-weight: bold; color: #333; }
    .setting-input { width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; box-sizing: border-box; resize: vertical; font-family: inherit; }
    .setting-select { width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; box-sizing: border-box; background: #fff; }
    .setting-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
    .setting-btn { padding: 12px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; min-height: 44px; -webkit-tap-highlight-color: transparent; }
    .save-btn { background: #6DA3BD; color: #fff; }
    .save-btn:hover { background: #5a8ba0; }
    .cancel-btn { background: #95a5a6; color: #fff; }
    .cancel-btn:hover { background: #7f8c8d; }
    .test-btn { background: #3498db; color: #fff; }
    .test-btn:hover { background: #2980b9; }
    .test-btn:disabled { background: #bdc3c7; cursor: not-allowed; }
    .refresh-models-btn { background: #9b59b6; color: #fff; }
    .refresh-models-btn:hover { background: #8e44ad; }
    .refresh-models-btn:disabled { background: #bdc3c7; cursor: not-allowed; }
    
    /* API配置管理样式 */
    .api-config-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      margin-bottom: 8px;
    }
    
    .api-config-item.active {
      background: #e7f3ff;
      border-color: #6DA3BD;
    }
    
    .api-config-info {
      flex: 1;
      min-width: 0;
    }
    
    .api-config-name {
      font-weight: bold;
      color: #333;
      margin-bottom: 2px;
    }
    
    .api-config-details {
      font-size: 11px;
      color: #666;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .api-config-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
    }
    
    .api-config-actions button {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      min-width: 50px;
    }
    .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-left: 10px; }
    .status-ready { background: #6DA3BD; }
    .status-error { background: #e74c3c; }
    .status-testing { background: #f39c12; animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    /* 主题设置样式 */
    .theme-preset-btn {
      background: #f8f9fa;
      border: 2px solid #e9ecef;
      color: #495057;
      padding: 12px 8px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      text-align: center;
    }
    .theme-preset-btn:hover {
      background: #e9ecef;
      border-color: #6DA3BD;
    }
    .theme-preset-btn.active {
      background: #6DA3BD;
      border-color: #6DA3BD;
      color: white;
    }
    
    .color-setting-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .color-label {
      min-width: 100px;
      font-weight: bold;
      color: #333;
    }
    .color-input {
      width: 50px;
      height: 35px;
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      padding: 0;
    }
    .color-text {
      width: 100px;
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      font-family: monospace;
    }
    
    .font-setting-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .font-label {
      min-width: 100px;
      font-weight: bold;
      color: #333;
    }
    
    .style-setting-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .style-label {
      min-width: 120px;
      font-weight: bold;
      color: #333;
    }
    .style-slider {
      flex: 1;
      min-width: 150px;
    }
    .style-value {
      min-width: 60px;
      font-weight: bold;
      color: #6DA3BD;
    }
    
    .theme-preview {
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      background: #f5f5f5;
    }
    .preview-header {
      background: #6DA3BD;
      color: white;
      padding: 12px;
      text-align: center;
      font-weight: bold;
    }
    .preview-chat {
      padding: 15px;
      background: #f5f5f5;
      min-height: 120px;
    }
    .preview-msg {
      display: flex;
      margin-bottom: 10px;
    }
    .preview-msg.user {
      justify-content: flex-end;
    }
    .preview-msg.ai {
      justify-content: flex-start;
    }
    .preview-bubble {
      max-width: 70%;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 14px;
    }
    .preview-bubble.user {
      background: #95EC69;
      color: #333;
    }
    .preview-bubble.ai {
      background: white;
      color: #333;
      border: 1px solid #eee;
    }
    .test-result { margin-top: 10px; padding: 8px 12px; border-radius: 6px; font-size: 12px; }
    .test-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .test-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .test-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    .model-info { font-size: 12px; color: #666; margin-top: 5px; }
    .chat-body { flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; background-image: url('https://i.postimg.cc/LsfcNN6t/IMG-20250617-214650.jpg'); background-size: cover; background-position: center; background-repeat: no-repeat; }
    .msg { display: flex; margin-bottom: 8px; align-items: flex-end; }
    .msg.user { justify-content: flex-end; margin-bottom: 12px; }
    .msg.ai { justify-content: flex-start; }
    .msg.ai + .msg.ai { margin-bottom: 6px; }
    .msg.ai:last-child { margin-bottom: 12px; }
    
    .avatar { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .msg.user .avatar { margin-left: 8px; order: 2; }
    .msg.ai .avatar { margin-right: 8px; order: 1; }
    
    .bubble { max-width: 75%; padding: 10px 16px; border-radius: 18px; font-size: 16px; line-height: 1.5; position: relative; }
    .msg.user .bubble { background: rgba(149, 236, 105, 0.95); color: #222; border-bottom-right-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); order: 1; }
    .msg.ai .bubble { background: rgba(255, 255, 255, 0.95); color: #222; border-bottom-left-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); order: 2; }
    
    /* 微信风格独立时间显示 */
    .msg-time { 
      font-size: 12px; 
      color: rgba(0,0,0,0.6); 
      text-align: center;
      margin: 10px 0 8px 0;
      width: 100%;
      display: flex;
      justify-content: center;
      position: relative;
    }
    
    .msg-time span {
      background: rgba(0,0,0,0.05);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      color: rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
    }
    
    /* 气泡容器样式调整 */
    .bubble-container {
      display: flex;
      flex-direction: column;
      max-width: 75%;
    }
    .msg.user .bubble-container {
      align-items: flex-end;
      order: 1;
    }
    .msg.ai .bubble-container {
      align-items: flex-start;
      order: 2;
    }
    
    /* 表情包气泡容器特殊处理 */
    .bubble-container.emoji-container-wrapper {
      max-width: 150px !important; /* 为表情包设置更小的最大宽度 */
    }
    
    /* 表情包容器样式 */
    .emoji-container {
      width: 120px !important;
      height: 120px !important;
      overflow: hidden;
      border-radius: 8px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f0f0f0;
    }
    
    .emoji-container img {
      width: 100% !important;
      height: 100% !important;
      object-fit: cover !important;
      display: block !important;
    }
    .bubble[data-streaming="true"] { position: relative; }
    .bubble[data-streaming="true"]:after { 
      content: '▋'; 
      color: #6DA3BD; 
      animation: blink 1s infinite; 
      margin-left: 2px; 
    }
    @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
    
    /* 表情包设置相关样式 */
    .emotion-tabs { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
    .emotion-tab { padding: 8px 16px; border: 1px solid #ddd; border-radius: 20px; background: #fff; cursor: pointer; font-size: 14px; transition: all 0.3s; }
    .emotion-tab:hover { background: #f0f0f0; }
    .emotion-tab.active { background: #6DA3BD; color: #fff; border-color: #6DA3BD; }
    
    .emoji-gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-bottom: 20px; max-height: 300px; overflow-y: auto; padding: 10px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9; }
    .emoji-item { position: relative; border-radius: 8px; overflow: hidden; aspect-ratio: 1; cursor: pointer; transition: transform 0.2s; }
    .emoji-item:hover { transform: scale(1.05); }
    .emoji-item img { width: 100%; height: 100%; object-fit: cover; }
    .emoji-item .delete-btn { position: absolute; top: 2px; right: 2px; background: rgba(231, 76, 60, 0.8); color: #fff; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer; display: none; }
    .emoji-item:hover .delete-btn { display: block; }
    
    @media (max-width: 480px) {
      .emotion-tabs { gap: 5px; }
      .emotion-tab { padding: 6px 12px; font-size: 12px; }
      .emoji-gallery { grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
    }
    .chat-footer { 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
      padding: 12px; 
      background: #fafafa; 
      border-radius: 0 0 10px 10px; 
    }
    
    .chat-input-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .chat-buttons-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: flex-start;
      padding: 0 4px;
      border-top: 1px solid #f0f0f0;
      padding-top: 8px;
      margin-top: 4px;
    }
    
    .chat-button-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    
    .chat-button-label {
      font-size: 11px;
      color: #666;
      line-height: 1;
    }
    .chat-input { flex: 1; padding: 12px 16px; border: 1px solid #ddd; border-radius: 18px; font-size: 16px; outline: none; -webkit-appearance: none; -webkit-tap-highlight-color: transparent; }
    .send-btn { background: #6DA3BD; color: #fff; border: none; border-radius: 18px; padding: 12px 24px; font-size: 16px; cursor: pointer; min-height: 44px; -webkit-tap-highlight-color: transparent; }
    .send-btn:active { background: #5a8ba0; }
    .send-btn:disabled { background: #bdc3c7; cursor: not-allowed; }
    .emoji-btn { background: #fff; border: 1px solid #ddd; border-radius: 50%; width: 44px; height: 44px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; -webkit-tap-highlight-color: transparent; }
    .emoji-btn:hover { background: #f0f0f0; border-color: #6DA3BD; }
    .emoji-btn:active { background: #e0e0e0; }
    
    /* 位置按钮样式 */
    .location-btn { background: #fff; border: 1px solid #ddd; border-radius: 50%; width: 44px; height: 44px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; -webkit-tap-highlight-color: transparent; }
    .location-btn:hover { background: #f0f0f0; border-color: #6DA3BD; }
    .location-btn:active { background: #e0e0e0; }
    
    /* 转账按钮样式 */
    .transfer-btn { background: #fff; border: 1px solid #ddd; border-radius: 50%; width: 44px; height: 44px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; -webkit-tap-highlight-color: transparent; }
    .transfer-btn:hover { background: #f0f0f0; border-color: #6DA3BD; }
    .transfer-btn:active { background: #e0e0e0; }
    
    /* 图片按钮样式 */
    .image-btn { background: #fff; border: 1px solid #ddd; border-radius: 50%; width: 44px; height: 44px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; -webkit-tap-highlight-color: transparent; }
    .image-btn:hover { background: #f0f0f0; border-color: #6DA3BD; }
    .image-btn:active { background: #e0e0e0; }
    
    /* 用户表情包面板样式 */
    .user-emoji-panel { position: absolute; bottom: 120px; left: 12px; right: 12px; background: #fff; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 1000; display: none; max-height: 300px; }
    .user-emoji-panel.show { display: block; }
    .user-emoji-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid #eee; }
    .user-emoji-title { font-size: 14px; font-weight: bold; color: #333; }
    .user-emoji-close { background: none; border: none; font-size: 18px; color: #999; cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border-radius: 50%; }
    .user-emoji-close:hover { background: #f0f0f0; color: #333; }
    .user-emoji-grid { padding: 12px; display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; max-height: 200px; overflow-y: auto; }
    .user-emoji-item { aspect-ratio: 1; border-radius: 8px; overflow: hidden; cursor: pointer; transition: transform 0.2s; border: 2px solid transparent; }
    .user-emoji-item:hover { transform: scale(1.05); border-color: #6DA3BD; }
    .user-emoji-item:active { transform: scale(0.95); }
    .user-emoji-item img { width: 100%; height: 100%; object-fit: cover; }
    .user-emoji-empty { grid-column: 1/-1; text-align: center; color: #999; padding: 20px; font-size: 14px; }
    .user-emoji-empty .icon { font-size: 32px; margin-bottom: 8px; display: block; }
    
    /* 表情包气泡样式 */
    .emoji-bubble { 
      background: transparent !important; 
      padding: 4px !important; 
      box-shadow: none !important; 
      border: none !important;
      max-width: 140px !important; /* 限制最大宽度，避免遮挡头像 */
      width: auto !important;
    }
    .emoji-container { 
      border-radius: 8px; 
      overflow: hidden; 
      width: 120px !important;
      height: 120px !important;
    }
    
    /* 位置消息气泡样式 */
    .location-bubble {
      background: #fff !important;
      border: 1px solid #e0e0e0 !important;
      border-radius: 12px !important;
      padding: 0 !important;
      max-width: 260px !important;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }
    .location-container {
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
    }
    .location-container:hover {
      background: #f5f5f5;
    }
    .location-image {
      width: 100%;
      height: 120px;
      object-fit: cover;
      display: block;
    }
    .location-info {
      padding: 12px 16px;
      border-top: 1px solid #f0f0f0;
    }
    .location-name {
      font-size: 16px;
      font-weight: 500;
      color: #333;
      margin-bottom: 4px;
      line-height: 1.3;
    }
    .location-address {
      font-size: 13px;
      color: #666;
      line-height: 1.4;
    }
    .location-icon {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0,0,0,0.6);
      color: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    
    /* 转账消息气泡样式 */
    .transfer-bubble {
      background: #fff !important;
      border: 1px solid #e0e0e0 !important;
      border-radius: 12px !important;
      padding: 0 !important;
      max-width: 280px !important;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }
    .transfer-container {
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: white;
    }
    .transfer-container:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    .transfer-header {
      padding: 16px 20px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    .transfer-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .transfer-icon {
      font-size: 20px;
    }
    .transfer-subtitle {
      font-size: 13px;
      opacity: 0.9;
    }
    .transfer-body {
      padding: 12px 20px 16px;
    }
    .transfer-amount {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 4px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .transfer-note {
      font-size: 14px;
      opacity: 0.9;
      margin-bottom: 8px;
      line-height: 1.3;
    }
    .transfer-status {
      font-size: 12px;
      opacity: 0.8;
      display: flex;
      align-items: center;
      gap: 4px;
    }
          .transfer-status-icon {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: rgba(255,255,255,0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 8px;
      }
      
      /* 图片消息样式 */
      .image-bubble {
        background: transparent !important;
        border: none !important;
        padding: 0 !important;
        border-radius: 12px;
        overflow: hidden;
        max-width: 300px;
      }
      
      .image-message {
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        background: #f5f5f5;
        min-height: 100px;
        display: flex;
        flex-direction: column;
      }
      
      .image-message img {
        width: 100%;
        height: auto;
        max-height: 400px;
        object-fit: cover;
        display: block;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      
      .image-message img:hover {
        transform: scale(1.02);
      }
      
      .image-message-text {
        padding: 12px;
        background: rgba(255, 255, 255, 0.95);
        font-size: 14px;
        line-height: 1.4;
        color: #333;
        border-top: 1px solid #eee;
      }
      
      .image-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100px;
        background: #f5f5f5;
        color: #666;
        font-size: 14px;
      }
      
      .image-error {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100px;
        background: #ffeaea;
        color: #d63031;
        font-size: 14px;
        border: 1px solid #fab1a0;
      }
    @media (max-width: 480px) {
      .chat-footer { padding: 8px; gap: 6px; }
      .chat-input-row { gap: 6px; }
      .chat-buttons-row { gap: 8px; padding: 0 2px; }
      .chat-button-item { gap: 2px; }
      .chat-button-label { font-size: 10px; }
      .chat-input { font-size: 16px; padding: 10px 14px; }
      .send-btn { padding: 10px 20px; min-width: 60px; }
      .emoji-btn { width: 40px; height: 40px; font-size: 16px; }
      .image-btn { width: 40px; height: 40px; font-size: 16px; }
      .location-btn { width: 40px; height: 40px; font-size: 16px; }
      .transfer-btn { width: 40px; height: 40px; font-size: 16px; }
      .video-call-btn { width: 40px; height: 40px; font-size: 16px; }
      .avatar { width: 50px; height: 50px; }
      .msg.user .avatar { margin-left: 8px; }
      .msg.ai .avatar { margin-right: 8px; }
      
      /* 移动端聊天气泡宽度优化 */
      .bubble { max-width: 85% !important; }
      .bubble-container { max-width: 85% !important; }
      
      /* 移动端消息间距调整 */
      .msg { margin-bottom: 16px !important; }
      .msg.user + .msg.user { margin-bottom: 8px !important; }
      .msg.ai + .msg.ai { margin-bottom: 8px !important; }
      
      .user-emoji-panel { bottom: 100px; left: 8px; right: 8px; max-height: 250px; }
      .user-emoji-grid { grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 6px; }
      
      /* 移动端表情包尺寸调整 */
      .emoji-container { 
        width: 110px !important; 
        height: 110px !important; 
      }
      .emoji-bubble { 
        max-width: 120px !important; 
      }
      
      /* 移动端位置消息尺寸调整 */
      .location-bubble {
        max-width: 280px !important;
      }
      .location-image {
        height: 100px !important;
      }
      
      /* 移动端位置弹窗优化 */
      .location-modal-content {
        width: 95%;
        max-height: 95vh;
        margin: 10px;
      }
      
      .location-modal-header {
        padding: 12px 16px;
      }
      
      .location-modal-title {
        font-size: 16px;
      }
      
      .location-modal-body {
        padding: 16px;
      }
      
      .location-modal-footer {
        padding: 12px 16px;
      }
      
      .location-preview-image {
        height: 150px !important;
      }
      
      .location-form-input {
        font-size: 16px;
      }
      
      /* 移动端转账消息尺寸调整 */
      .transfer-bubble {
        max-width: 280px !important;
      }
      .transfer-amount {
        font-size: 24px !important;
      }
      
      /* 移动端转账弹窗优化 */
      .transfer-modal-content {
        width: 95%;
        max-height: 95vh;
        margin: 10px;
        box-sizing: border-box;
      }
      
      .transfer-modal-header {
        padding: 12px 16px;
      }
      
      .transfer-modal-title {
        font-size: 16px;
      }
      
      .transfer-modal-body {
        padding: 16px;
        box-sizing: border-box;
      }
      
      .transfer-modal-footer {
        padding: 12px 16px;
      }
      
      .transfer-form-input {
        font-size: 16px;
      }
      
      .transfer-amount-input {
        font-size: 20px !important;
      }
      
      .transfer-preview-amount {
        font-size: 28px !important;
      }
    }
    
    /* 群聊相关样式 */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center; }
    .modal-content { background: #fff; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; }
    .modal-header { padding: 20px 20px 0; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h3 { margin: 0; color: #333; }
    .modal-close { background: none; border: none; font-size: 24px; color: #999; cursor: pointer; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; }
    .modal-close:hover { color: #333; }
    .modal-body { padding: 20px; }
    .modal-footer { padding: 0 20px 20px; display: flex; gap: 10px; justify-content: flex-end; }
    
    .role-item { display: flex; align-items: center; padding: 12px; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 10px; background: #f9f9f9; }
    .role-item-avatar { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; margin-right: 12px; }
    .role-item-info { flex: 1; }
    .role-item-name { font-weight: bold; color: #333; margin-bottom: 4px; }
    .role-item-desc { font-size: 12px; color: #666; line-height: 1.4; }
    .role-item-frequency { font-size: 11px; color: #999; margin-top: 2px; }
    .role-item-actions { display: flex; flex-direction: column; gap: 5px; }
    .role-item-btn { padding: 4px 8px; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; min-width: 50px; }
    .role-item-btn.edit { background: #3498db; color: #fff; }
    .role-item-btn.delete { background: #e74c3c; color: #fff; }
    .role-item-btn:hover { opacity: 0.8; }
    
    .group-chat-indicator { display: inline-block; background: #9b59b6; color: #fff; font-size: 10px; padding: 2px 6px; border-radius: 10px; margin-left: 8px; }
    
    /* 预设管理相关样式 */
    .preset-item { display: flex; align-items: center; padding: 12px; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 10px; background: #f9f9f9; }
    .preset-item-info { flex: 1; }
    .preset-item-name { font-weight: bold; color: #333; margin-bottom: 4px; }
    .preset-item-desc { font-size: 12px; color: #666; line-height: 1.4; }
    .preset-item-type { font-size: 11px; color: #999; margin-top: 2px; }
    .preset-item-actions { display: flex; gap: 5px; }
    .preset-item-btn { padding: 4px 8px; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; min-width: 50px; }
    .preset-item-btn.use { background: #3498db; color: #fff; }
    .preset-item-btn.delete { background: #e74c3c; color: #fff; }
    .preset-item-btn:hover { opacity: 0.8; }
    .preset-item.builtin { background: #e8f5e8; border-color: #c3e6c3; }
    .preset-item.custom { background: #f0f8ff; border-color: #b3d9ff; }
    
    /* 群聊消息显示 */
    .msg.group { 
      margin-bottom: 12px; 
      position: relative; 
    }
    
    /* 群聊中AI消息都需要上边距为角色名称留空间 */
    .msg.group.ai {
      margin-top: 20px;
    }
    
    /* 角色名称样式 */
    .msg.group .role-name { 
      font-size: 12px; 
      color: #666; 
      margin-bottom: 4px; 
      position: absolute;
      top: -18px;
      left: 53px;
      z-index: 1;
      white-space: nowrap;
    }
    .msg.group.user .role-name { 
      left: auto;
      right: 53px; 
      text-align: right; 
    }
    
    /* 文件上传相关样式 */
    .upload-area {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      margin: 10px 0;
      transition: all 0.3s ease;
      background: #fafafa;
    }
    
    .upload-area:hover {
      border-color: #007AFF;
      background: #f0f8ff;
    }
    
    .upload-area.dragover {
      border-color: #007AFF;
      background: #e6f3ff;
      transform: scale(1.02);
    }
    
    .upload-btn {
      background: #17a2b8 !important;
      color: white !important;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    
    .upload-btn:hover {
      background: #138496 !important;
    }
    
    .upload-btn:disabled {
      background: #6c757d !important;
      cursor: not-allowed;
    }
    
    .file-info {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    
    .preview-image {
      max-width: 100px;
      max-height: 100px;
      border-radius: 4px;
      margin-top: 10px;
      border: 1px solid #ddd;
    }
    
    /* 拖拽上传提示 */
    .drag-hint {
      color: #999;
      font-size: 12px;
      margin-top: 5px;
    }
    
    /* 群聊中第一条消息的上边距 */
    .msg.group:first-child { 
      margin-top: 20px; 
    }
    
    /* 用户消息后的AI消息需要额外间距 */
    .msg.group.user + .msg.group.ai { 
      margin-top: 24px; 
    }
    
    /* 连续AI消息的间距调整 */
    .msg.group.ai + .msg.group.ai {
      margin-top: 16px; /* 稍微紧密一些，但仍为名称留空间 */
    }
    
    @media (max-width: 480px) {
      .modal-content { width: 95%; max-height: 90vh; }
      .modal-header, .modal-body, .modal-footer { padding: 15px; }
      .role-item { padding: 10px; }
      .role-item-avatar { width: 35px; height: 35px; }
      
      /* 移动端群聊角色名称调整 */
      .msg.group .role-name { 
        left: 58px; 
        font-size: 11px;
        top: -16px;
      }
      .msg.group.user .role-name { 
        right: 58px; 
      }
    }
    
    /* 朋友圈界面样式 */
    .moments-view { display: none; flex-direction: column; height: 100%; background: #f7f7f7; }
    .moments-view.active { display: flex; }
    
    .moments-header { 
      background: linear-gradient(135deg, #6DA3BD 0%, #8BC34A 100%); 
      color: #fff; 
      padding: 16px; 
      border-radius: 10px 10px 0 0; 
      position: relative;
      height: 200px;
      background-image: url('https://i.postimg.cc/7Lr42Xqf/IMG-20250618-215711.jpg');
      background-size: cover;
      background-position: center;
      background-blend-mode: overlay;
    }
    
    .moments-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: none;
      border-radius: 10px 10px 0 0;
    }
    
    .moments-header-content {
      position: relative;
      z-index: 2;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      height: 100%;
    }
    
    .moments-back-btn { 
      background: rgba(0,0,0,0.4); 
      border: none; 
      color: #fff; 
      border-radius: 50%; 
      width: 36px; 
      height: 36px; 
      cursor: pointer; 
      font-size: 18px; 
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }
    .moments-back-btn:hover { background: rgba(0,0,0,0.6); }
    
    .moments-user-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      margin-top: auto;
      margin-bottom: 20px;
    }
    
    .moments-user-name {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 8px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .moments-user-avatar {
      width: 80px;
      height: 80px;
      border-radius: 8px;
      object-fit: cover;
      border: 3px solid rgba(255,255,255,0.8);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .moments-content { 
      flex: 1; 
      overflow-y: auto; 
      background: #f7f7f7; 
      padding: 0;
    }
    
    .moments-publish-area {
      background: #fff;
      padding: 15px;
      border-bottom: 8px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .publish-avatar {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      object-fit: cover;
    }
    
    .publish-text {
      flex: 1;
      background: #f5f5f5;
      border: none;
      padding: 12px;
      border-radius: 6px;
      font-size: 16px;
      color: #999;
      cursor: pointer;
      outline: none;
    }
    
    .moments-list {
      background: #f7f7f7;
    }
    
    .moment-item {
      background: #fff;
      margin-bottom: 8px;
      padding: 15px;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .moment-header {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 12px;
    }
    
    .moment-avatar {
      width: 45px;
      height: 45px;
      border-radius: 6px;
      object-fit: cover;
      flex-shrink: 0;
    }
    
    .moment-author-info {
      flex: 1;
    }
    
    .moment-author {
      font-weight: bold;
      color: #576b95;
      font-size: 16px;
      margin-bottom: 4px;
    }
    
    .moment-content-text {
      font-size: 16px;
      line-height: 1.5;
      color: #333;
      margin-bottom: 12px;
      word-break: break-word;
    }
    
    .moment-images {
      display: grid;
      gap: 4px;
      margin-bottom: 12px;
    }
    
    .moment-images.single { grid-template-columns: 1fr; max-width: 200px; }
    .moment-images.two { grid-template-columns: 1fr 1fr; max-width: 300px; }
    .moment-images.three { grid-template-columns: 1fr 1fr 1fr; }
    .moment-images.four { grid-template-columns: 1fr 1fr; }
    .moment-images.five { grid-template-columns: 1fr 1fr 1fr; }
    .moment-images.six { grid-template-columns: 1fr 1fr 1fr; }
    .moment-images.seven { grid-template-columns: 1fr 1fr 1fr; }
    .moment-images.eight { grid-template-columns: 1fr 1fr 1fr; }
    .moment-images.nine { grid-template-columns: 1fr 1fr 1fr; }
    
    .moment-image {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .moment-image:hover {
      transform: scale(1.02);
    }
    
    .moment-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: #999;
    }
    
    .moment-time {
      font-size: 13px;
      color: #999;
    }
    
    .moment-actions {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    
    .moment-like-btn, .moment-comment-btn {
      background: none;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s;
    }
    
    .moment-like-btn:hover, .moment-comment-btn:hover {
      background: #f0f0f0;
    }
    
    .moment-like-btn.liked {
      color: #e74c3c;
    }
    
    .moment-comments {
      background: #f7f7f7;
      margin-top: 12px;
      padding: 0;
      border-radius: 4px;
      font-size: 14px;
      display: none;
    }
    
    .moment-comments.show {
      display: block;
    }
    
    .comments-header {
      padding: 8px 12px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f0f0f0;
      border-radius: 4px 4px 0 0;
    }
    
    .comments-title {
      font-weight: bold;
      color: #666;
      font-size: 13px;
    }
    
    .comments-toggle {
      background: none;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 3px;
    }
    
    .comments-toggle:hover {
      background: #ddd;
    }
    
    .comments-list {
      max-height: 300px;
      overflow-y: auto;
      padding: 8px 12px;
    }
    
    .comments-list.collapsed {
      max-height: 60px;
      overflow: hidden;
    }
    
    .moment-comment {
      margin-bottom: 8px;
      line-height: 1.4;
      position: relative;
      padding: 4px 0;
    }
    
    .moment-comment:last-child {
      margin-bottom: 0;
    }
    
    .comment-author {
      color: #576b95;
      font-weight: bold;
      cursor: pointer;
    }
    
    .comment-author:hover {
      text-decoration: underline;
    }
    
    .comment-text {
      color: #333;
    }
    
    .comment-reply {
      color: #576b95;
      font-weight: bold;
    }
    
    .comment-mention {
      color: #576b95;
      font-weight: bold;
      background: #e8f4f8;
      padding: 0 2px;
      border-radius: 2px;
    }
    
    .comment-time {
      color: #999;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .comment-actions {
      display: none;
      position: absolute;
      right: 0;
      top: 2px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 2px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      z-index: 10;
    }
    
    .moment-comment:hover .comment-actions {
      display: block;
    }
    
    .reply-btn {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 2px;
    }
    
    .reply-btn:hover {
      background: #f0f0f0;
    }
    
    .comment-input-area {
      padding: 8px 12px;
      border-top: 1px solid #e0e0e0;
      background: #fff;
    }
    
    .comment-input-container {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      position: relative;
    }
    
    .comment-input {
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px 10px;
      font-size: 14px;
      outline: none;
      resize: none;
      min-height: 20px;
      max-height: 80px;
      line-height: 1.4;
      font-family: inherit;
    }
    
    .comment-input:focus {
      border-color: #6DA3BD;
    }
    
    .comment-send-btn {
      background: #6DA3BD;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      white-space: nowrap;
    }
    
    .comment-send-btn:hover {
      background: #5a8ba0;
    }
    
    .comment-send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .reply-indicator {
      background: #e8f4f8;
      padding: 4px 8px;
      margin: 4px 0;
      border-radius: 4px;
      font-size: 12px;
      color: #666;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .cancel-reply {
      background: none;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 12px;
      padding: 0;
    }
    
    .cancel-reply:hover {
      color: #666;
    }
    
    .mention-suggestions {
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 -2px 6px rgba(0,0,0,0.1);
      max-height: 150px;
      overflow-y: auto;
      z-index: 20;
      display: none;
    }
    
    .mention-suggestions.show {
      display: block;
    }
    
    .mention-item {
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .mention-item:last-child {
      border-bottom: none;
    }
    
    .mention-item:hover {
      background: #f5f5f5;
    }
    
    .mention-item.selected {
      background: #e8f4f8;
    }
    
    .mention-avatar {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      object-fit: cover;
    }
    
    .mention-name {
      font-weight: bold;
      color: #333;
    }
    
    /* 发布朋友圈弹窗 */
    .publish-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .publish-modal.show {
      display: flex;
    }
    
    .publish-modal-content {
      background: #fff;
      width: 90%;
      max-width: 400px;
      border-radius: 10px;
      overflow: hidden;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }
    
    .publish-modal-header {
      background: #6DA3BD;
      color: #fff;
      padding: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .publish-modal-title {
      font-size: 18px;
      font-weight: bold;
    }
    
    .publish-modal-close {
      background: none;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .publish-modal-close:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .publish-modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .publish-textarea {
      width: 100%;
      border: none;
      outline: none;
      font-size: 16px;
      line-height: 1.5;
      resize: none;
      min-height: 120px;
      font-family: inherit;
      color: #333;
    }
    
    .publish-images-container {
      margin-top: 15px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    
    .publish-image-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 6px;
      overflow: hidden;
      background: #f5f5f5;
      border: 1px dashed #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .publish-image-item.has-image {
      border: none;
    }
    
    .publish-image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .publish-image-remove {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .publish-add-image {
      font-size: 24px;
      color: #999;
    }
    
    .publish-visibility {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #f0f0f0;
    }
    
    .visibility-label {
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .visibility-options {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .visibility-option {
      background: #f5f5f5;
      border: 1px solid #ddd;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    
    .visibility-option.selected {
      background: #6DA3BD;
      color: #fff;
      border-color: #6DA3BD;
    }
    
    .visibility-option.disabled {
      background: #f0f0f0;
      color: #999;
      border-color: #e0e0e0;
      cursor: not-allowed;
    }
    
    .publish-modal-footer {
      padding: 15px 20px;
      border-top: 1px solid #f0f0f0;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .publish-btn {
      background: #6DA3BD;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .publish-btn:hover {
      background: #5a8ba0;
    }
    
    .publish-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .cancel-btn {
      background: #95a5a6;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .cancel-btn:hover {
      background: #7f8c8d;
    }
    
    /* 图片预览弹窗 */
    .image-preview-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .image-preview-modal.show {
      display: flex;
    }
    
    .image-preview-content {
      max-width: 90%;
      max-height: 90%;
      object-fit: contain;
    }
    
    .image-preview-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: #fff;
      font-size: 24px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .image-preview-close:hover {
      background: rgba(255,255,255,0.3);
    }

    /* 位置选择弹窗 */
    .location-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .location-modal.show {
      display: flex;
    }
    
    .location-modal-content {
      background: #fff;
      border-radius: 12px;
      width: 90%;
      max-width: 480px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    
    .location-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid #f0f0f0;
      background: #fafafa;
      flex-shrink: 0;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    
    .location-modal-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
    }
    
    .location-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: #999;
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    }
    
    .location-modal-close:hover {
      background: #f0f0f0;
      color: #333;
    }
    
    .location-modal-body {
      padding: 20px;
      flex: 1;
      overflow: visible;
    }
    
    .location-preview {
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 20px;
      background: #fff;
    }
    
    .location-preview-image {
      width: 100%;
      height: 180px;
      object-fit: cover;
      display: block;
      background: #f5f5f5;
    }
    
    .location-preview-info {
      padding: 16px;
    }
    
    .location-form-group {
      margin-bottom: 16px;
    }
    
    .location-form-label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      color: #333;
      margin-bottom: 6px;
    }
    
    .location-form-input {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      outline: none;
      transition: border-color 0.2s;
    }
    
    .location-form-input:focus {
      border-color: #6DA3BD;
      box-shadow: 0 0 0 2px rgba(109, 163, 189, 0.2);
    }
    
    .location-form-textarea {
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }
    
    .location-image-upload {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      background: #fafafa;
    }
    
    .location-image-upload:hover {
      border-color: #6DA3BD;
      background: #f0f8ff;
    }
    
    .location-image-upload.has-image {
      border-style: solid;
      padding: 0;
      background: none;
    }
    
    .location-upload-text {
      color: #666;
      font-size: 14px;
      margin-top: 8px;
    }
    
    .location-upload-icon {
      font-size: 32px;
      color: #ccc;
      margin-bottom: 8px;
    }
    
    .location-modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #f0f0f0;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      background: #fafafa;
      flex-shrink: 0;
      position: sticky;
      bottom: 0;
      z-index: 1;
    }
    
    .location-btn-cancel {
      background: #f5f5f5;
      color: #666;
      border: 1px solid #ddd;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .location-btn-cancel:hover {
      background: #e0e0e0;
      border-color: #ccc;
    }
    
    .location-btn-send {
      background: #6DA3BD;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .location-btn-send:hover {
      background: #5a8ba0;
    }
    
    .location-btn-send:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    /* 位置弹窗滚动条样式 */
    .location-modal-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .location-modal-content::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .location-modal-content::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
      transition: background 0.2s;
    }
    
    .location-modal-content::-webkit-scrollbar-thumb:hover {
      background: #a1a1a1;
    }
    
    /* Firefox滚动条样式 */
    .location-modal-content {
      scrollbar-width: thin;
      scrollbar-color: #c1c1c1 #f1f1f1;
    }

    /* 转账弹窗样式 */
    .transfer-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .transfer-modal.show {
      display: flex;
    }
    
    .transfer-modal-content {
      background: #fff;
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      max-height: 90vh;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    
    .transfer-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid #f0f0f0;
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: white;
      flex-shrink: 0;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    
    .transfer-modal-title {
      font-size: 18px;
      font-weight: 600;
    }
    
    .transfer-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: white;
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    }
    
    .transfer-modal-close:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .transfer-modal-body {
      padding: 20px;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    .transfer-form-group {
      margin-bottom: 20px;
    }
    
    .transfer-form-label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      color: #333;
      margin-bottom: 8px;
    }
    
    .transfer-form-input {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      outline: none;
      transition: border-color 0.2s;
    }
    
    .transfer-form-input:focus {
      border-color: #ff6b35;
      box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.2);
    }
    
    .transfer-amount-input {
      font-size: 24px;
      font-weight: 600;
      text-align: center;
      color: #ff6b35;
    }
    
    .transfer-amount-input::placeholder {
      color: #ccc;
    }
    
    .transfer-form-textarea {
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }
    
    .transfer-preview {
      border: 1px solid #f0f0f0;
      border-radius: 12px;
      overflow: hidden;
      margin: 0 auto 20px auto;
      background: #fff;
      box-sizing: border-box;
      width: 100%;
    }
    
    .transfer-preview-container {
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: white;
      padding: 20px;
      text-align: center;
      box-sizing: border-box;
      width: 100%;
    }
    
    .transfer-preview-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .transfer-preview-amount {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 8px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
      word-break: break-all;
    }
    
    .transfer-preview-note {
      font-size: 14px;
      opacity: 0.9;
      line-height: 1.3;
      word-wrap: break-word;
    }
    
    .transfer-modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #f0f0f0;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      background: #fafafa;
      flex-shrink: 0;
      position: sticky;
      bottom: 0;
      z-index: 1;
    }
    
    .transfer-btn-cancel {
      background: #f5f5f5;
      color: #666;
      border: 1px solid #ddd;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .transfer-btn-cancel:hover {
      background: #e0e0e0;
      border-color: #ccc;
    }
    
    .transfer-btn-send {
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
    }
    
    .transfer-btn-send:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
    }
    
    .transfer-btn-send:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* 转账弹窗滚动条样式 */
    .transfer-modal-body::-webkit-scrollbar {
      width: 6px;
    }
    
    .transfer-modal-body::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .transfer-modal-body::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
      transition: background 0.2s;
    }
    
    .transfer-modal-body::-webkit-scrollbar-thumb:hover {
      background: #a1a1a1;
    }
    
    /* Firefox滚动条样式 */
    .transfer-modal-body {
      scrollbar-width: thin;
      scrollbar-color: #c1c1c1 #f1f1f1;
    }

    /* 确保转账预览在有滚动条时保持正确对齐 */
    .transfer-modal-body {
      box-sizing: border-box;
    }

    /* 滚动条背景透明化 */
    .transfer-modal-body::-webkit-scrollbar-track {
      background: transparent;
    }

    /* 转账预览图片对齐修复 */
    .transfer-preview-container * {
      box-sizing: border-box;
    }

    /* 转账预览完美居中 */
    .transfer-preview {
      display: block;
      margin-left: auto;
      margin-right: auto;
      position: relative;
      left: 0;
      right: 0;
    }

    /* 确保转账预览容器完全居中 */
    .transfer-modal-body .transfer-preview {
      margin-left: 0;
      margin-right: 0;
      width: 100%;
      max-width: 100%;
    }

    /* 视频通话按钮样式 */
    .video-call-btn {
      background: #28a745;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .video-call-btn:hover {
      background: #218838;
      transform: scale(1.05);
    }

    .video-call-btn:active {
      transform: scale(0.95);
    }

    /* 视频通话申请弹窗样式 */
    .video-call-request-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }

    .video-call-request-modal.show {
      display: flex;
    }

    .video-call-request-content {
      background: #fff;
      border-radius: 20px;
      padding: 40px 30px;
      text-align: center;
      max-width: 300px;
      width: 90%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      animation: slideInUp 0.3s ease;
    }

    .video-call-request-avatar {
      margin-bottom: 20px;
    }

    .video-call-request-avatar img {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #28a745;
    }

    .video-call-request-name {
      font-size: 20px;
      font-weight: bold;
      color: #333;
      margin-bottom: 8px;
    }

    .video-call-request-text {
      font-size: 16px;
      color: #666;
      margin-bottom: 30px;
    }

    .video-call-request-actions {
      display: flex;
      gap: 20px;
      justify-content: center;
    }

    .video-call-decline-btn {
      background: #dc3545;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .video-call-decline-btn:hover {
      background: #c82333;
      transform: scale(1.05);
    }

    .video-call-accept-btn {
      background: #28a745;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .video-call-accept-btn:hover {
      background: #218838;
      transform: scale(1.05);
    }

    .video-call-decline-btn::before {
      content: '✕';
    }

    .video-call-accept-btn::before {
      content: '✓';
    }

    /* 拍一拍提醒弹窗样式 */
    .pat-reminder-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2500;
      backdrop-filter: blur(2px);
    }

    .pat-reminder-modal.show {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    .pat-reminder-content {
      background: #fff;
      border-radius: 16px;
      padding: 24px;
      text-align: center;
      max-width: 280px;
      width: 80%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      animation: slideInScale 0.4s ease;
      position: relative;
    }

    .pat-reminder-avatar {
      margin-bottom: 16px;
      position: relative;
    }

    .pat-reminder-avatar img {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #6DA3BD;
      animation: patBounce 0.6s ease-in-out;
    }

    .pat-reminder-text {
      font-size: 16px;
      color: #333;
      margin-bottom: 20px;
      line-height: 1.4;
    }

    .pat-reminder-close {
      background: #6DA3BD;
      color: #fff;
      border: none;
      border-radius: 20px;
      padding: 8px 20px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .pat-reminder-close:hover {
      background: #5a8ca0;
      transform: translateY(-1px);
    }

    /* 拍一拍动画效果 */
    @keyframes patBounce {
      0% { transform: scale(1); }
      20% { transform: scale(1.1) rotate(-5deg); }
      40% { transform: scale(0.95) rotate(3deg); }
      60% { transform: scale(1.05) rotate(-2deg); }
      80% { transform: scale(0.98) rotate(1deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    @keyframes slideInScale {
      0% { 
        transform: scale(0.8) translateY(20px); 
        opacity: 0; 
      }
      100% { 
        transform: scale(1) translateY(0); 
        opacity: 1; 
      }
    }

    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    /* 移动端适配 */
    @media (max-width: 768px) {
      .pat-reminder-content {
        max-width: 260px;
        width: 85%;
        padding: 20px;
      }
      
      .pat-reminder-avatar img {
        width: 70px;
        height: 70px;
      }
      
      .pat-reminder-text {
        font-size: 15px;
      }
    }

    /* 拍一拍消息样式 */
    .pat-message {
      text-align: center;
      margin: 8px 0;
      padding: 0;
    }

    .pat-message-content {
      display: inline-block;
      background: rgba(0, 0, 0, 0.05);
      color: #999;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 12px;
      max-width: 80%;
      word-wrap: break-word;
      animation: patMessageFadeIn 0.3s ease;
    }

    .pat-message-content.shake {
      animation: patShake 0.6s ease-in-out;
    }

    /* 拍一拍消息动画 */
    @keyframes patMessageFadeIn {
      0% { 
        opacity: 0; 
        transform: scale(0.8) translateY(10px); 
      }
      100% { 
        opacity: 1; 
        transform: scale(1) translateY(0); 
      }
    }

    @keyframes patShake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
      20%, 40%, 60%, 80% { transform: translateX(2px); }
    }

    /* 头像被拍动画 */
    @keyframes patBounce {
      0% { transform: scale(1); }
      20% { transform: scale(1.1) rotate(-5deg); }
      40% { transform: scale(1.05) rotate(3deg); }
      60% { transform: scale(1.08) rotate(-2deg); }
      80% { transform: scale(1.02) rotate(1deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    /* 视频通话界面样式 */
    .video-call-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: none;
      z-index: 3000;
    }

    .video-call-modal.show {
      display: block;
    }

    .video-call-content {
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .video-call-screen {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .video-call-main-video {
      width: 100%;
      height: 100%;
      position: relative;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .video-call-main-video img,
    .video-call-main-video video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .video-call-user-info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      z-index: 10;
    }

    .video-call-user-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 4px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .video-call-duration {
      font-size: 14px;
      opacity: 0.8;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .video-call-user-video {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 120px;
      height: 160px;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #fff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 10;
    }

    .video-call-user-video img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .video-call-messages {
      position: absolute;
      bottom: 170px;
      left: 20px;
      right: 20px;
      max-height: 250px;
      overflow-y: auto;
      z-index: 10;
      padding-bottom: 15px;
    }

    /* 自定义滚动条样式 */
    .video-call-messages::-webkit-scrollbar {
      width: 4px;
    }

    .video-call-messages::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
    }

    .video-call-messages::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.3);
      border-radius: 2px;
    }

    .video-call-messages::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.5);
    }

    .video-call-message {
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 12px 16px;
      border-radius: 20px;
      margin-bottom: 10px;
      max-width: 80%;
      word-wrap: break-word;
      backdrop-filter: blur(15px);
      animation: fadeInUp 0.3s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
    }

    .video-call-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      backdrop-filter: blur(10px);
      z-index: 10;
    }

    .video-call-input-row {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      align-items: center;
    }

    .video-call-input {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: 25px;
      background: rgba(255,255,255,0.9);
      font-size: 16px;
      outline: none;
    }

    .video-call-input::placeholder {
      color: #999;
    }

    .video-call-send-btn {
      background: #007AFF;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .video-call-send-btn:hover {
      background: #0056CC;
      transform: scale(1.05);
    }

    .video-call-action-row {
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    .video-call-mute-btn,
    .video-call-camera-btn {
      background: rgba(255,255,255,0.2);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 56px;
      height: 56px;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
    }

    .video-call-mute-btn:hover,
    .video-call-camera-btn:hover {
      background: rgba(255,255,255,0.3);
      transform: scale(1.05);
    }

    .video-call-hangup-btn {
      background: #dc3545;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 64px;
      height: 64px;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      transform: rotate(135deg);
    }

    .video-call-hangup-btn:hover {
      background: #c82333;
      transform: scale(1.05) rotate(135deg);
    }

    /* 移动端适配 */
    @media (max-width: 768px) {
      .video-call-user-video {
        width: 100px;
        height: 130px;
        top: 15px;
        right: 15px;
      }

      .video-call-user-info {
        top: 15px;
        left: 15px;
      }

      .video-call-user-name {
        font-size: 16px;
      }

      .video-call-duration {
        font-size: 12px;
      }

      .video-call-messages {
        bottom: 140px;
        left: 15px;
        right: 15px;
        max-height: 180px;
        padding-bottom: 15px;
      }

      .video-call-controls {
        padding: 15px;
      }

      .video-call-input-row {
        margin-bottom: 12px;
      }

      .video-call-input {
        padding: 10px 14px;
        font-size: 14px;
      }

      .video-call-send-btn {
        width: 44px;
        height: 44px;
        font-size: 14px;
      }

      .video-call-mute-btn,
      .video-call-camera-btn {
        width: 48px;
        height: 48px;
        font-size: 18px;
      }

      .video-call-hangup-btn {
        width: 56px;
        height: 56px;
        font-size: 20px;
      }

      .video-call-action-row {
        gap: 15px;
      }
    }

    /* 动画效果 */
    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- 聊天列表界面 -->
    <div class="chat-list-view active" id="chatListView">
      <div class="chat-list-header">
        <span>聊天</span>
        <div class="header-buttons">
          <button class="header-btn" id="momentsBtn" title="朋友圈">📸</button>
          <button class="header-btn" id="settingsBtn" title="API设置">⚙</button>
          <button class="header-btn" id="emojiBtn" title="表情包设置">😊</button>
          <button class="header-btn" id="aiSettingsBtn" title="AI回复设置">🤖</button>
          <button class="header-btn" id="newGroupChatBtn" title="新建群聊">👥</button>
          <button class="header-btn" id="newChatBtn" title="新建聊天">+</button>
        </div>
      </div>
      
      <!-- API设置面板 -->
    <div class="settings-panel" id="settingsPanel">
      <!-- API配置管理 -->
      <div class="setting-group">
        <label class="setting-label">已保存的API配置:</label>
        <select class="setting-select" id="savedApiSelect">
          <option value="">选择已保存的API配置...</option>
        </select>
        <div class="setting-buttons" style="margin-top: 8px;">
          <button class="setting-btn test-btn" id="loadApiBtn">加载配置</button>
          <button class="setting-btn test-btn" id="deleteApiBtn" style="background: #e74c3c;">删除配置</button>
          <button class="setting-btn test-btn" id="newApiConfigBtn" style="background: #27ae60;">新建配置</button>
        </div>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">配置名称:</label>
        <input type="text" class="setting-input" id="apiConfigNameInput" placeholder="为此API配置起个名字，如：DeepSeek主要" />
      </div>
      
      <div class="setting-group">
        <label class="setting-label">API地址:</label>
        <input type="text" class="setting-input" id="apiUrlInput" placeholder="请输入API基础地址" />
        <div class="model-info" style="margin-top: 8px; font-size: 12px; color: #666;">
          <div><strong>支持的API格式：</strong></div>
          <div>• <strong>DeepSeek:</strong> https://api.deepseek.com</div>
          <div>• <strong>OpenAI:</strong> https://api.openai.com/v1</div>
          <div>• <strong>硅基流动:</strong> https://api.siliconflow.cn/v1</div>
          <div style="margin-top: 5px; color: #e74c3c;"><strong>注意：</strong>Google API密钥格式为 AIza... 开头</div>
          <div style="margin-top: 5px; color: #f39c12;"><strong>第三方API：</strong>如遇连接问题，请使用"🔍 调试模型"按钮</div>
          <div style="margin-top: 5px; color: #8e44ad;">如果连接失败，请使用"💬 直接测试聊天"按钮</div>
          <div style="margin-top: 10px;">
            <button class="setting-btn test-btn" id="siliconflowApiHelperBtn" style="background: #2ecc71; color: white;">
              🚀 硅基流动 API 连接助手
            </button>
          </div>
        </div>
      </div>
      <div class="setting-group">
        <label class="setting-label">API秘钥:</label>
        <input type="password" class="setting-input" id="apiKeyInput" placeholder="请输入API秘钥" />
      </div>
      
      <!-- 识图API配置 -->
      <div class="setting-group">
        <h3 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">🖼️ 识图API配置 (可选)</h3>
        <p style="font-size: 12px; color: #666; margin: 0 0 10px 0;">配置识图API后，AI可以识别用户发送的图片内容</p>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">识图API地址:</label>
        <input type="text" class="setting-input" id="visionApiUrlInput" placeholder="请输入识图API地址（可选）" />
        <div class="model-info" style="margin-top: 5px; font-size: 12px; color: #666;">
          <div><strong>支持的识图API：</strong></div>
          <div>• <strong>OpenAI:</strong> https://api.openai.com/v1</div>
          <div>• <strong>硅基流动:</strong> https://api.siliconflow.cn/v1</div>
          <div>• <strong>其他兼容OpenAI格式的API</strong></div>
        </div>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">识图API密钥:</label>
        <input type="password" class="setting-input" id="visionApiKeyInput" placeholder="请输入识图API密钥（可选）" />
      </div>
      
      <div class="setting-group">
        <label class="setting-label">识图模型:</label>
        <select class="setting-select" id="visionModelSelect">
          <option value="">请先测试识图连接以获取可用模型</option>
        </select>
        <div class="model-info" id="visionModelInfo">选择一个支持视觉识别的AI模型</div>
      </div>
      
      <div class="setting-buttons" style="margin-top: 10px;">
        <button class="setting-btn test-btn" id="testVisionBtn" style="background: #9b59b6;">测试识图连接</button>
        <button class="setting-btn refresh-models-btn" id="refreshVisionModelsBtn" style="background: #9b59b6;">刷新识图模型</button>
        <button class="setting-btn test-btn" id="debugVisionModelsBtn" style="background: #e67e22;">🔍 调试识图模型</button>
      </div>
      
      <div class="setting-group">
        <label class="setting-label">AI模型:</label>
        <select class="setting-select" id="modelSelect">
          <option value="">请先测试连接以获取可用模型</option>
        </select>
        <div class="model-info" id="modelInfo">选择一个AI模型进行对话</div>
      </div>
      <div id="testResult"></div>
      <div class="setting-buttons">
        <button class="setting-btn test-btn" id="testBtn">测试连接</button>
        <button class="setting-btn refresh-models-btn" id="refreshModelsBtn">刷新模型</button>
        <button class="setting-btn test-btn" id="debugModelsBtn" style="background: #e67e22;">🔍 调试模型</button>
        <button class="setting-btn test-btn" id="directChatTestBtn" style="background: #27ae60;">💬 直接测试聊天</button>
      </div>
      <div class="setting-buttons" style="margin-top: 10px;">
        <button class="setting-btn save-btn" id="saveAsNewBtn">💾 保存为新配置</button>
        <button class="setting-btn save-btn" id="updateCurrentBtn" style="background: #f39c12;">📝 更新当前配置</button>
        <button class="setting-btn cancel-btn" id="cancelBtn">取消</button>
      </div>
    </div>
      
      <!-- 表情包设置面板 -->
      <div class="settings-panel" id="emojiPanel">
        <div class="setting-group">
          <label class="setting-label">AI表情包设置</label>
          <p style="font-size: 12px; color: #666; margin: 5px 0;">AI每次回复后都会发送表情包，会根据用户和AI的情绪选择对应的表情包</p>
        </div>
        
        <div class="emotion-tabs">
          <button class="emotion-tab active" data-emotion="happy">😊 开心</button>
          <button class="emotion-tab" data-emotion="sad">😢 伤心</button>
          <button class="emotion-tab" data-emotion="angry">😠 生气</button>
          <button class="emotion-tab" data-emotion="confused">😕 疑惑</button>
          <button class="emotion-tab" data-emotion="love">😍 喜欢</button>
        </div>
        
        <div class="emoji-gallery" id="emojiGallery">
          <!-- 表情包会动态加载到这里 -->
        </div>
        
        <div class="setting-group">
          <label class="setting-label">添加表情包:</label>
          <input type="url" class="setting-input" id="newEmojiInput" placeholder="请输入表情包图片链接" />
          <div class="setting-buttons" style="margin-top: 10px;">
            <button class="setting-btn save-btn" id="addEmojiBtn">添加链接</button>
            <button class="setting-btn test-btn upload-btn" id="uploadEmojiBtn">📁 上传文件</button>
          </div>
          <div class="upload-area" id="emojiDropArea">
            <div>📤 拖拽图片文件到这里上传</div>
            <div class="drag-hint">或点击上方"上传文件"按钮选择图片</div>
            <div class="file-info">支持 JPG、PNG、GIF、WebP 格式，最大 10MB</div>
          </div>
          <input type="file" id="emojiFileInput" accept="image/*" style="display: none;" />
        </div>
        
        <div class="setting-buttons">
          <button class="setting-btn cancel-btn" id="closeEmojiBtn">关闭</button>
        </div>
      </div>
      
      <!-- AI回复设置面板 -->
      <div class="ai-settings-panel" id="aiSettingsPanel">
        <div class="setting-group">
          <label class="setting-label">🤖 AI回复设置</label>
          <p style="font-size: 12px; color: #666; margin: 5px 0;">控制AI可以看到的上下文长度，避免记忆混乱</p>
        </div>
        
        <div class="setting-group context-setting">
          <label class="setting-label">上下文轮数:</label>
          <input type="number" class="setting-input context-input" id="contextLengthInput" 
                 value="10" min="1" max="50" placeholder="10" />
          <span style="font-size: 12px; color: #666; margin-left: 10px;">AI可以看到最近N个对话轮数</span>
        </div>
        
        <div class="setting-group context-setting">
          <label class="setting-label">响应间隔 (秒):</label>
          <input type="number" class="setting-input context-input" id="responseDelayInput" 
                 value="0" min="0" max="60" placeholder="0" />
          <span style="font-size: 12px; color: #666; margin-left: 10px;">0表示立即回复，>0表示延迟回复</span>
        </div>
        
        <div class="setting-group">
          <label class="setting-label">设置说明:</label>
          <div style="font-size: 12px; color: #666; line-height: 1.5; padding: 10px; background: #f9f9f9; border-radius: 6px;">
            <div>• <strong>上下文轮数:</strong> 控制AI能看到的历史对话数量</div>
            <div>• <strong>数值越大:</strong> AI记忆更完整，但可能混乱</div>
            <div>• <strong>数值越小:</strong> AI记忆更清晰，但可能断层</div>
            <div>• <strong>推荐值:</strong> 单聊 10-20，群聊 5-15</div>
            <div>• <strong>响应间隔:</strong> 设置AI延迟回复时间，可收集多条消息</div>
            <div>• <strong>间隔用途:</strong> 0秒立即回复，3-10秒适合连续对话</div>
            <div>• <strong>重置聊天:</strong> 清空聊天后AI将完全忘记之前的对话</div>
          </div>
        </div>
        
        <div class="setting-group">
          <label class="setting-label">预设提示词:</label>
          <textarea class="setting-textarea" id="aiPromptInput" 
                    placeholder="在这里输入预设提示词，AI将根据这些提示词来规范回复内容...&#10;&#10;例如：&#10;- 请用简洁明了的语言回复&#10;- 保持友善和耐心的语气&#10;- 如果不确定答案，请诚实说明&#10;- 回复时请考虑上下文情况" 
                    maxlength="2000"></textarea>
          <div style="font-size: 12px; color: #666; margin-top: 5px;">
            <span>💡 提示词将作为系统指令发送给AI，帮助规范AI的回复风格和内容</span>
            <span style="float: right;" id="promptCharCount">0/2000</span>
          </div>
        </div>
        
        <div class="setting-group">
          <label class="setting-label">预设模板:</label>
          <div class="setting-buttons">
            <button class="setting-btn test-btn" onclick="setPromptTemplate('professional')">专业助手</button>
            <button class="setting-btn test-btn" onclick="setPromptTemplate('friendly')">友善聊天</button>
            <button class="setting-btn test-btn" onclick="setPromptTemplate('creative')">创意写作</button>
          </div>
          <div class="setting-buttons" style="margin-top: 8px;">
            <button class="setting-btn test-btn" onclick="setPromptTemplate('teacher')">教学指导</button>
            <button class="setting-btn test-btn" onclick="setPromptTemplate('clear')">清空提示词</button>
          </div>
        </div>

        <div class="setting-group">
          <label class="setting-label">快速设置:</label>
          <div class="setting-buttons">
            <button class="setting-btn test-btn" onclick="setAIConfig(5, 0)">简短记忆+即时回复</button>
            <button class="setting-btn test-btn" onclick="setAIConfig(10, 3)">标准记忆+3秒延迟</button>
            <button class="setting-btn test-btn" onclick="setAIConfig(20, 0)">长期记忆+即时回复</button>
          </div>
          <div class="setting-buttons" style="margin-top: 8px;">
            <button class="setting-btn test-btn" onclick="setAIConfig(15, 5)">对话模式(5秒延迟)</button>
            <button class="setting-btn test-btn" onclick="setAIConfig(10, 10)">深度思考(10秒延迟)</button>
          </div>
        </div>
        
        <div class="setting-buttons">
          <button class="setting-btn save-btn" id="saveAISettingsBtn">保存设置</button>
          <button class="setting-btn cancel-btn" id="closeAISettingsBtn">关闭</button>
        </div>
      </div>
      
      <div class="chat-list-body" id="chatListBody">
        <div class="empty-chat-list" id="emptyChatList">
          <div class="icon">💬</div>
          <div class="text">还没有聊天记录</div>
          <button class="new-chat-btn" onclick="createNewChat()">开始新聊天</button>
          <button class="new-chat-btn" onclick="createNewGroupChat()" style="margin-top: 10px; background: #9b59b6;">创建群聊</button>
        </div>
      </div>
    </div>

    <!-- 朋友圈界面 -->
    <div class="moments-view" id="momentsView">
      <div class="moments-header">
        <div class="moments-header-content">
          <button class="moments-back-btn" id="momentsBackBtn">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="m15 18-6-6 6-6"/>
            </svg>
          </button>
          <button class="moments-back-btn" id="momentsSettingsBtn" style="position: absolute; top: 16px; right: 16px;" title="朋友圈设置">
            ⚙️
          </button>
          <div class="moments-user-info">
            <div class="moments-user-name" id="momentsUserName">我的朋友圈</div>
            <img class="moments-user-avatar" id="momentsUserAvatar" src="https://i.postimg.cc/9fv1G8vS/default-user.png" alt="用户头像">
          </div>
        </div>
      </div>
      
      <div class="moments-content">
        <div class="moments-publish-area" id="momentsPublishArea">
          <img class="publish-avatar" id="publishAvatar" src="https://i.postimg.cc/9fv1G8vS/default-user.png" alt="头像">
          <div class="publish-text" id="publishText">分享新鲜事...</div>
        </div>
        
        <div class="moments-list" id="momentsList">
          <!-- 朋友圈动态列表 -->
        </div>
      </div>
    </div>

    <!-- 发布朋友圈弹窗 -->
    <div class="publish-modal" id="publishModal">
      <div class="publish-modal-content">
        <div class="publish-modal-header">
          <div class="publish-modal-title">发表朋友圈</div>
          <button class="publish-modal-close" id="publishModalClose">×</button>
        </div>
        <div class="publish-modal-body">
          <textarea class="publish-textarea" id="publishTextarea" placeholder="这一刻的想法..."></textarea>
          <div class="publish-images-container" id="publishImagesContainer">
            <div class="publish-image-item" id="addImageBtn">
              <div class="publish-add-image">+</div>
            </div>
          </div>
          <div class="publish-visibility">
            <div class="visibility-label">
              <span>👁️</span>
              <span>谁可以看</span>
            </div>
                    <div class="visibility-options" id="visibilityOptions">
          <!-- 角色选项将动态生成 -->
        </div>
          </div>
        </div>
        <div class="publish-modal-footer">
          <button class="cancel-btn" id="publishCancel">取消</button>
          <button class="cancel-btn" id="testAIReply" style="background: #e67e22;">🤖 测试AI回复</button>
          <button class="publish-btn" id="publishConfirm">发表</button>
        </div>
      </div>
    </div>

    <!-- 图片预览弹窗 -->
    <div class="image-preview-modal" id="imagePreviewModal">
      <button class="image-preview-close" id="imagePreviewClose">×</button>
      <img class="image-preview-content" id="imagePreviewContent">
    </div>

    <!-- 转发选择模态框 -->
    <div class="forward-modal" id="forwardModal">
      <div class="forward-content-wrapper">
        <div class="forward-header-bar">
          <div class="forward-title">选择聊天</div>
          <button class="forward-close" id="forwardClose">×</button>
        </div>
        
        <div class="forward-preview" id="forwardPreview">
          <div class="forward-preview-title">转发内容：</div>
          <div class="forward-preview-content" id="forwardPreviewContent"></div>
        </div>
        
        <div class="forward-search">
          <input type="text" id="forwardSearchInput" placeholder="搜索聊天">
        </div>
        
        <div class="forward-chat-list" id="forwardChatList">
          <!-- 聊天列表将在这里动态生成 -->
        </div>
        
        <div class="forward-actions">
          <button class="forward-btn forward-cancel" id="forwardCancel">取消</button>
          <button class="forward-btn forward-confirm" id="forwardConfirm" disabled>发送</button>
        </div>
      </div>
    </div>

    <!-- 朋友圈设置弹窗 -->
    <div class="publish-modal" id="momentsSettingsModal">
      <div class="publish-modal-content">
        <div class="publish-modal-header">
          <div class="publish-modal-title">朋友圈设置</div>
          <button class="publish-modal-close" id="momentsSettingsClose">×</button>
        </div>
        <div class="publish-modal-body">
          <div class="setting-group">
            <label class="setting-label">朋友圈标题:</label>
            <input type="text" class="setting-input" id="momentsTitle" placeholder="我的朋友圈" maxlength="20">
          </div>
          
          <div class="setting-group">
            <label class="setting-label">封面图片:</label>
            <input type="url" class="setting-input" id="momentsCoverUrl" placeholder="请输入封面图片链接（可选）">
            <div class="setting-buttons" style="margin-top: 10px;">
              <button class="setting-btn test-btn upload-btn" id="uploadMomentsCoverBtn">📷 上传封面</button>
              <button class="setting-btn cancel-btn" id="resetMomentsCoverBtn">重置默认</button>
              <button class="setting-btn save-btn" id="setAsDefaultBtn">⭐ 设为默认</button>
            </div>
            <input type="file" id="momentsCoverFileInput" accept="image/*" style="display: none;">
          </div>
          
          <div class="setting-group">
            <label class="setting-label">封面预览:</label>
            <div id="momentsCoverPreview" style="width: 100%; height: 150px; background-size: cover; background-position: center; border-radius: 8px; border: 1px solid #ddd; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px;">
              当前封面预览
            </div>
          </div>
          
          <div class="setting-group">
            <label class="setting-label">AI角色评论设置:</label>
            <select class="setting-select" id="momentsCommentMode">
              <option value="smart">智能评论（推荐）</option>
              <option value="all">所有可见角色都评论</option>
              <option value="random">随机选择角色评论</option>
              <option value="none">关闭AI评论</option>
            </select>
            <div style="font-size: 12px; color: #666; margin-top: 5px; line-height: 1.4;">
              <div><strong>智能评论：</strong>≤3个角色全部评论，>3个角色智能选择2-4个</div>
              <div><strong>所有评论：</strong>所有可见角色都会评论（可能较多）</div>
              <div><strong>随机评论：</strong>随机选择1-3个角色评论</div>
              <div><strong>关闭评论：</strong>AI角色不会自动评论朋友圈</div>
            </div>
          </div>
        </div>
        <div class="publish-modal-footer">
          <button class="cancel-btn" id="cancelMomentsSettings">取消</button>
          <button class="publish-btn" id="saveMomentsSettings">保存设置</button>
        </div>
      </div>
    </div>

    <!-- 隐藏的文件输入 -->
    <input type="file" id="momentImageInput" accept="image/*" multiple style="display: none;">

    <!-- 聊天界面 -->
    <div class="chat-view" id="chatView">
  <div class="chat-container">
    <div class="chat-header">
          <button class="back-btn" id="backBtn">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="m15 18-6-6 6-6"/>
            </svg>
          </button>
      <span id="chatTitle" class="chat-title">AI微信聊天</span>
      <span class="status-indicator" id="statusIndicator"></span>
      <button class="settings-btn" id="themeBtn" title="主题设置">🎨</button>
      <button class="settings-btn" id="userBtn" title="用户设定">👤</button>
      <button class="settings-btn" id="roleBtn" title="角色设定">🎭</button>
    </div>
    

    
    <div class="settings-panel" id="rolePanel">
          <div class="setting-group">
            <label class="setting-label">聊天类型: <span id="chatTypeDisplay">单聊</span></label>
            <div id="groupChatControls" style="display: none;">
              <div class="setting-group">
                <label class="setting-label">每次最多回复角色数:</label>
                <select class="setting-select" id="maxRolesPerReplySelect">
                  <option value="1">1个角色</option>
                  <option value="2">2个角色</option>
                  <option value="3" selected>3个角色</option>
                  <option value="4">4个角色</option>
                  <option value="5">5个角色</option>
                  <option value="999">所有角色都回复</option>
                </select>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">控制每次用户发言时最多有几个角色回复。选择"所有角色都回复"将忽略角色频率设置。</div>
              </div>
              <button class="setting-btn save-btn" id="addRoleBtn">添加角色</button>
              <div class="setting-label" style="margin-top: 15px;">群聊角色列表:</div>
              <div id="rolesList"></div>
            </div>
          </div>
          
          <div id="singleRoleSettings">
      <div class="setting-group">
        <label class="setting-label">角色预设:</label>
        <select class="setting-select" id="rolePresetSelect">
          <option value="">选择预设角色（可选）</option>
          <option value="louwuche">楼无澈</option>
          <option value="template">模板</option>
        </select>
        <div class="setting-buttons" style="margin-top: 10px;">
          <button class="setting-btn test-btn" id="saveRolePresetBtn">保存为预设</button>
          <button class="setting-btn refresh-models-btn" id="manageRolePresetsBtn">管理预设</button>
        </div>
      </div>
      <div class="setting-group">
        <label class="setting-label">角色姓名:</label>
        <input type="text" class="setting-input" id="roleNameInput" placeholder="请输入角色姓名，如：小助手、老师等" />
      </div>
      <div class="setting-group">
        <label class="setting-label">角色描述:</label>
        <textarea class="setting-input" id="roleDescInput" rows="6" placeholder="请详细描述角色特点、性格、说话风格等，AI将根据此描述来扮演角色..."></textarea>
            </div>
            <div class="setting-group">
              <label class="setting-label">AI头像:</label>
              <input type="url" class="setting-input" id="aiAvatarInput" placeholder="请输入AI头像图片链接（可选，留空使用默认头像）" />
              <div class="setting-buttons" style="margin-top: 10px;">
                <button class="setting-btn test-btn upload-btn" id="uploadAiAvatarBtn">📷 上传AI头像</button>
              </div>
              <input type="file" id="aiAvatarFileInput" accept="image/*" style="display: none;" />
            </div>
            <div class="setting-group">
              <label class="setting-label">视频通话画面:</label>
              <input type="url" class="setting-input" id="aiVideoInput" placeholder="请输入视频通话画面链接（可选）" />
              <div class="setting-buttons" style="margin-top: 10px;">
                <button class="setting-btn test-btn upload-btn" id="uploadAiVideoBtn">📹 上传视频/图片</button>
                <button class="setting-btn test-btn" id="previewAiVideoBtn">👁️ 预览</button>
              </div>
              <input type="file" id="aiVideoFileInput" accept="image/*,image/jpeg,image/png,image/gif,image/webp,video/*,video/mp4,video/webm,video/ogg,video/mov,video/avi" capture="environment" style="display: none;" />
              <div style="font-size: 12px; color: #666; margin-top: 5px;">支持图片和视频文件，留空则使用AI头像</div>
            </div>
      </div>
      


      
      <div class="setting-buttons">
        <button class="setting-btn save-btn" id="saveRoleBtn">保存设定</button>
        <button class="setting-btn cancel-btn" id="cancelRoleBtn">取消</button>
        <button class="setting-btn cancel-btn" id="clearChatBtn">清空聊天</button>
        <button class="setting-btn test-btn" id="exportChatBtn">导出聊天记录</button>
        <button class="setting-btn refresh-models-btn" id="importChatBtn">导入聊天记录</button>
      </div>
      <input type="file" id="importFileInput" accept=".json" style="display: none;" />
    </div>
    
    <!-- 用户设定面板 -->
    <div class="settings-panel" id="userPanel">
      <div class="setting-group">
        <label class="setting-label">用户预设:</label>
        <select class="setting-select" id="userPresetSelect">
          <option value="">选择用户预设（可选）</option>
        </select>
        <div class="setting-buttons" style="margin-top: 10px;">
          <button class="setting-btn test-btn" id="saveUserPresetBtn">保存为预设</button>
          <button class="setting-btn refresh-models-btn" id="manageUserPresetsBtn">管理预设</button>
        </div>
      </div>
      <div class="setting-group">
        <label class="setting-label">用户姓名:</label>
        <input type="text" class="setting-input" id="userNameInput" placeholder="请输入您的姓名或昵称..." />
      </div>
      <div class="setting-group">
        <label class="setting-label">用户描述:</label>
        <textarea class="setting-input" id="userDescInput" rows="4" placeholder="请描述您的性格、喜好、背景等，AI将根据此信息与您互动..."></textarea>
      </div>
      <div class="setting-group">
        <label class="setting-label">用户头像:</label>
        <input type="url" class="setting-input" id="userAvatarInput" placeholder="请输入头像图片链接（可选，留空使用默认头像）" />
        <div class="setting-buttons" style="margin-top: 10px;">
          <button class="setting-btn test-btn upload-btn" id="uploadUserAvatarBtn">📷 上传用户头像</button>
        </div>
        <input type="file" id="userAvatarFileInput" accept="image/*" style="display: none;" />
      </div>
      
      <div class="setting-buttons">
        <button class="setting-btn save-btn" id="saveUserBtn">保存设定</button>
        <button class="setting-btn cancel-btn" id="cancelUserBtn">取消</button>
      </div>
    </div>
        
        <!-- 群聊角色编辑弹窗 -->
        <div class="modal-overlay" id="roleEditModal" style="display: none;">
          <div class="modal-content">
            <div class="modal-header">
              <h3 id="roleEditTitle">添加角色</h3>
              <button class="modal-close" id="closeRoleEditModal">×</button>
            </div>
            <div class="modal-body">
              <div class="setting-group">
                <label class="setting-label">角色预设:</label>
                <select class="setting-select" id="modalRolePresetSelect">
                  <option value="">选择预设角色（可选）</option>
                  <option value="louwuche">楼无澈</option>
                  <option value="template">模板</option>
                </select>
                <div class="setting-buttons" style="margin-top: 10px;">
                  <button class="setting-btn test-btn" id="saveModalRolePresetBtn">保存为预设</button>
                  <button class="setting-btn refresh-models-btn" id="manageModalRolePresetsBtn">管理预设</button>
                </div>
              </div>
              <div class="setting-group">
                <label class="setting-label">角色姓名:</label>
                <input type="text" class="setting-input" id="modalRoleNameInput" placeholder="请输入角色姓名" />
              </div>
              <div class="setting-group">
                <label class="setting-label">角色描述:</label>
                <textarea class="setting-input" id="modalRoleDescInput" rows="6" placeholder="请详细描述角色特点、性格、说话风格等..."></textarea>
              </div>
              <div class="setting-group">
                <label class="setting-label">角色头像:</label>
                <input type="url" class="setting-input" id="modalRoleAvatarInput" placeholder="请输入头像图片链接（可选）" />
                <div class="setting-buttons" style="margin-top: 10px;">
                  <button class="setting-btn test-btn upload-btn" id="uploadModalRoleAvatarBtn">📷 上传角色头像</button>
                </div>
                <input type="file" id="modalRoleAvatarFileInput" accept="image/*" style="display: none;" />
              </div>
              <div class="setting-group">
                <label class="setting-label">视频通话画面:</label>
                <input type="url" class="setting-input" id="modalRoleVideoInput" placeholder="请输入视频通话画面链接（可选）" />
                <div class="setting-buttons" style="margin-top: 10px;">
                  <button class="setting-btn test-btn upload-btn" id="uploadModalRoleVideoBtn">📹 上传视频/图片</button>
                  <button class="setting-btn test-btn" id="previewModalRoleVideoBtn">👁️ 预览</button>
                </div>
                <input type="file" id="modalRoleVideoFileInput" accept="image/*,image/jpeg,image/png,image/gif,image/webp,video/*,video/mp4,video/webm,video/ogg,video/mov,video/avi" capture="environment" style="display: none;" />
                <div style="font-size: 12px; color: #666; margin-top: 5px;">支持图片和视频文件，留空则使用角色头像</div>
              </div>
              <div class="setting-group">
                <label class="setting-label">回复频率:</label>
                <select class="setting-select" id="modalRoleFrequencySelect">
                  <option value="always">每次都回复</option>
                  <option value="often">经常回复</option>
                  <option value="sometimes">偶尔回复</option>
                  <option value="rarely">很少回复</option>
                </select>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">控制该角色在群聊中的活跃度</div>
              </div>
            </div>
            <div class="modal-footer">
              <button class="setting-btn save-btn" id="saveRoleEditBtn">保存角色</button>
              <button class="setting-btn cancel-btn" id="cancelRoleEditBtn">取消</button>
            </div>
          </div>
    </div>
    
    <!-- 预设管理弹窗 -->
    <div class="modal-overlay" id="presetManageModal" style="display: none;">
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="presetManageTitle">管理预设</h3>
          <button class="modal-close" id="closePresetManageModal">×</button>
        </div>
        <div class="modal-body">
      <div class="setting-group">
            <label class="setting-label">现有预设:</label>
            <div id="presetList" style="max-height: 300px; overflow-y: auto;">
              <!-- 预设列表会动态加载到这里 -->
      </div>
      </div>
        </div>
        <div class="modal-footer">
          <button class="setting-btn cancel-btn" id="closePresetManageBtn">关闭</button>
        </div>
      </div>
      </div>
      
    <!-- 保存预设弹窗 -->
    <div class="modal-overlay" id="savePresetModal" style="display: none;">
      <div class="modal-content">
        <div class="modal-header">
          <h3 id="savePresetTitle">保存预设</h3>
          <button class="modal-close" id="closeSavePresetModal">×</button>
        </div>
        <div class="modal-body">
      <div class="setting-group">
            <label class="setting-label">预设名称:</label>
            <input type="text" class="setting-input" id="presetNameInput" placeholder="请输入预设名称" />
      </div>
          <div class="setting-group">
            <label class="setting-label">预设描述:</label>
            <input type="text" class="setting-input" id="presetDescInput" placeholder="请输入预设描述（可选）" />
          </div>
        </div>
        <div class="modal-footer">
          <button class="setting-btn save-btn" id="confirmSavePresetBtn">保存</button>
          <button class="setting-btn cancel-btn" id="cancelSavePresetBtn">取消</button>
        </div>
      </div>
    </div>
    
    <!-- 主题设置弹窗 -->
    <div class="modal-overlay" id="themeSettingsModal" style="display: none;">
      <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
        <div class="modal-header">
          <h3>🎨 主题设置</h3>
          <button class="modal-close" id="closeThemeSettingsModal">×</button>
        </div>
        <div class="modal-body">
          <!-- 预设主题 -->
          <div class="setting-group">
            <label class="setting-label">🌈 预设主题:</label>
            <div class="theme-presets" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 10px;">
                          <button class="theme-preset-btn" data-theme="default">默认主题</button>
            <button class="theme-preset-btn" data-theme="dark">暗黑主题</button>
            <button class="theme-preset-btn" data-theme="blue">蓝色主题</button>
            <button class="theme-preset-btn" data-theme="green">绿色主题</button>
            <button class="theme-preset-btn" data-theme="purple">紫色主题</button>
            <button class="theme-preset-btn" data-theme="pink">粉色主题</button>
            </div>
          </div>
          
          <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">
          
          <!-- 颜色设置 -->
          <div class="setting-group">
            <label class="setting-label">🎨 颜色设置:</label>
            
            <div class="color-setting-item">
              <label class="color-label">导航栏颜色:</label>
              <input type="color" class="color-input" id="headerColorInput" value="#6DA3BD">
              <input type="text" class="color-text" id="headerColorText" value="#6DA3BD">
            </div>
            
            <div class="color-setting-item">
              <label class="color-label">聊天背景:</label>
              <input type="color" class="color-input" id="chatBgColorInput" value="#f5f5f5">
              <input type="text" class="color-text" id="chatBgColorText" value="#f5f5f5">
            </div>
            
            <div class="color-setting-item">
              <label class="color-label">用户消息气泡:</label>
              <input type="color" class="color-input" id="userBubbleColorInput" value="#95EC69">
              <input type="text" class="color-text" id="userBubbleColorText" value="#95EC69">
            </div>
            
            <div class="color-setting-item">
              <label class="color-label">AI消息气泡:</label>
              <input type="color" class="color-input" id="aiBubbleColorInput" value="#FFFFFF">
              <input type="text" class="color-text" id="aiBubbleColorText" value="#FFFFFF">
            </div>
          </div>
          
          <!-- 聊天背景图片 -->
          <div class="setting-group">
            <label class="setting-label">🖼️ 聊天背景图片:</label>
            <input type="url" class="setting-input" id="chatBgImageInput" placeholder="请输入背景图片链接（可选）">
            <div class="setting-buttons" style="margin-top: 10px;">
              <button class="setting-btn test-btn" id="uploadChatBgBtn">📷 上传背景</button>
              <button class="setting-btn cancel-btn" id="removeChatBgBtn">移除背景</button>
            </div>
            <input type="file" id="chatBgFileInput" accept="image/*" style="display: none;">
          </div>
          
          <!-- 字体设置 -->
          <div class="setting-group">
            <label class="setting-label">📝 字体设置:</label>
            
            <div class="font-setting-item">
              <label class="font-label">字体族:</label>
              <select class="setting-select" id="fontFamilySelect">
                <option value="微软雅黑, Arial, sans-serif">微软雅黑</option>
                <option value="&quot;寒蝉团圆体 Round&quot;, 微软雅黑, Arial, sans-serif">寒蝉团圆体</option>
                <option value="&quot;DymonShouXieTi&quot;, 微软雅黑, Arial, sans-serif">呆萌手写体</option>
                <option value="&quot;Fusion Pixel 12px Monospaced zh_hans&quot;, 微软雅黑, Arial, sans-serif">缝合像素字体</option>
                <option value="&quot;ZSFT-dr&quot;, 微软雅黑, Arial, sans-serif">Permanent Marker</option>
                <option value="&quot;平方星辰体&quot;, 微软雅黑, Arial, sans-serif">平方星辰体</option>
                <option value="&quot;huangkaihuaLawyerfont&quot;, 微软雅黑, Arial, sans-serif">黄凯桦律师手写体</option>
                <option value="宋体, serif">宋体</option>
                <option value="黑体, sans-serif">黑体</option>
                <option value="楷体, cursive">楷体</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Times New Roman, serif">Times New Roman</option>
                <option value="Courier New, monospace">Courier New</option>
                <option value="Georgia, serif">Georgia</option>
              </select>
            </div>
            
            <div class="font-setting-item">
              <label class="font-label">导入字体:</label>
              <input type="file" class="setting-input" id="fontFileInput" accept=".ttf,.otf,.woff,.woff2" style="display: none;">
              <button class="setting-btn test-btn" id="importFontBtn">📁 导入字体文件</button>
              <button class="setting-btn cancel-btn" id="clearCustomFontsBtn">清除自定义字体</button>
            </div>
            <div style="font-size: 12px; color: #666; margin-top: 5px; margin-left: 120px;">
              支持格式: .ttf, .otf, .woff, .woff2 | 最大文件大小: 50MB
            </div>
            
            <div class="color-setting-item">
              <label class="color-label">字体颜色:</label>
              <input type="color" class="color-input" id="fontColorInput" value="#333333">
              <input type="text" class="color-text" id="fontColorText" value="#333333">
            </div>
          </div>
          
          <!-- 导航栏样式设置 -->
          <div class="setting-group">
            <label class="setting-label">🧭 导航栏样式:</label>
            
            <div class="style-setting-item">
              <label class="style-label">导航栏圆角:</label>
              <input type="range" class="style-slider" id="headerBorderRadiusSlider" min="0" max="20" value="10">
              <span class="style-value" id="headerBorderRadiusValue">10px</span>
            </div>
            
            <div class="style-setting-item">
              <label class="style-label">导航栏透明度:</label>
              <input type="range" class="style-slider" id="headerOpacitySlider" min="0.5" max="1" step="0.1" value="1">
              <span class="style-value" id="headerOpacityValue">100%</span>
            </div>
            
            <div class="style-setting-item">
              <label class="style-label">导航栏阴影:</label>
              <select class="setting-select" id="headerShadowSelect">
                <option value="none">无阴影</option>
                <option value="light">轻微阴影</option>
                <option value="normal" selected>普通阴影</option>
                <option value="heavy">重阴影</option>
              </select>
            </div>
          </div>
          
          <!-- 气泡样式设置 -->
          <div class="setting-group">
            <label class="setting-label">💬 气泡样式:</label>
            
            <div class="style-setting-item">
              <label class="style-label">气泡圆角:</label>
              <input type="range" class="style-slider" id="bubbleBorderRadiusSlider" min="8" max="25" value="18">
              <span class="style-value" id="bubbleBorderRadiusValue">18px</span>
            </div>
            
            <div class="style-setting-item">
              <label class="style-label">气泡透明度:</label>
              <input type="range" class="style-slider" id="bubbleOpacitySlider" min="0.7" max="1" step="0.1" value="0.95">
              <span class="style-value" id="bubbleOpacityValue">95%</span>
            </div>
            
            <div class="style-setting-item">
              <label class="style-label">气泡阴影:</label>
              <select class="setting-select" id="bubbleShadowSelect">
                <option value="none">无阴影</option>
                <option value="light" selected>轻微阴影</option>
                <option value="normal">普通阴影</option>
                <option value="heavy">重阴影</option>
              </select>
            </div>
            
            <div class="style-setting-item">
              <label class="style-label">气泡边框:</label>
              <select class="setting-select" id="bubbleBorderSelect">
                <option value="none" selected>无边框</option>
                <option value="thin">细边框</option>
                <option value="normal">普通边框</option>
                <option value="thick">粗边框</option>
              </select>
            </div>
          </div>
          
          <!-- 预览区域 -->
          <div class="setting-group">
            <label class="setting-label">👀 效果预览:</label>
            <div class="theme-preview" id="themePreview">
              <div class="preview-header">
                <span>聊天预览</span>
              </div>
              <div class="preview-chat">
                <div class="preview-msg user">
                  <div class="preview-bubble user">这是用户消息预览</div>
                </div>
                <div class="preview-msg ai">
                  <div class="preview-bubble ai">这是AI消息预览</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="setting-btn save-btn" id="applyThemeBtn">应用主题</button>
          <button class="setting-btn test-btn" id="previewThemeBtn">实时预览</button>
          <button class="setting-btn refresh-models-btn" id="resetThemeBtn">重置默认</button>
          <button class="setting-btn cancel-btn" id="cancelThemeBtn">取消</button>
        </div>
      </div>
    </div>
    

    
    <div class="chat-body" id="chatBody"></div>
    <!-- 用户表情包面板 -->
    <div class="user-emoji-panel" id="userEmojiPanel">
      <div class="user-emoji-header">
        <span class="user-emoji-title">选择表情包</span>
        <button class="user-emoji-close" id="userEmojiClose">×</button>
      </div>
      <div class="user-emoji-grid" id="userEmojiGrid">
        <!-- 表情包将在这里动态加载 -->
      </div>
    </div>
    
    <div class="chat-footer">
      <div class="chat-input-row">
        <input type="text" class="chat-input" id="chatInput" placeholder="输入消息..." autocomplete="off" />
        <button class="send-btn" id="sendBtn">发送</button>
      </div>
      <div class="chat-buttons-row">
        <div class="chat-button-item">
          <button class="emoji-btn" id="userEmojiBtn" title="发送表情包">😊</button>
          <span class="chat-button-label">表情</span>
        </div>
        <div class="chat-button-item">
          <button class="image-btn" id="imageBtn" title="发送图片">🖼️</button>
          <span class="chat-button-label">图片</span>
        </div>
        <div class="chat-button-item">
          <button class="location-btn" id="locationBtn" title="发送位置">📍</button>
          <span class="chat-button-label">位置</span>
        </div>
        <div class="chat-button-item">
          <button class="transfer-btn" id="transferBtn" title="转账">💰</button>
          <span class="chat-button-label">转账</span>
        </div>
        <div class="chat-button-item">
          <button class="video-call-btn" id="videoCallBtn" title="视频通话">📹</button>
          <span class="chat-button-label">视频</span>
        </div>
      </div>
      
      <!-- 隐藏的图片上传输入框 -->
      <input type="file" id="imageFileInput" accept="image/*" style="display: none;" />
    </div>
  </div>
    </div>
  </div>

  <!-- 多选工具栏 -->
  <div class="multi-select-toolbar" id="multiSelectToolbar">
    <div class="multi-select-info" id="multiSelectInfo">已选择 0 条消息</div>
    <div class="multi-select-actions">
      <button class="multi-select-btn forward" id="multiForwardBtn">转发</button>
      <button class="multi-select-btn delete" id="multiDeleteBtn">删除</button>
      <button class="multi-select-btn cancel" id="multiCancelBtn">取消</button>
    </div>
  </div>

  <!-- 聊天记录查看模态框 -->
  <div class="chat-record-modal" id="chatRecordModal">
    <div class="chat-record-modal-content">
      <div class="chat-record-modal-header">
        <div class="chat-record-modal-title">聊天记录</div>
        <button class="chat-record-modal-close" id="chatRecordClose">×</button>
      </div>
      <div class="chat-record-modal-body" id="chatRecordModalBody">
        <!-- 聊天记录详情将在这里动态生成 -->
      </div>
    </div>
  </div>

  <!-- 位置选择弹窗 -->
  <div class="location-modal" id="locationModal">
    <div class="location-modal-content">
      <div class="location-modal-header">
        <div class="location-modal-title">发送位置</div>
        <button class="location-modal-close" id="locationModalClose">×</button>
      </div>
      <div class="location-modal-body">
        <!-- 位置预览 -->
        <div class="location-preview">
          <img class="location-preview-image" id="locationPreviewImage" src="https://i.postimg.cc/8ckw0FYH/Camera-1040g0k03186v4spmjk005pmubdtiubpdu8mmhbg.jpg" alt="位置图片">
          <div class="location-preview-info">
            <div class="location-name" id="locationPreviewName">我的位置</div>
            <div class="location-address" id="locationPreviewAddress">请编辑位置信息</div>
          </div>
        </div>
        
        <!-- 位置编辑表单 -->
        <div class="location-form-group">
          <label class="location-form-label">位置名称</label>
          <input type="text" class="location-form-input" id="locationNameInput" placeholder="例如：咖啡厅、公司、家" value="我的位置">
        </div>
        
        <div class="location-form-group">
          <label class="location-form-label">详细地址</label>
          <textarea class="location-form-input location-form-textarea" id="locationAddressInput" placeholder="请输入详细地址信息">请编辑位置信息</textarea>
        </div>
        
        <div class="location-form-group">
          <label class="location-form-label">位置图片</label>
          <div class="location-image-upload" id="locationImageUpload">
            <div class="location-upload-icon">📷</div>
            <div class="location-upload-text">点击更换位置图片</div>
          </div>
          <input type="file" id="locationImageInput" accept="image/*" style="display: none;">
        </div>
      </div>
      <div class="location-modal-footer">
        <button class="location-btn-cancel" id="locationCancelBtn">取消</button>
        <button class="location-btn-send" id="locationSendBtn">发送</button>
      </div>
    </div>
  </div>

  <!-- 转账弹窗 -->
  <div class="transfer-modal" id="transferModal">
    <div class="transfer-modal-content">
      <div class="transfer-modal-header">
        <div class="transfer-modal-title">转账</div>
        <button class="transfer-modal-close" id="transferModalClose">×</button>
      </div>
      <div class="transfer-modal-body">
        <!-- 转账预览 -->
        <div class="transfer-preview">
          <div class="transfer-preview-container">
            <div class="transfer-preview-title">
              <span class="transfer-icon">💰</span>
              <span>转账</span>
            </div>
            <div class="transfer-preview-amount" id="transferPreviewAmount">¥0.00</div>
            <div class="transfer-preview-note" id="transferPreviewNote">请输入转账信息</div>
          </div>
        </div>
        
        <!-- 转账表单 -->
        <div class="transfer-form-group">
          <label class="transfer-form-label">转账金额</label>
          <input type="number" class="transfer-form-input transfer-amount-input" id="transferAmountInput" placeholder="0.00" min="0.01" max="99999" step="0.01">
        </div>
        
        <div class="transfer-form-group">
          <label class="transfer-form-label">转账说明</label>
          <textarea class="transfer-form-input transfer-form-textarea" id="transferNoteInput" placeholder="请输入转账说明（可选）"></textarea>
        </div>
        
        <div class="transfer-form-group">
          <label class="transfer-form-label">收款人</label>
          <input type="text" class="transfer-form-input" id="transferReceiverInput" placeholder="请输入收款人姓名" readonly>
        </div>
      </div>
      <div class="transfer-modal-footer">
        <button class="transfer-btn-cancel" id="transferCancelBtn">取消</button>
        <button class="transfer-btn-send" id="transferSendBtn">确认转账</button>
      </div>
    </div>
  </div>

  <!-- 视频通话申请弹窗 -->
  <div class="video-call-request-modal" id="videoCallRequestModal">
    <div class="video-call-request-content">
      <div class="video-call-request-avatar">
        <img id="videoCallRequestAvatar" src="" alt="头像">
      </div>
      <div class="video-call-request-info">
        <div class="video-call-request-name" id="videoCallRequestName">角色名</div>
        <div class="video-call-request-text">向你发送通话申请</div>
      </div>
      <div class="video-call-request-actions">
        <button class="video-call-decline-btn" id="videoCallDeclineBtn">拒绝</button>
        <button class="video-call-accept-btn" id="videoCallAcceptBtn">接听</button>
      </div>
    </div>
  </div>

  <!-- 拍一拍提醒弹窗 -->
  <div class="pat-reminder-modal" id="patReminderModal">
    <div class="pat-reminder-content">
      <div class="pat-reminder-avatar">
        <img id="patReminderAvatar" src="" alt="角色头像">
      </div>
      <div class="pat-reminder-text" id="patReminderText">
        角色拍了拍你
      </div>
      <button class="pat-reminder-close" id="patReminderClose">知道了</button>
    </div>
  </div>

  <!-- 视频通话界面 -->
  <div class="video-call-modal" id="videoCallModal">
    <div class="video-call-content">
      <!-- 视频画面区域 -->
      <div class="video-call-screen">
        <div class="video-call-main-video">
          <img id="videoCallMainImage" src="" alt="视频画面" style="display: none;">
          <video id="videoCallMainVideo" style="display: none;" autoplay loop muted playsinline webkit-playsinline>
            您的浏览器不支持视频播放
          </video>
          <div class="video-call-user-info">
            <div class="video-call-user-name" id="videoCallUserName">角色名</div>
            <div class="video-call-duration" id="videoCallDuration">00:00</div>
          </div>
        </div>
        
        <!-- 用户小窗口 -->
        <div class="video-call-user-video">
          <img src="" alt="用户头像" id="videoCallUserAvatar">
        </div>
      </div>
      
      <!-- AI消息显示区域 -->
      <div class="video-call-messages" id="videoCallMessages">
        <!-- AI消息会在这里显示 -->
      </div>
      
      <!-- 输入和控制区域 -->
      <div class="video-call-controls">
        <div class="video-call-input-row">
          <input type="text" class="video-call-input" id="videoCallInput" placeholder="输入消息..." autocomplete="off">
          <button class="video-call-send-btn" id="videoCallSendBtn">发送</button>
        </div>
        <div class="video-call-action-row">
          <button class="video-call-mute-btn" id="videoCallMuteBtn" title="静音">🔇</button>
          <button class="video-call-camera-btn" id="videoCallCameraBtn" title="关闭摄像头">📷</button>
          <button class="video-call-hangup-btn" id="videoCallHangupBtn" title="挂断">📞</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 全局变量
    let apiURL = '';
    let apiKey = '';
    let selectedModel = '';
    let availableModels = [];
    
    // API配置存储
    let savedApiConfigs = {}; // 存储多个API配置
    let currentApiConfigId = null; // 当前使用的配置ID
    
    // 识图API配置
    let visionApiURL = '';
    let visionApiKey = '';
    let selectedVisionModel = '';
    let availableVisionModels = [];
    let roleName = '';
    let roleDescription = '';
    let userName = '';
    let userDescription = '';
    let userAvatar = '';
    let aiAvatar = '';
    
    // AI回复设置
    let aiContextLength = 10; // 默认上下文长度为10个气泡
    let aiResponseDelay = 0; // 响应间隔（秒），0表示立即回复
    let aiCustomPrompt = ''; // 预设提示词
    
    // 响应延迟相关变量
    let pendingMessages = []; // 待处理的用户消息
    let responseTimer = null; // 响应定时器
    let isWaitingForResponse = false; // 是否正在等待响应
    
    // 消息操作相关变量
    let currentSelectedMessage = null; // 当前选中的消息
    let replyToMessage = null; // 正在回复的消息
    let selectedForwardChats = []; // 选中的转发目标聊天
    let forwardMessage = null; // 要转发的消息
    let forwardMessages = []; // 要转发的多条消息
    let isMultiSelectMode = false; // 是否处于多选模式
    let selectedMessages = []; // 选中的消息列表
    
    // 初始化聊天记录数据存储
    if (!window.chatRecordsData) {
      window.chatRecordsData = {};
    }
    
    // 聊天列表管理
    let chatList = [];
    let currentChatId = null;
    let currentEditingRoleIndex = -1; // 当前编辑的角色索引
    
    // 默认头像
    const DEFAULT_AI_AVATAR = 'https://i.postimg.cc/YSBx6wnx/IMG-20250617-215551.jpg';
    const DEFAULT_USER_AVATAR = 'https://i.postimg.cc/xTqgY5NL/IMG-20250617-215606.jpg';
    
    // 默认表情包数据
    const DEFAULT_EMOJIS = {
      happy: [
        'https://i.postimg.cc/8ckw0FYH/Camera-1040g0k03186v4spmjk005pmubdtiubpdu8mmhbg.jpg',
        'https://i.postimg.cc/YqzMFTNB/Camera-1040g0k03186v4tat0q005pmubdtiubpdgjjc208.jpg',
        'https://i.postimg.cc/Vv4Zf9tp/Camera-1040g34o3186v4bahgo0g5pmubdtiubpdm2m3520.jpg'
      ],
      sad: [
        'https://i.postimg.cc/PfbBVYCm/Camera-1040g34o3186v4sr1jk0g5pmubdtiubpdn64nug0.jpg',
        'https://i.postimg.cc/MpswPRrs/Camera-1040g34o3186v4t0lgq0g5pmubdtiubpdqcoib90.jpg',
        'https://i.postimg.cc/mgnq1SnG/Camera-1040g34o3186v4so6go0g5pmubdtiubpdolbqdmo.jpg'
      ],
      angry: [
        'https://i.postimg.cc/43mgrdDX/Camera-1040g0k03186v505k0q005pmubdtiubpd0ll7q90.jpg',
        'https://i.postimg.cc/FsWCwZNJ/Camera-1040g0k03186v4bdegs005pmubdtiubpdfipdsng.jpg'
      ],
      confused: [
        'https://i.postimg.cc/Dy630LF2/Camera-1040g0k03186v4t4c0q005pmubdtiubpd4gdlof0.jpg',
        'https://i.postimg.cc/2jxK7YtG/Camera-1040g34o3186v4b8s0q0g5pmubdtiubpdk9on5ag.jpg',
        'https://i.postimg.cc/3JJbL65T/Camera-1040g34o3186v4bfhjk0g5pmubdtiubpds0k9plg.jpg'
      ],
      love: [
        'https://i.postimg.cc/BZDqSjX6/Camera-XHS-17473999641601040g008310c813u16m6g5pajh6v20dkvfs3f5pg.jpg',
        'https://i.postimg.cc/mrMdzWMQ/Camera-1040g0k03186v4bbs0o705pmubdtiubpdhd5614g.jpg'
      ]
    };
    
    // 表情包数据
    let emojiData = {};
    
    // 位置数据
    let currentLocationData = {
      name: '我的位置',
      address: '请编辑位置信息',
      image: 'https://i.postimg.cc/8ckw0FYH/Camera-1040g0k03186v4spmjk005pmubdtiubpdu8mmhbg.jpg'
    };
    
    // 转账数据
    let currentTransferData = {
      amount: 0,
      note: '',
      receiver: ''
    };

    // 视频通话相关变量
    let isVideoCallActive = false;
    let videoCallTimer = null;
    let videoCallStartTime = null;
    let currentVideoCallRole = null;
    
    // 拍一拍提醒相关变量
    let inactivityTimer = null;
    let lastActivityTime = Date.now();
    let patReminderShown = false;
    const INACTIVITY_TIMEOUT = 60000; // 1分钟 = 60000毫秒
    
    // 预设数据
    let customRolePresets = {};
    let customUserPresets = {};
    let currentPresetType = 'role'; // 'role' 或 'user'
    let currentPresetContext = 'main'; // 'main' 或 'modal'
    
    // 朋友圈数据
    let moments = [];
    let currentVisibleRoles = []; // 当前发布时选择的可见角色
    let selectedImages = []; // 当前选择的图片
    let currentReplyTo = null; // 当前回复的评论
    let mentionSuggestions = []; // @提及建议列表
    let selectedMentionIndex = -1; // 当前选中的@建议索引
    
    // 朋友圈设置数据
    let momentsSettings = {
      title: '我的朋友圈',
      coverImage: '', // 空字符串表示使用默认背景
      commentMode: 'smart' // AI角色评论模式：smart/all/random/none
    };

    // DOM元素
    const chatListView = document.getElementById('chatListView');
    const chatView = document.getElementById('chatView');
    const chatListBody = document.getElementById('chatListBody');
    const emptyChatList = document.getElementById('emptyChatList');
    const newChatBtn = document.getElementById('newChatBtn');
    const newGroupChatBtn = document.getElementById('newGroupChatBtn');
    const backBtn = document.getElementById('backBtn');
    
    // 朋友圈DOM元素
    const momentsBtn = document.getElementById('momentsBtn');
    const momentsView = document.getElementById('momentsView');
    const momentsBackBtn = document.getElementById('momentsBackBtn');
    const momentsSettingsBtn = document.getElementById('momentsSettingsBtn');
    const momentsUserName = document.getElementById('momentsUserName');
    const momentsUserAvatar = document.getElementById('momentsUserAvatar');
    const momentsPublishArea = document.getElementById('momentsPublishArea');
    const publishAvatar = document.getElementById('publishAvatar');
    const publishText = document.getElementById('publishText');
    const momentsList = document.getElementById('momentsList');
    const publishModal = document.getElementById('publishModal');
    const publishModalClose = document.getElementById('publishModalClose');
    const publishTextarea = document.getElementById('publishTextarea');
    const publishImagesContainer = document.getElementById('publishImagesContainer');
    const addImageBtn = document.getElementById('addImageBtn');
    const visibilityOptions = document.getElementById('visibilityOptions');
    const publishCancel = document.getElementById('publishCancel');
    const publishConfirm = document.getElementById('publishConfirm');
    const imagePreviewModal = document.getElementById('imagePreviewModal');
    const imagePreviewClose = document.getElementById('imagePreviewClose');
    const imagePreviewContent = document.getElementById('imagePreviewContent');
    const momentImageInput = document.getElementById('momentImageInput');
    
    // 朋友圈设置DOM元素
    const momentsSettingsModal = document.getElementById('momentsSettingsModal');
    const momentsSettingsClose = document.getElementById('momentsSettingsClose');
    const momentsTitle = document.getElementById('momentsTitle');
    const momentsCoverUrl = document.getElementById('momentsCoverUrl');
    const uploadMomentsCoverBtn = document.getElementById('uploadMomentsCoverBtn');
    const resetMomentsCoverBtn = document.getElementById('resetMomentsCoverBtn');
    const momentsCoverFileInput = document.getElementById('momentsCoverFileInput');
    const momentsCoverPreview = document.getElementById('momentsCoverPreview');
    const momentsCommentMode = document.getElementById('momentsCommentMode');
    const cancelMomentsSettings = document.getElementById('cancelMomentsSettings');
    const saveMomentsSettings = document.getElementById('saveMomentsSettings');
    
    const chatBody = document.getElementById('chatBody');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');
    const roleBtn = document.getElementById('roleBtn');
    const userBtn = document.getElementById('userBtn');
    const userPanel = document.getElementById('userPanel');
    const rolePanel = document.getElementById('rolePanel');
    const chatTitle = document.getElementById('chatTitle');
    const chatTypeDisplay = document.getElementById('chatTypeDisplay');
    
    // 用户表情包相关DOM元素
    const userEmojiBtn = document.getElementById('userEmojiBtn');
    const userEmojiPanel = document.getElementById('userEmojiPanel');
    const userEmojiClose = document.getElementById('userEmojiClose');
    const userEmojiGrid = document.getElementById('userEmojiGrid');
    
    // 位置相关DOM元素
    const locationBtn = document.getElementById('locationBtn');
    const locationModal = document.getElementById('locationModal');
    const locationModalClose = document.getElementById('locationModalClose');
    const locationPreviewImage = document.getElementById('locationPreviewImage');
    const locationPreviewName = document.getElementById('locationPreviewName');
    const locationPreviewAddress = document.getElementById('locationPreviewAddress');
    const locationNameInput = document.getElementById('locationNameInput');
    const locationAddressInput = document.getElementById('locationAddressInput');
    const locationImageUpload = document.getElementById('locationImageUpload');
    const locationImageInput = document.getElementById('locationImageInput');
    const locationCancelBtn = document.getElementById('locationCancelBtn');
    const locationSendBtn = document.getElementById('locationSendBtn');
    
    // 转账相关DOM元素
    const transferBtn = document.getElementById('transferBtn');
    const transferModal = document.getElementById('transferModal');
    const transferModalClose = document.getElementById('transferModalClose');
    const transferPreviewAmount = document.getElementById('transferPreviewAmount');
    const transferPreviewNote = document.getElementById('transferPreviewNote');
    const transferAmountInput = document.getElementById('transferAmountInput');
    const transferNoteInput = document.getElementById('transferNoteInput');
    const transferReceiverInput = document.getElementById('transferReceiverInput');
    const transferCancelBtn = document.getElementById('transferCancelBtn');
    const transferSendBtn = document.getElementById('transferSendBtn');

    // 视频通话相关DOM元素
    const videoCallBtn = document.getElementById('videoCallBtn');
    const videoCallRequestModal = document.getElementById('videoCallRequestModal');
    const videoCallRequestAvatar = document.getElementById('videoCallRequestAvatar');
    const videoCallRequestName = document.getElementById('videoCallRequestName');
    const videoCallDeclineBtn = document.getElementById('videoCallDeclineBtn');
    const videoCallAcceptBtn = document.getElementById('videoCallAcceptBtn');
    const videoCallModal = document.getElementById('videoCallModal');
    const videoCallMainImage = document.getElementById('videoCallMainImage');
    const videoCallMainVideo = document.getElementById('videoCallMainVideo');
    const videoCallUserName = document.getElementById('videoCallUserName');
    const videoCallDuration = document.getElementById('videoCallDuration');
    const videoCallUserAvatar = document.getElementById('videoCallUserAvatar');
    const videoCallMessages = document.getElementById('videoCallMessages');
    const videoCallInput = document.getElementById('videoCallInput');
    const videoCallSendBtn = document.getElementById('videoCallSendBtn');
    const videoCallMuteBtn = document.getElementById('videoCallMuteBtn');
    const videoCallCameraBtn = document.getElementById('videoCallCameraBtn');
    const videoCallHangupBtn = document.getElementById('videoCallHangupBtn');
    
    // 拍一拍提醒相关DOM元素
    const patReminderModal = document.getElementById('patReminderModal');
    const patReminderAvatar = document.getElementById('patReminderAvatar');
    const patReminderText = document.getElementById('patReminderText');
    const patReminderClose = document.getElementById('patReminderClose');
    
    // 标题编辑功能
    let isEditingTitle = false;
    let originalTitle = '';
    
    function enableTitleEdit() {
      if (isEditingTitle) return;
      
      isEditingTitle = true;
      originalTitle = chatTitle.textContent;
      
      // 创建编辑容器
      const editContainer = document.createElement('div');
      editContainer.className = 'chat-title-edit-container';
      editContainer.style.cssText = `
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.95);
        padding: 12px;
        border-radius: 8px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        position: relative;
        z-index: 1000;
      `;
      
      // 创建输入框
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'chat-title-input';
      input.value = originalTitle;
      input.maxLength = 20; // 限制标题长度
      input.style.cssText = `
        background: rgba(255, 255, 255, 1);
        border: 2px solid #ddd;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 16px;
        color: #333;
        min-width: 200px;
        text-align: center;
        outline: none;
        transition: border-color 0.2s ease;
      `;
      
      // 创建按钮容器
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = `
        display: flex;
        gap: 12px;
        align-items: center;
      `;
      
      // 创建确认按钮
      const confirmBtn = document.createElement('button');
      confirmBtn.innerHTML = '✓ 确认';
      confirmBtn.title = '确认修改';
      confirmBtn.style.cssText = `
        background: #07c160;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        transition: all 0.2s ease;
      `;
      
      // 创建取消按钮
      const cancelBtn = document.createElement('button');
      cancelBtn.innerHTML = '✕ 取消';
      cancelBtn.title = '取消修改';
      cancelBtn.style.cssText = `
        background: #fa5151;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        transition: all 0.2s ease;
      `;
      
      // 组装编辑界面
      buttonContainer.appendChild(confirmBtn);
      buttonContainer.appendChild(cancelBtn);
      editContainer.appendChild(input);
      editContainer.appendChild(buttonContainer);
      
      // 将编辑容器添加到标题元素内部
      chatTitle.appendChild(editContainer);
      
      // 自动选中文本并聚焦
      input.select();
      input.focus();
      
      // 保存标题
      function saveTitleEdit() {
        const newTitle = input.value.trim();
        if (newTitle && newTitle !== originalTitle) {
          chatTitle.textContent = newTitle;
          
          // 更新当前聊天的自定义标题
          const currentChat = chatList.find(c => c.id === currentChatId);
          if (currentChat) {
            currentChat.customTitle = newTitle;
            // 如果自定义标题和默认标题一样，清除自定义标题
            const defaultTitle = getDefaultTitle(currentChat);
            if (newTitle === defaultTitle) {
              delete currentChat.customTitle;
              chatTitle.classList.remove('custom-title');
            } else {
              chatTitle.classList.add('custom-title');
            }
            saveChatList();
            renderChatList(); // 更新聊天列表显示
          }
        }
        exitTitleEdit();
      }
      
      // 取消编辑
      function cancelTitleEdit() {
        chatTitle.textContent = originalTitle;
        exitTitleEdit();
        // 取消编辑时不需要更新聊天列表，因为没有实际修改
      }
      
      // 退出编辑模式
      function exitTitleEdit() {
        if (editContainer.parentNode) {
          editContainer.parentNode.removeChild(editContainer);
        }
        isEditingTitle = false;
      }
      
      // 事件监听
      confirmBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        saveTitleEdit();
      });
      
      cancelBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        cancelTitleEdit();
      });
      
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          saveTitleEdit();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelTitleEdit();
        }
      });
      
      // 点击其他地方取消编辑
      document.addEventListener('click', function handleClickOutside(e) {
        if (!editContainer.contains(e.target)) {
          cancelTitleEdit();
          document.removeEventListener('click', handleClickOutside);
        }
      });
    }
    
    // 获取默认标题（用于聊天界面头部显示）
    function getDefaultTitle(chat) {
      if (!chat) return 'AI微信聊天';
      
      if (chat.type === 'group') {
        const roleCount = chat.roles ? chat.roles.length : 0;
        return `${chat.name} (${roleCount}个角色)`;
      } else if (chat.roleName) {
        return `与${chat.roleName}聊天`;
      } else {
        return chat.name;
      }
    }
    
    // 获取聊天列表中的显示标题（用于聊天列表显示）
    function getDisplayTitle(chat) {
      if (!chat) return 'AI微信聊天';
      
      // 对于聊天列表，使用基础名称
      return chat.name;
    }
    
    // 重置标题为默认值
    function resetTitleToDefault() {
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (currentChat) {
        delete currentChat.customTitle;
        chatTitle.classList.remove('custom-title');
        saveChatList();
        renderChatList();
        updateChatHeader();
      }
    }
    
    // 为标题添加点击事件
    chatTitle.addEventListener('click', enableTitleEdit);
    chatTitle.addEventListener('dblclick', enableTitleEdit);
    
    // 为标题添加右键菜单
    chatTitle.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (currentChat && currentChat.customTitle) {
        if (confirm('是否要重置标题为默认值？')) {
          resetTitleToDefault();
        }
      }
    });
    const groupChatControls = document.getElementById('groupChatControls');
    const singleRoleSettings = document.getElementById('singleRoleSettings');
    const addRoleBtn = document.getElementById('addRoleBtn');
    const rolesList = document.getElementById('rolesList');
    
    // 群聊角色编辑弹窗元素
    const roleEditModal = document.getElementById('roleEditModal');
    const roleEditTitle = document.getElementById('roleEditTitle');
    const closeRoleEditModal = document.getElementById('closeRoleEditModal');
    const modalRolePresetSelect = document.getElementById('modalRolePresetSelect');
    const modalRoleNameInput = document.getElementById('modalRoleNameInput');
    const modalRoleDescInput = document.getElementById('modalRoleDescInput');
    const modalRoleAvatarInput = document.getElementById('modalRoleAvatarInput');
    const modalRoleFrequencySelect = document.getElementById('modalRoleFrequencySelect');
    const saveRoleEditBtn = document.getElementById('saveRoleEditBtn');
    const cancelRoleEditBtn = document.getElementById('cancelRoleEditBtn');
    
    const apiUrlInput = document.getElementById('apiUrlInput');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const modelSelect = document.getElementById('modelSelect');
    const modelInfo = document.getElementById('modelInfo');
    
    // API配置管理相关元素
    const apiConfigNameInput = document.getElementById('apiConfigNameInput');
    const savedApiSelect = document.getElementById('savedApiSelect');
    const loadApiBtn = document.getElementById('loadApiBtn');
    const deleteApiBtn = document.getElementById('deleteApiBtn');
    const newApiConfigBtn = document.getElementById('newApiConfigBtn');
    const saveAsNewBtn = document.getElementById('saveAsNewBtn');
    const updateCurrentBtn = document.getElementById('updateCurrentBtn');
    
    // 识图API相关元素
    const visionApiUrlInput = document.getElementById('visionApiUrlInput');
    const visionApiKeyInput = document.getElementById('visionApiKeyInput');
    const visionModelSelect = document.getElementById('visionModelSelect');
    const testVisionBtn = document.getElementById('testVisionBtn');
    const refreshVisionModelsBtn = document.getElementById('refreshVisionModelsBtn');
    const debugVisionModelsBtn = document.getElementById('debugVisionModelsBtn');
    
    // 图片上传相关元素
    const imageBtn = document.getElementById('imageBtn');
    const imageFileInput = document.getElementById('imageFileInput');
    
    const roleNameInput = document.getElementById('roleNameInput');
    const roleDescInput = document.getElementById('roleDescInput');
    const rolePresetSelect = document.getElementById('rolePresetSelect');
    const userNameInput = document.getElementById('userNameInput');
    const userDescInput = document.getElementById('userDescInput');
    const userAvatarInput = document.getElementById('userAvatarInput');
    const aiAvatarInput = document.getElementById('aiAvatarInput');
    const testResult = document.getElementById('testResult');
    const testBtn = document.getElementById('testBtn');
    const refreshModelsBtn = document.getElementById('refreshModelsBtn');
    const directChatTestBtn = document.getElementById('directChatTestBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const saveRoleBtn = document.getElementById('saveRoleBtn');
    const cancelRoleBtn = document.getElementById('cancelRoleBtn');
    const clearChatBtn = document.getElementById('clearChatBtn');
    const exportChatBtn = document.getElementById('exportChatBtn');
    const importChatBtn = document.getElementById('importChatBtn');
    const importFileInput = document.getElementById('importFileInput');
    const statusIndicator = document.getElementById('statusIndicator');
    const emojiBtn = document.getElementById('emojiBtn');
    const emojiPanel = document.getElementById('emojiPanel');
    const emojiGallery = document.getElementById('emojiGallery');
    const newEmojiInput = document.getElementById('newEmojiInput');
    const addEmojiBtn = document.getElementById('addEmojiBtn');
    const closeEmojiBtn = document.getElementById('closeEmojiBtn');
    
    // 文件上传相关元素
    const uploadEmojiBtn = document.getElementById('uploadEmojiBtn');
    const emojiFileInput = document.getElementById('emojiFileInput');
    const uploadAiAvatarBtn = document.getElementById('uploadAiAvatarBtn');
    const aiAvatarFileInput = document.getElementById('aiAvatarFileInput');
    const uploadUserAvatarBtn = document.getElementById('uploadUserAvatarBtn');
    const userAvatarFileInput = document.getElementById('userAvatarFileInput');
    const uploadModalRoleAvatarBtn = document.getElementById('uploadModalRoleAvatarBtn');
    const modalRoleAvatarFileInput = document.getElementById('modalRoleAvatarFileInput');
    
    // 预设管理相关元素
    const userPresetSelect = document.getElementById('userPresetSelect');
    const saveRolePresetBtn = document.getElementById('saveRolePresetBtn');
    const manageRolePresetsBtn = document.getElementById('manageRolePresetsBtn');
    const saveUserPresetBtn = document.getElementById('saveUserPresetBtn');
    const manageUserPresetsBtn = document.getElementById('manageUserPresetsBtn');
    const saveModalRolePresetBtn = document.getElementById('saveModalRolePresetBtn');
    const manageModalRolePresetsBtn = document.getElementById('manageModalRolePresetsBtn');
    
    // 预设管理弹窗元素
    const presetManageModal = document.getElementById('presetManageModal');
    const presetManageTitle = document.getElementById('presetManageTitle');
    const closePresetManageModal = document.getElementById('closePresetManageModal');
    const closePresetManageBtn = document.getElementById('closePresetManageBtn');
    const presetList = document.getElementById('presetList');
    
    // 保存预设弹窗元素
    const savePresetModal = document.getElementById('savePresetModal');
    const savePresetTitle = document.getElementById('savePresetTitle');
    const closeSavePresetModal = document.getElementById('closeSavePresetModal');
    const cancelSavePresetBtn = document.getElementById('cancelSavePresetBtn');
    const presetNameInput = document.getElementById('presetNameInput');
    const presetDescInput = document.getElementById('presetDescInput');
    const confirmSavePresetBtn = document.getElementById('confirmSavePresetBtn');
    
    // 当前选中的情绪
    let currentEmotion = 'happy';

    // 文件上传工具函数
    
    // 将文件转换为Base64
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
      });
    }

    // 压缩图片
    function compressImage(file, maxWidth = 800, maxHeight = 600, quality = 0.8) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        img.onload = function() {
          // 计算新的尺寸
          let { width, height } = img;
          if (width > height) {
            if (width > maxWidth) {
              height = height * (maxWidth / width);
              width = maxWidth;
            }
          } else {
            if (height > maxHeight) {
              width = width * (maxHeight / height);
              height = maxHeight;
            }
          }
          
          // 设置canvas尺寸
          canvas.width = width;
          canvas.height = height;
          
          // 绘制图片
          ctx.drawImage(img, 0, 0, width, height);
          
          // 转换为base64
          const compressedBase64 = canvas.toDataURL('image/jpeg', quality);
          resolve(compressedBase64);
        };
        img.src = URL.createObjectURL(file);
      });
    }

    // 验证图片文件
    function validateImageFile(file) {
      const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
      const maxSize = 10 * 1024 * 1024; // 10MB
      
      if (!validTypes.includes(file.type)) {
        alert('请选择有效的图片文件（JPG、PNG、GIF、WebP）');
        return false;
      }
      
      if (file.size > maxSize) {
        alert('文件大小不能超过10MB');
        return false;
      }
      
      return true;
    }

    // 处理图片上传
    async function handleImageUpload(file, targetInput, isEmoji = false, buttonElement = null) {
      if (!validateImageFile(file)) {
        return;
      }
      
      try {
        // 显示加载提示
        const loadingText = isEmoji ? '正在上传表情包...' : '正在上传头像...';
        let button = buttonElement;
        let originalText = '';
        
        // 查找对应的按钮元素
        if (!button) {
          if (isEmoji) {
            button = uploadEmojiBtn;
          } else if (targetInput === aiAvatarInput) {
            button = uploadAiAvatarBtn;
          } else if (targetInput === userAvatarInput) {
            button = uploadUserAvatarBtn;
          } else if (targetInput === modalRoleAvatarInput) {
            button = uploadModalRoleAvatarBtn;
          }
        }
        
        if (button) {
          originalText = button.textContent;
          button.textContent = loadingText;
          button.disabled = true;
        }
        
        // 压缩图片
        const maxWidth = isEmoji ? 400 : 200;
        const maxHeight = isEmoji ? 400 : 200;
        const compressedBase64 = await compressImage(file, maxWidth, maxHeight, 0.8);
        
        // 更新目标输入框
        if (targetInput) {
          targetInput.value = compressedBase64;
          
          // 添加预览图片
          addImagePreview(targetInput, compressedBase64);
        }
        
        // 恢复按钮状态
        if (button) {
          button.textContent = originalText;
          button.disabled = false;
        }
        
        // 显示成功提示
        const successText = isEmoji ? '表情包上传成功！' : '头像上传成功！';
        alert(successText);
        
        // 如果是表情包，自动添加到当前情绪
        if (isEmoji) {
          addEmojiToCurrentEmotion(compressedBase64);
        }
        
      } catch (error) {
        console.error('图片上传失败:', error);
        alert('图片上传失败，请重试');
        
        // 恢复按钮状态
        let button = buttonElement;
        if (!button) {
          if (isEmoji) {
            button = uploadEmojiBtn;
          } else if (targetInput === aiAvatarInput) {
            button = uploadAiAvatarBtn;
          } else if (targetInput === userAvatarInput) {
            button = uploadUserAvatarBtn;
          } else if (targetInput === modalRoleAvatarInput) {
            button = uploadModalRoleAvatarBtn;
          }
        }
        
        if (button) {
          const originalText = isEmoji ? '上传文件' : button.textContent.replace('正在上传...', '').replace('正在上传头像...', '').replace('正在上传表情包...', '') || '上传文件';
          button.textContent = originalText;
          button.disabled = false;
        }
      }
    }

    // 添加表情包到当前情绪
    function addEmojiToCurrentEmotion(emojiUrl) {
      if (!emojiData[currentEmotion]) {
        emojiData[currentEmotion] = [];
      }
      
      emojiData[currentEmotion].push(emojiUrl);
      localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
      updateEmojiGallery();
    }

    // 处理视频通话画面文件上传
    async function handleVideoCallMediaUpload(file, targetInput) {
      // 验证文件类型
      const allowedImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp', 'image/bmp'];
      const allowedVideoTypes = ['video/mp4', 'video/webm', 'video/ogg', 'video/mov', 'video/avi', 'video/3gp', 'video/quicktime'];
      
      const isValidImage = allowedImageTypes.includes(file.type) || file.type.startsWith('image/');
      const isValidVideo = allowedVideoTypes.includes(file.type) || file.type.startsWith('video/');
      
      if (!isValidImage && !isValidVideo) {
        alert('不支持的文件格式，请选择图片或视频文件');
        return;
      }
      
      // 验证文件大小 (图片最大10MB，视频最大50MB)
      const maxImageSize = 10 * 1024 * 1024; // 10MB
      const maxVideoSize = 50 * 1024 * 1024; // 50MB
      const maxSize = isValidImage ? maxImageSize : maxVideoSize;
      
      if (file.size > maxSize) {
        const sizeLimit = isValidImage ? '10MB' : '50MB';
        alert(`文件大小不能超过${sizeLimit}`);
        return;
      }
      
      try {
        // 显示加载提示
        const loadingText = '正在上传视频通话画面...';
        let button = null;
        let originalText = '';
        
        // 查找对应的按钮元素
        if (targetInput && targetInput.id === 'modalRoleVideoInput') {
          button = document.getElementById('uploadModalRoleVideoBtn');
        } else if (targetInput && targetInput.id === 'aiVideoInput') {
          button = document.getElementById('uploadAiVideoBtn');
        }
        
        if (button) {
          originalText = button.textContent;
          button.textContent = loadingText;
          button.disabled = true;
        }
        
        // 检测是否为移动设备，如果是则进行压缩
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let processedFile = file;
        
        if (isMobile && isValidImage) {
          // 移动端图片压缩
          try {
            processedFile = await compressImageForMobile(file);
          } catch (error) {
            console.warn('图片压缩失败，使用原文件:', error);
          }
        }
        
        // 将文件转换为base64
        const fileBase64 = await fileToBase64(processedFile);
        
        // 更新目标输入框
        if (targetInput) {
          targetInput.value = fileBase64;
          
          // 添加预览
          addVideoCallMediaPreview(targetInput, fileBase64, file.type);
        }
        
        // 恢复按钮状态
        if (button) {
          button.textContent = originalText;
          button.disabled = false;
        }
        
        // 显示成功提示
        const fileType = file.type.startsWith('video/') ? '视频' : '图片';
        alert(`${fileType}上传成功！`);
        
      } catch (error) {
        console.error('视频通话画面上传失败:', error);
        alert('文件上传失败，请重试');
        
        // 恢复按钮状态
        let button = null;
        if (targetInput && targetInput.id === 'modalRoleVideoInput') {
          button = document.getElementById('uploadModalRoleVideoBtn');
        } else if (targetInput && targetInput.id === 'aiVideoInput') {
          button = document.getElementById('uploadAiVideoBtn');
        }
        
        if (button) {
          button.textContent = originalText || '📹 上传视频/图片';
          button.disabled = false;
        }
      }
    }

    // 将文件转换为base64
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // 移动端图片压缩
    function compressImageForMobile(file, maxWidth = 1920, maxHeight = 1080, quality = 0.8) {
      return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
          // 计算新的尺寸
          let { width, height } = img;
          
          // 如果图片尺寸超过限制，进行缩放
          if (width > maxWidth || height > maxHeight) {
            const ratio = Math.min(maxWidth / width, maxHeight / height);
            width = Math.floor(width * ratio);
            height = Math.floor(height * ratio);
          }
          
          // 设置canvas尺寸
          canvas.width = width;
          canvas.height = height;
          
          // 绘制图片
          ctx.drawImage(img, 0, 0, width, height);
          
          // 转换为blob
          canvas.toBlob((blob) => {
            if (blob) {
              // 创建新的File对象
              const compressedFile = new File([blob], file.name, {
                type: file.type,
                lastModified: Date.now()
              });
              resolve(compressedFile);
            } else {
              reject(new Error('图片压缩失败'));
            }
          }, file.type, quality);
        };
        
        img.onerror = () => reject(new Error('图片加载失败'));
        img.src = URL.createObjectURL(file);
      });
    }

    // 移动端视频上传菜单
    function showMobileVideoUploadMenu(fileInput) {
      // 创建弹窗
      const modal = document.createElement('div');
      modal.className = 'mobile-upload-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: flex-end;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: white;
        width: 100%;
        max-width: 500px;
        border-radius: 20px 20px 0 0;
        padding: 20px;
        animation: slideUp 0.3s ease;
      `;
      
      content.innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
          <h3 style="margin: 0; color: #333;">选择上传方式</h3>
        </div>
        <div class="upload-options">
          <button class="upload-option-btn" data-action="camera">
            <span class="icon">📹</span>
            <span>拍摄视频</span>
          </button>
          <button class="upload-option-btn" data-action="video">
            <span class="icon">🎬</span>
            <span>选择视频</span>
          </button>
          <button class="upload-option-btn" data-action="photo">
            <span class="icon">📷</span>
            <span>拍照</span>
          </button>
          <button class="upload-option-btn" data-action="image">
            <span class="icon">🖼️</span>
            <span>选择图片</span>
          </button>
        </div>
        <button class="cancel-upload-btn" style="width: 100%; padding: 15px; margin-top: 15px; background: #f5f5f5; border: none; border-radius: 10px; font-size: 16px;">取消</button>
      `;
      
      // 添加样式
      const style = document.createElement('style');
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideUp {
          from { transform: translateY(100%); }
          to { transform: translateY(0); }
        }
        .upload-options {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 15px;
          margin-bottom: 10px;
        }
        .upload-option-btn {
          display: flex;
          flex-direction: column;
          align-items: center;
          padding: 20px 15px;
          background: #f8f9fa;
          border: 1px solid #e9ecef;
          border-radius: 12px;
          cursor: pointer;
          transition: all 0.2s ease;
        }
        .upload-option-btn:hover {
          background: #e9ecef;
          border-color: #6DA3BD;
        }
        .upload-option-btn .icon {
          font-size: 24px;
          margin-bottom: 8px;
        }
        .upload-option-btn span:last-child {
          font-size: 14px;
          color: #333;
        }
      `;
      document.head.appendChild(style);
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // 创建不同类型的文件输入
      const createFileInput = (accept, capture) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = accept;
        if (capture) input.capture = capture;
        input.style.display = 'none';
        document.body.appendChild(input);
        return input;
      };
      
      // 事件处理
      content.addEventListener('click', (e) => {
        const btn = e.target.closest('.upload-option-btn');
        if (!btn) return;
        
        const action = btn.dataset.action;
        let tempInput;
        
        switch (action) {
          case 'camera':
            tempInput = createFileInput('video/*', 'environment');
            break;
          case 'video':
            tempInput = createFileInput('video/*');
            break;
          case 'photo':
            tempInput = createFileInput('image/*', 'environment');
            break;
          case 'image':
            tempInput = createFileInput('image/*');
            break;
        }
        
        if (tempInput) {
          tempInput.onchange = function(e) {
            const file = e.target.files[0];
            if (file) {
              // 触发原始文件输入的change事件
              Object.defineProperty(fileInput, 'files', {
                value: e.target.files,
                writable: false
              });
              fileInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            // 清理临时输入
            document.body.removeChild(tempInput);
          };
          tempInput.click();
        }
        
        // 关闭弹窗
        modal.remove();
        style.remove();
      });
      
      // 取消按钮和背景点击关闭
      content.querySelector('.cancel-upload-btn').onclick = () => {
        modal.remove();
        style.remove();
      };
      
      modal.onclick = (e) => {
        if (e.target === modal) {
          modal.remove();
          style.remove();
        }
      };
    }

    // 添加视频通话画面预览
    function addVideoCallMediaPreview(targetInput, mediaSrc, fileType) {
      // 查找或创建预览容器
      let previewContainer = targetInput.parentNode.querySelector('.preview-container');
      if (!previewContainer) {
        previewContainer = document.createElement('div');
        previewContainer.className = 'preview-container';
        previewContainer.style.marginTop = '10px';
        targetInput.parentNode.appendChild(previewContainer);
      }
      
      // 清空现有内容
      previewContainer.innerHTML = '';
      
      // 创建预览元素
      let previewElement;
      if (fileType.startsWith('video/')) {
        previewElement = document.createElement('video');
        previewElement.controls = true;
        previewElement.style.maxWidth = '200px';
        previewElement.style.maxHeight = '150px';
      } else {
        previewElement = document.createElement('img');
        previewElement.className = 'preview-image';
        previewElement.alt = '预览图片';
      }
      
      previewElement.src = mediaSrc;
      
      // 创建删除按钮
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '✕';
      deleteBtn.className = 'setting-btn cancel-btn';
      deleteBtn.style.marginLeft = '10px';
      deleteBtn.style.padding = '4px 8px';
      deleteBtn.style.fontSize = '12px';
      deleteBtn.onclick = function() {
        targetInput.value = '';
        previewContainer.remove();
      };
      
      // 添加到容器
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'center';
      wrapper.appendChild(previewElement);
      wrapper.appendChild(deleteBtn);
      previewContainer.appendChild(wrapper);
    }

    // 添加图片预览
    function addImagePreview(targetInput, imageSrc) {
      // 查找或创建预览容器
      let previewContainer = targetInput.parentNode.querySelector('.preview-container');
      if (!previewContainer) {
        previewContainer = document.createElement('div');
        previewContainer.className = 'preview-container';
        previewContainer.style.marginTop = '10px';
        targetInput.parentNode.appendChild(previewContainer);
      }
      
      // 清空现有内容
      previewContainer.innerHTML = '';
      
      // 创建预览图片
      const previewImg = document.createElement('img');
      previewImg.src = imageSrc;
      previewImg.className = 'preview-image';
      previewImg.alt = '预览图片';
      
      // 创建删除按钮
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = '✕';
      deleteBtn.className = 'setting-btn cancel-btn';
      deleteBtn.style.marginLeft = '10px';
      deleteBtn.style.padding = '4px 8px';
      deleteBtn.style.fontSize = '12px';
      deleteBtn.onclick = function() {
        targetInput.value = '';
        previewContainer.remove();
      };
      
      // 添加到容器
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'center';
      wrapper.appendChild(previewImg);
      wrapper.appendChild(deleteBtn);
      previewContainer.appendChild(wrapper);
    }

    // 生成唯一ID
    function generateId() {
      return Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // 获取当前时间戳
    function getCurrentTime() {
      return new Date().toISOString();
    }

    // 格式化时间显示（用于聊天列表）
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffTime = now - date;
      const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) {
        return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
      } else if (diffDays === 1) {
        return '昨天';
      } else if (diffDays < 7) {
        return `${diffDays}天前`;
      } else {
        return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
      }
    }

    // 格式化消息时间显示（用于气泡）
    function formatMessageTime(timestamp = null) {
      const date = timestamp ? new Date(timestamp) : new Date();
      const now = new Date();
      const diffTime = now - date;
      const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) {
        // 今天显示时分秒
        return date.toLocaleTimeString('zh-CN', { 
          hour: '2-digit', 
          minute: '2-digit',
          second: '2-digit'
        });
      } else if (diffDays === 1) {
        // 昨天显示"昨天 时:分"
        return '昨天 ' + date.toLocaleTimeString('zh-CN', { 
          hour: '2-digit', 
          minute: '2-digit'
        });
      } else if (diffDays < 7) {
        // 一周内显示"X天前 时:分"
        return `${diffDays}天前 ` + date.toLocaleTimeString('zh-CN', { 
          hour: '2-digit', 
          minute: '2-digit'
        });
      } else {
        // 超过一周显示"月-日 时:分"
        return date.toLocaleDateString('zh-CN', { 
          month: '2-digit', 
          day: '2-digit'
        }) + ' ' + date.toLocaleTimeString('zh-CN', { 
          hour: '2-digit', 
          minute: '2-digit'
        });
      }
    }

    // 创建新聊天
    function createNewChat() {
      const chatId = generateId();
      const newChat = {
        id: chatId,
        name: '新聊天',
        type: 'single', // 'single' 或 'group'
        avatar: DEFAULT_AI_AVATAR,
        lastMessage: '',
        lastTime: getCurrentTime(),
        conversationHistory: [],
        chatDisplay: [],
        // 单聊角色信息
        roleName: '',
        roleDescription: '',
        userName: '',
        userDescription: '',
        userAvatar: DEFAULT_USER_AVATAR,
        aiAvatar: DEFAULT_AI_AVATAR,
        // 群聊角色信息
        roles: [], // 群聊中的多个角色
        groupSettings: {
          maxRolesPerReply: 3, // 每次最多几个角色回复
          replyDelay: 1000 // 角色回复间隔(ms)
        }
      };
      
      chatList.unshift(newChat); // 添加到列表开头
      saveChatList();
      renderChatList();
      
      // 确保新聊天时清空AI记忆
      window.conversationHistory = [];
      console.log('新建聊天：已清空AI记忆');
      
      openChat(chatId);
    }

    // 创建新群聊
    function createNewGroupChat() {
      const chatId = generateId();
      const newChat = {
        id: chatId,
        name: '新群聊',
        type: 'group',
        avatar: DEFAULT_AI_AVATAR,
        lastMessage: '',
        lastTime: getCurrentTime(),
        conversationHistory: [],
        chatDisplay: [],
        // 单聊角色信息（保持兼容性）
        roleName: '',
        roleDescription: '',
        userName: '',
        userDescription: '',
        userAvatar: DEFAULT_USER_AVATAR,
        aiAvatar: DEFAULT_AI_AVATAR,
        // 群聊角色信息
        roles: [], // 群聊中的多个角色
        groupSettings: {
          maxRolesPerReply: 3, // 每次最多几个角色回复
          replyDelay: 1000 // 角色回复间隔(ms)
        }
      };
      
      chatList.unshift(newChat);
      saveChatList();
      renderChatList();
      
      // 确保新群聊时清空AI记忆
      window.conversationHistory = [];
      console.log('新建群聊：已清空AI记忆');
      
      openChat(chatId);
    }

    // 删除聊天
    function deleteChat(chatId) {
      if (confirm('确定要删除这个聊天吗？')) {
        chatList = chatList.filter(chat => chat.id !== chatId);
        saveChatList();
        renderChatList();
        
        // 如果删除的是当前聊天，返回列表
        if (currentChatId === chatId) {
          currentChatId = null;
          showChatList();
        }
      }
    }

    // 打开聊天
    function openChat(chatId) {
      const chat = chatList.find(c => c.id === chatId);
      if (!chat) return;
      
      currentChatId = chatId;
      
      // 加载聊天数据
      loadChatData(chat);
      
      // 显示聊天界面
      showChatView();
      
      // 更新聊天标题
      updateChatHeader();
    }

    // 加载聊天数据
    function loadChatData(chat) {
      // 清理响应状态
      if (responseTimer) {
        clearTimeout(responseTimer);
        responseTimer = null;
      }
      isWaitingForResponse = false;
      pendingMessages = [];
      hideWaitingIndicator();
      updateSendButton();
      
      // 重置拍一拍计时器
      if (typeof resetActivityTimer === 'function') {
        resetActivityTimer();
      }
      
      // 加载角色和用户设定
      roleName = chat.roleName || '';
      roleDescription = chat.roleDescription || '';
      userName = chat.userName || '';
      userDescription = chat.userDescription || '';
      userAvatar = chat.userAvatar || DEFAULT_USER_AVATAR;
      aiAvatar = chat.aiAvatar || DEFAULT_AI_AVATAR;
      
      // 更新界面显示
      updateChatInterface(chat);
      
      // 清空聊天界面
      chatBody.innerHTML = '';
      
      // 清空并重新加载对话历史（确保AI只能看到当前聊天的记录）
      window.conversationHistory = chat.conversationHistory ? [...chat.conversationHistory] : [];
      console.log('已加载聊天对话历史:', window.conversationHistory.length, '条');
      
      // 恢复聊天记录
      if (chat.chatDisplay && chat.chatDisplay.length > 0) {
        chat.chatDisplay.forEach(msg => {
          if (msg.type === 'emoji') {
            // 使用新的表情包消息创建函数
            createEmojiMessage(msg.sender || msg.role, msg.content, msg.id, msg.timestamp, msg.roleId, msg.roleName);
          } else if (msg.type === 'location') {
            // 位置消息
            appendMsg(msg.role, msg.content, false, msg.roleId, msg.roleName, msg.timestamp, msg.id, null, false, null, false, null, 'location');
          } else if (msg.type === 'transfer') {
            // 转账消息
            appendMsg(msg.role, msg.content, false, msg.roleId, msg.roleName, msg.timestamp, msg.id, null, false, null, false, null, 'transfer');
          } else if (msg.type === 'chatRecord') {
            // 聊天记录消息
            appendMsg(msg.role, '', false, msg.roleId, msg.roleName, msg.timestamp, msg.id, null, false, null, true, msg.chatRecordData);
          } else if (msg.type === 'forward') {
            // 转发消息
            appendMsg(msg.role, msg.content, false, msg.roleId, msg.roleName, msg.timestamp, msg.id, null, true, msg.forwardFrom);
          } else if (msg.type === 'image') {
            // 图片消息
            appendMsg(msg.role, msg.content, false, msg.roleId, msg.roleName, msg.timestamp, msg.id, null, false, null, false, null, 'image');
          } else if (msg.type === 'pat') {
            // 拍一拍消息
            loadPatMessage(msg);
          } else {
            // 普通消息（可能包含回复引用）
            appendMsg(msg.role, msg.content, false, msg.roleId, msg.roleName, msg.timestamp, msg.id, msg.replyTo);
          }
        });
        
        // 更新现有消息的操作菜单
        updateMenusAfterLoad();
      } else {
        // 即使没有聊天记录，也要更新菜单
        updateMenusAfterLoad();
      }
      
      // 处理待处理的转发消息（如果有）
      if (chat.pendingMessages && chat.pendingMessages.length > 0) {
        chat.pendingMessages.forEach(pendingMsg => {
          if (pendingMsg.isForwarded) {
            // 将转发消息添加到消息队列，触发AI回复
            pendingMessages.push({
              text: pendingMsg.text,
              chat: chat,
              timestamp: pendingMsg.timestamp,
              isForwarded: true
            });
          }
        });
        
        // 清空待处理消息
        chat.pendingMessages = [];
        
        // 如果有待处理消息，启动AI回复
        if (pendingMessages.length > 0) {
          if (aiResponseDelay === 0) {
            setTimeout(() => processMessages(), 500); // 延迟确保UI完全加载
          } else {
            startResponseTimer();
          }
        }
      }
    }

    // 更新聊天界面显示
    function updateChatInterface(chat) {
      // 更新聊天类型显示
      if (chat.type === 'group') {
        chatTypeDisplay.textContent = '群聊';
        groupChatControls.style.display = 'block';
        singleRoleSettings.style.display = 'none';
        updateRolesList(chat);
        
        // 更新群聊设置显示
        const maxRolesSelect = document.getElementById('maxRolesPerReplySelect');
        if (maxRolesSelect && chat.groupSettings) {
          maxRolesSelect.value = chat.groupSettings.maxRolesPerReply || 3;
        }
      } else {
        chatTypeDisplay.textContent = '单聊';
        groupChatControls.style.display = 'none';
        singleRoleSettings.style.display = 'block';
        
        // 更新单聊角色设定输入框
        roleNameInput.value = roleName;
        roleDescInput.value = roleDescription;
        aiAvatarInput.value = aiAvatar === DEFAULT_AI_AVATAR ? '' : aiAvatar;
        
        // 更新视频通话画面设定
        const aiVideoInput = document.getElementById('aiVideoInput');
        if (aiVideoInput) {
          aiVideoInput.value = chat.aiVideo && chat.aiVideo !== aiAvatar ? chat.aiVideo : '';
        }
      }
      
      // 更新用户设定输入框（对单聊和群聊都有效）
      userNameInput.value = userName;
      userDescInput.value = userDescription;
      userAvatarInput.value = userAvatar === DEFAULT_USER_AVATAR ? '' : userAvatar;
    }

    // 更新群聊角色列表显示
    function updateRolesList(chat) {
      if (!chat || chat.type !== 'group') {
        rolesList.innerHTML = '';
        return;
      }
      
      if (chat.roles.length === 0) {
        rolesList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">还没有添加角色，点击上方按钮添加</div>';
        return;
      }
      
      rolesList.innerHTML = chat.roles.map((role, index) => `
        <div class="role-item">
          <img class="role-item-avatar" src="${role.avatar || DEFAULT_AI_AVATAR}" alt="${role.name}" onerror="this.src='${DEFAULT_AI_AVATAR}'">
          <div class="role-item-info">
            <div class="role-item-name">${role.name || '未命名角色'}</div>
            <div class="role-item-desc">${role.description ? (role.description.length > 50 ? role.description.substring(0, 50) + '...' : role.description) : '暂无描述'}</div>
            <div class="role-item-frequency">回复频率: ${getFrequencyText(role.frequency)}</div>
          </div>
          <div class="role-item-actions">
            <button class="role-item-btn edit" data-role-index="${index}">编辑</button>
            <button class="role-item-btn delete" data-role-index="${index}">删除</button>
          </div>
        </div>
      `).join('');
      
      // 添加事件监听器
      rolesList.querySelectorAll('.role-item-btn.edit').forEach(btn => {
        btn.addEventListener('click', function() {
          const roleIndex = parseInt(this.getAttribute('data-role-index'));
          editRole(roleIndex);
        });
      });
      
      rolesList.querySelectorAll('.role-item-btn.delete').forEach(btn => {
        btn.addEventListener('click', function() {
          const roleIndex = parseInt(this.getAttribute('data-role-index'));
          deleteRole(roleIndex);
        });
      });
    }

    // 获取频率文本
    function getFrequencyText(frequency) {
      const frequencies = {
        'always': '每次都回复',
        'often': '经常回复',
        'sometimes': '偶尔回复',
        'rarely': '很少回复'
      };
      return frequencies[frequency] || '每次都回复';
    }

    // 保存当前聊天数据
    function saveCurrentChatData() {
      if (!currentChatId) return;
      
      const chat = chatList.find(c => c.id === currentChatId);
      if (!chat) return;
      
      // 保存角色和用户设定
      chat.roleName = roleName;
      chat.roleDescription = roleDescription;
      chat.userName = userName;
      chat.userDescription = userDescription;
      chat.userAvatar = userAvatar;
      chat.aiAvatar = aiAvatar;
      
      // 保存对话历史（从全局变量）
      if (window.conversationHistory) {
        chat.conversationHistory = [...window.conversationHistory];
      }
      
      // 保存界面显示
      chat.chatDisplay = [];
      
      // 获取所有消息元素（包括普通消息和拍一拍消息）
      const allElements = chatBody.querySelectorAll('.msg, .pat-message');
      allElements.forEach(element => {
        // 处理拍一拍消息
        if (element.classList.contains('pat-message')) {
          const content = element.querySelector('.pat-message-content');
          if (content) {
            // 查找当前拍一拍消息前面的时间元素
            let timestamp = formatMessageTime();
            let prevElement = element.previousElementSibling;
            if (prevElement && prevElement.classList.contains('msg-time')) {
              const timeSpan = prevElement.querySelector('span');
              if (timeSpan) {
                timestamp = timeSpan.textContent;
              }
            }
            
            chat.chatDisplay.push({
              id: generateId(),
              type: 'pat',
              content: content.textContent,
              timestamp: timestamp
            });
          }
          return;
        }
        
        // 处理普通消息
        const msg = element;
        const isUser = msg.classList.contains('user');
        const bubble = msg.querySelector('.bubble');
        const isEmoji = bubble && bubble.classList.contains('emoji-bubble');
        const isLocation = bubble && bubble.classList.contains('location-bubble');
        const isTransfer = bubble && bubble.classList.contains('transfer-bubble');
        const roleNameElement = msg.querySelector('.role-name');
        
        // 获取角色信息（用于群聊）
        let roleId = null;
        let roleName = null;
        
        // 首先尝试从消息元素的data属性获取
        if (!isUser) {
          roleId = msg.getAttribute('data-role-id');
          roleName = msg.getAttribute('data-role-name');
        }
        
        // 如果没有从data属性获取到，再从角色名称元素获取
        if (!roleId && roleNameElement) {
          roleName = roleNameElement.textContent;
          // 从当前聊天的角色列表中查找对应的角色ID
          if (chat.type === 'group' && chat.roles) {
            const roleData = chat.roles.find(r => r.name === roleName);
            if (roleData) {
              roleId = roleData.id;
            }
          }
        }
        
        // 查找当前消息前面的时间元素
        let timestamp = formatMessageTime();
        let prevElement = msg.previousElementSibling;
        if (prevElement && prevElement.classList.contains('msg-time')) {
          const timeSpan = prevElement.querySelector('span');
          if (timeSpan) {
            timestamp = timeSpan.textContent;
          }
        }
        
        // 获取消息ID和附加信息
        const messageId = msg.getAttribute('data-message-id') || generateId();
        const forwardMessage = bubble.querySelector('.forward-message');
        const chatRecord = bubble.querySelector('.chat-record');
        const replyReference = bubble.querySelector('.reply-reference');
        const imageMessage = bubble.querySelector('.image-message');
        
        if (isEmoji) {
          const img = bubble.querySelector('img');
          chat.chatDisplay.push({
            id: messageId,
            role: isUser ? 'user' : 'ai',
            sender: isUser ? 'user' : 'ai',
            type: 'emoji',
            content: img.src,
            roleId: roleId,
            roleName: roleName,
            timestamp: timestamp
          });
        } else if (isLocation) {
          // 位置消息
          chat.chatDisplay.push({
            id: messageId,
            role: isUser ? 'user' : 'ai',
            type: 'location',
            content: bubble.innerHTML, // 保存完整的HTML内容
            roleId: roleId,
            roleName: roleName,
            timestamp: timestamp
          });
        } else if (isTransfer) {
          // 转账消息
          chat.chatDisplay.push({
            id: messageId,
            role: isUser ? 'user' : 'ai',
            type: 'transfer',
            content: bubble.innerHTML, // 保存完整的HTML内容
            roleId: roleId,
            roleName: roleName,
            timestamp: timestamp
          });
        } else if (chatRecord) {
          // 聊天记录消息
          const chatRecordId = chatRecord.getAttribute('data-chat-record-id');
          // 从全局存储中获取聊天记录数据
          const chatRecordData = window.chatRecordsData && window.chatRecordsData[chatRecordId] || {
            messages: [],
            fromChat: '未知聊天'
          };
          
          chat.chatDisplay.push({
            id: messageId,
            role: isUser ? 'user' : 'ai',
            type: 'chatRecord',
            content: `聊天记录 - ${chatRecordData.messages.length}条消息`,
            roleId: roleId,
            roleName: roleName,
            timestamp: timestamp,
            chatRecordData: chatRecordData
          });
        } else if (forwardMessage) {
          // 转发消息
          const forwardContent = forwardMessage.querySelector('.forward-content');
          const forwardFromElement = forwardMessage.querySelector('.forward-header span:not(.icon)');
          chat.chatDisplay.push({
            id: messageId,
            role: isUser ? 'user' : 'ai',
            type: 'forward',
            content: forwardContent ? forwardContent.textContent : '',
            roleId: roleId,
            roleName: roleName,
            timestamp: timestamp,
            forwardFrom: {
              chatName: forwardFromElement ? forwardFromElement.textContent.replace('转发自', '').replace('的聊天记录', '') : '未知来源'
            }
          });
        } else if (imageMessage) {
          // 图片消息
          chat.chatDisplay.push({
            id: messageId,
            role: isUser ? 'user' : 'ai',
            type: 'image',
            content: bubble.innerHTML, // 保存完整的HTML内容
            roleId: roleId,
            roleName: roleName,
            timestamp: timestamp
          });
        } else {
          // 普通消息
          let replyTo = null;
          if (replyReference) {
            const replyFromElement = replyReference.querySelector('.reply-from');
            const replyContentElement = replyReference.querySelector('.reply-content');
            replyTo = {
              fromName: replyFromElement ? replyFromElement.textContent : '未知',
              content: replyContentElement ? replyContentElement.textContent : ''
            };
          }
          
          // 获取消息的纯文本内容（排除回复引用）
          let content = '';
          if (bubble) {
            // 克隆节点以避免修改原始内容
            const clonedBubble = bubble.cloneNode(true);
            // 移除回复引用元素
            const clonedReplyRef = clonedBubble.querySelector('.reply-reference');
            if (clonedReplyRef) {
              clonedReplyRef.remove();
            }
            content = clonedBubble.textContent || clonedBubble.innerText || '';
          }
          
          chat.chatDisplay.push({
            id: messageId,
            role: isUser ? 'user' : 'ai',
            type: 'text',
            content: content,
            roleId: roleId,
            roleName: roleName,
            timestamp: timestamp,
            replyTo: replyTo
          });
        }
      });
      
      // 更新最后消息和时间
      if (chat.chatDisplay.length > 0) {
        const lastMsg = chat.chatDisplay[chat.chatDisplay.length - 1];
        if (lastMsg.type === 'emoji') {
          chat.lastMessage = '[表情包]';
        } else if (lastMsg.type === 'location') {
          chat.lastMessage = '[位置]';
        } else if (lastMsg.type === 'transfer') {
          chat.lastMessage = '[转账]';
        } else if (lastMsg.type === 'chatRecord') {
          chat.lastMessage = '[聊天记录]';
        } else if (lastMsg.type === 'forward') {
          chat.lastMessage = '[转发消息]';
        } else if (lastMsg.type === 'image') {
          chat.lastMessage = '[图片]';
        } else if (lastMsg.type === 'pat') {
          chat.lastMessage = '[拍一拍]';
        } else {
          chat.lastMessage = lastMsg.content.length > 30 
            ? lastMsg.content.substring(0, 30) + '...' 
            : lastMsg.content;
        }
        chat.lastTime = getCurrentTime();
      }
      
      // 更新聊天名称（如果有角色名）
      if (roleName && chat.name === '新聊天') {
        chat.name = `与${roleName}聊天`;
      }
      
      saveChatList();
      
      // 更新重新生成按钮状态
      updateRegenerateButtons();
    }

    // 显示聊天列表
    function showChatList() {
      chatListView.classList.add('active');
      chatView.classList.remove('active');
      momentsView.classList.remove('active');
      renderChatList();
      
      // 清除拍一拍计时器
      if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
      }
    }

    // 显示聊天界面
    function showChatView() {
      chatListView.classList.remove('active');
      chatView.classList.add('active');
      momentsView.classList.remove('active');
      
      // 重置拍一拍计时器
      if (typeof resetActivityTimer === 'function') {
        resetActivityTimer();
      }
    }

    // 渲染聊天列表
    function renderChatList() {
      if (chatList.length === 0) {
        emptyChatList.style.display = 'block';
        chatListBody.innerHTML = '';
        return;
      }
      
      emptyChatList.style.display = 'none';
      
      chatListBody.innerHTML = chatList.map(chat => {
        // 获取显示标题：优先使用自定义标题，否则使用默认标题
        const displayTitle = chat.customTitle || getDisplayTitle(chat);
        
        return `
          <div class="chat-item" onclick="openChat('${chat.id}')">
            <img class="chat-item-avatar" src="${chat.aiAvatar || DEFAULT_AI_AVATAR}" alt="头像" onerror="this.src='${DEFAULT_AI_AVATAR}'">
            <div class="chat-item-content">
              <div class="chat-item-header">
                <div class="chat-item-name">
                  ${displayTitle}
                  ${chat.type === 'group' ? '<span class="group-chat-indicator">群聊</span>' : ''}
                </div>
                <div class="chat-item-time">${formatTime(chat.lastTime)}</div>
              </div>
              <div class="chat-item-preview">${chat.lastMessage || '开始新的对话...'}</div>
            </div>
            <div class="chat-item-actions">
              <button class="chat-item-btn delete" data-chat-id="${chat.id}">删除</button>
            </div>
          </div>
        `;
      }).join('');
      
      // 为删除按钮添加事件监听器
      chatListBody.querySelectorAll('.chat-item-btn.delete').forEach(btn => {
        btn.addEventListener('click', function(e) {
          e.stopPropagation(); // 阻止事件冒泡
          const chatId = this.getAttribute('data-chat-id');
          deleteChat(chatId);
        });
      });
    }

    // 保存聊天列表
    function saveChatList() {
      localStorage.setItem('aiChatList', JSON.stringify(chatList));
    }

    // 加载聊天列表
    function loadChatList() {
      const saved = localStorage.getItem('aiChatList');
      if (saved) {
        try {
          chatList = JSON.parse(saved);
          // 兼容旧版本数据，为旧聊天添加必要字段
          chatList.forEach(chat => {
            if (!chat.type) {
              chat.type = 'single'; // 默认为单聊
            }
            if (!chat.roles) {
              chat.roles = []; // 初始化角色列表
            }
            if (!chat.groupSettings) {
              chat.groupSettings = {
                maxRolesPerReply: 3,
                replyDelay: 1000
              };
            }
          });
        } catch (e) {
          chatList = [];
        }
      }
    }

    // 初始化
    function init() {
      loadSettings();
      loadChatList();
      loadCustomPresets(); // 加载自定义预设
      loadLocationData(); // 加载位置数据
      loadTransferData(); // 加载转账数据
      renderChatList();
      updateStatus();
      updateSendButton();
      
      // 初始化对话历史
      window.conversationHistory = [];
    }

    // 加载保存的设置
    function loadSettings() {
      // 加载API配置
      loadApiConfigs();
      
      // 加载当前使用的API配置
      currentApiConfigId = localStorage.getItem('currentApiConfigId');
      if (currentApiConfigId && savedApiConfigs[currentApiConfigId]) {
        const currentConfig = savedApiConfigs[currentApiConfigId];
        apiURL = currentConfig.url;
        apiKey = currentConfig.key;
        selectedModel = currentConfig.model || '';
        availableModels = currentConfig.models || [];
        
        // 加载识图API配置
        visionApiURL = currentConfig.visionUrl || '';
        visionApiKey = currentConfig.visionKey || '';
        selectedVisionModel = currentConfig.visionModel || '';
        availableVisionModels = currentConfig.visionModels || [];
      } else {
        // 兼容旧版本，加载旧的单个API配置
        apiURL = localStorage.getItem('aiChatApiUrl') || '';
        apiKey = localStorage.getItem('aiChatApiKey') || '';
        selectedModel = localStorage.getItem('aiChatModel') || '';
      }
      
      // 加载表情包数据
      const savedEmojis = localStorage.getItem('aiChatEmojis');
      if (savedEmojis) {
        try {
          emojiData = JSON.parse(savedEmojis);
          // 检查数据完整性，如果数据为空或不完整，使用默认数据
          if (!emojiData || Object.keys(emojiData).length === 0) {
            emojiData = JSON.parse(JSON.stringify(DEFAULT_EMOJIS));
            localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
          }
        } catch (e) {
          console.error('解析表情包数据失败，使用默认数据:', e);
          emojiData = JSON.parse(JSON.stringify(DEFAULT_EMOJIS));
          localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
        }
      } else {
        emojiData = JSON.parse(JSON.stringify(DEFAULT_EMOJIS));
        localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
      }
      
      // 加载AI设置
      const savedContextLength = localStorage.getItem('aiContextLength');
      if (savedContextLength) {
        aiContextLength = parseInt(savedContextLength);
        if (isNaN(aiContextLength) || aiContextLength < 1 || aiContextLength > 50) {
          aiContextLength = 10; // 默认值
        }
      }
      
      const savedResponseDelay = localStorage.getItem('aiResponseDelay');
      if (savedResponseDelay) {
        aiResponseDelay = parseInt(savedResponseDelay);
        if (isNaN(aiResponseDelay) || aiResponseDelay < 0 || aiResponseDelay > 60) {
          aiResponseDelay = 0; // 默认值
        }
      }
      
      // 加载预设提示词
      const savedCustomPrompt = localStorage.getItem('aiCustomPrompt');
      if (savedCustomPrompt) {
        aiCustomPrompt = savedCustomPrompt;
        console.log('🔧 加载预设提示词成功，长度:', aiCustomPrompt.length);
        console.log('🔧 预设提示词内容:', aiCustomPrompt.substring(0, 100) + (aiCustomPrompt.length > 100 ? '...' : ''));
      } else {
        console.log('🔧 未找到保存的预设提示词');
      }
      
      // 加载自定义字体
      loadCustomFonts();
      
      // 更新界面显示
      updateApiSettingsUI();
      
      // 加载保存的模型列表（兼容旧版本）
      if (!currentApiConfigId) {
        const savedModels = localStorage.getItem('aiChatModels');
        if (savedModels) {
          availableModels = JSON.parse(savedModels);
        }
      }
      
      updateModelSelect();
      updateVisionModelSelect();
      updateChatHeader();
    }

    // 保存API设置
    function saveSettings() {
      // 获取新的设置值
      apiURL = apiUrlInput.value.trim();
      apiKey = apiKeyInput.value.trim();
      selectedModel = modelSelect.value;
      
      // 保存API设置到localStorage
      localStorage.setItem('aiChatApiUrl', apiURL);
      localStorage.setItem('aiChatApiKey', apiKey);
      localStorage.setItem('aiChatModel', selectedModel);
      localStorage.setItem('aiChatModels', JSON.stringify(availableModels));
      
      updateStatus();
      updateSendButton();
      settingsPanel.classList.remove('show');
      showTestResult('API设置已保存！', 'success');
    }

    // API配置管理函数
    
    // 加载API配置
    function loadApiConfigs() {
      const saved = localStorage.getItem('savedApiConfigs');
      if (saved) {
        try {
          savedApiConfigs = JSON.parse(saved);
        } catch (e) {
          console.error('加载API配置失败:', e);
          savedApiConfigs = {};
        }
      }
      updateSavedApiSelect();
    }
    
    // 保存API配置到localStorage
    function saveApiConfigs() {
      localStorage.setItem('savedApiConfigs', JSON.stringify(savedApiConfigs));
    }
    
    // 更新API设置界面
    function updateApiSettingsUI() {
      apiUrlInput.value = apiURL;
      apiKeyInput.value = apiKey;
      
      // 更新识图API界面
      visionApiUrlInput.value = visionApiURL;
      visionApiKeyInput.value = visionApiKey;
      
      // 更新配置名称输入框
      if (currentApiConfigId && savedApiConfigs[currentApiConfigId]) {
        apiConfigNameInput.value = savedApiConfigs[currentApiConfigId].name;
        savedApiSelect.value = currentApiConfigId;
      } else {
        apiConfigNameInput.value = '';
        savedApiSelect.value = '';
      }
      
      updateSavedApiSelect();
      updateApiConfigButtons();
    }
    
    // 更新已保存API选择框
    function updateSavedApiSelect() {
      savedApiSelect.innerHTML = '<option value="">选择已保存的API配置...</option>';
      
      Object.keys(savedApiConfigs).forEach(configId => {
        const config = savedApiConfigs[configId];
        const option = document.createElement('option');
        option.value = configId;
        option.textContent = config.name;
        if (configId === currentApiConfigId) {
          option.selected = true;
        }
        savedApiSelect.appendChild(option);
      });
    }
    
    // 更新API配置按钮状态
    function updateApiConfigButtons() {
      const hasCurrentConfig = currentApiConfigId && savedApiConfigs[currentApiConfigId];
      const hasConfigName = apiConfigNameInput.value.trim() !== '';
      
      loadApiBtn.disabled = !savedApiSelect.value;
      deleteApiBtn.disabled = !savedApiSelect.value;
      updateCurrentBtn.disabled = !hasCurrentConfig || !hasConfigName;
      saveAsNewBtn.disabled = !hasConfigName;
    }
    
    // 生成唯一ID
    function generateConfigId() {
      return 'config_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    // 保存为新配置
    function saveAsNewApiConfig() {
      const name = apiConfigNameInput.value.trim();
      const url = apiUrlInput.value.trim();
      const key = apiKeyInput.value.trim();
      
      if (!name) {
        alert('请输入配置名称！');
        return;
      }
      
      if (!url || !key) {
        alert('请输入API地址和密钥！');
        return;
      }
      
      // 检查名称是否已存在
      const existingId = Object.keys(savedApiConfigs).find(id => 
        savedApiConfigs[id].name === name
      );
      
      if (existingId) {
        if (!confirm(`配置名称"${name}"已存在，是否覆盖？`)) {
          return;
        }
        // 删除旧配置
        delete savedApiConfigs[existingId];
      }
      
      // 创建新配置
      const configId = generateConfigId();
      savedApiConfigs[configId] = {
        name: name,
        url: url,
        key: key,
        model: selectedModel,
        models: [...availableModels],
        // 识图API配置
        visionUrl: visionApiURL,
        visionKey: visionApiKey,
        visionModel: selectedVisionModel,
        visionModels: [...availableVisionModels],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      // 设置为当前配置
      currentApiConfigId = configId;
      localStorage.setItem('currentApiConfigId', currentApiConfigId);
      
      // 保存配置
      saveApiConfigs();
      updateApiSettingsUI();
      
      showTestResult(`API配置"${name}"已保存！`, 'success');
    }
    
    // 更新当前配置
    function updateCurrentApiConfig() {
      if (!currentApiConfigId || !savedApiConfigs[currentApiConfigId]) {
        alert('没有选中的配置可以更新！');
        return;
      }
      
      const name = apiConfigNameInput.value.trim();
      const url = apiUrlInput.value.trim();
      const key = apiKeyInput.value.trim();
      
      if (!name) {
        alert('请输入配置名称！');
        return;
      }
      
      if (!url || !key) {
        alert('请输入API地址和密钥！');
        return;
      }
      
      // 检查名称冲突（排除当前配置）
      const existingId = Object.keys(savedApiConfigs).find(id => 
        id !== currentApiConfigId && savedApiConfigs[id].name === name
      );
      
      if (existingId) {
        alert(`配置名称"${name}"已被其他配置使用，请选择其他名称！`);
        return;
      }
      
      // 更新配置
      savedApiConfigs[currentApiConfigId].name = name;
      savedApiConfigs[currentApiConfigId].url = url;
      savedApiConfigs[currentApiConfigId].key = key;
      savedApiConfigs[currentApiConfigId].model = selectedModel;
      savedApiConfigs[currentApiConfigId].models = [...availableModels];
      // 更新识图API配置
      savedApiConfigs[currentApiConfigId].visionUrl = visionApiURL;
      savedApiConfigs[currentApiConfigId].visionKey = visionApiKey;
      savedApiConfigs[currentApiConfigId].visionModel = selectedVisionModel;
      savedApiConfigs[currentApiConfigId].visionModels = [...availableVisionModels];
      savedApiConfigs[currentApiConfigId].updatedAt = new Date().toISOString();
      
      // 更新全局变量
      apiURL = url;
      apiKey = key;
      
      // 保存配置
      saveApiConfigs();
      updateApiSettingsUI();
      
      showTestResult(`API配置"${name}"已更新！`, 'success');
    }
    
    // 加载选中的API配置
    function loadSelectedApiConfig() {
      const configId = savedApiSelect.value;
      if (!configId || !savedApiConfigs[configId]) {
        alert('请选择一个有效的API配置！');
        return;
      }
      
      const config = savedApiConfigs[configId];
      
      // 更新界面
      apiUrlInput.value = config.url;
      apiKeyInput.value = config.key;
      apiConfigNameInput.value = config.name;
      
      // 更新识图API界面
      visionApiUrlInput.value = config.visionUrl || '';
      visionApiKeyInput.value = config.visionKey || '';
      
      // 更新全局变量
      apiURL = config.url;
      apiKey = config.key;
      selectedModel = config.model || '';
      availableModels = config.models || [];
      
      // 更新识图API全局变量
      visionApiURL = config.visionUrl || '';
      visionApiKey = config.visionKey || '';
      selectedVisionModel = config.visionModel || '';
      availableVisionModels = config.visionModels || [];
      
      // 设置为当前配置
      currentApiConfigId = configId;
      localStorage.setItem('currentApiConfigId', currentApiConfigId);
      
      // 更新模型选择框
      updateModelSelect();
      updateVisionModelSelect();
      updateApiConfigButtons();
      
      showTestResult(`已加载API配置"${config.name}"！`, 'success');
    }
    
    // 删除选中的API配置
    function deleteSelectedApiConfig() {
      const configId = savedApiSelect.value;
      if (!configId || !savedApiConfigs[configId]) {
        alert('请选择一个有效的API配置！');
        return;
      }
      
      const config = savedApiConfigs[configId];
      
      if (!confirm(`确定要删除API配置"${config.name}"吗？此操作不可撤销！`)) {
        return;
      }
      
      // 删除配置
      delete savedApiConfigs[configId];
      
      // 如果删除的是当前配置，清除当前配置
      if (currentApiConfigId === configId) {
        currentApiConfigId = null;
        localStorage.removeItem('currentApiConfigId');
        
        // 清空界面
        apiUrlInput.value = '';
        apiKeyInput.value = '';
        apiConfigNameInput.value = '';
        modelSelect.innerHTML = '<option value="">请先测试连接以获取可用模型</option>';
        
        // 清空全局变量
        apiURL = '';
        apiKey = '';
        selectedModel = '';
        availableModels = [];
      }
      
      // 保存配置
      saveApiConfigs();
      updateApiSettingsUI();
      
      showTestResult(`API配置"${config.name}"已删除！`, 'success');
    }
    
    // 新建API配置
    function newApiConfig() {
      // 清空所有输入框
      apiUrlInput.value = '';
      apiKeyInput.value = '';
      apiConfigNameInput.value = '';
      savedApiSelect.value = '';
      modelSelect.innerHTML = '<option value="">请先测试连接以获取可用模型</option>';
      
      // 清空识图API输入框
      visionApiUrlInput.value = '';
      visionApiKeyInput.value = '';
      visionModelSelect.innerHTML = '<option value="">请先测试识图连接以获取可用模型</option>';
      
      // 清空全局变量
      apiURL = '';
      apiKey = '';
      selectedModel = '';
      availableModels = [];
      
      // 清空识图API全局变量
      visionApiURL = '';
      visionApiKey = '';
      selectedVisionModel = '';
      availableVisionModels = [];
      
      currentApiConfigId = null;
      
      localStorage.removeItem('currentApiConfigId');
      updateApiConfigButtons();
      
      // 聚焦到配置名称输入框
      apiConfigNameInput.focus();
      
      showTestResult('请配置新的API信息', 'info');
    }

    // 保存角色设置
    function saveRoleSettings() {
      // 获取新的角色设置值
      roleName = roleNameInput.value.trim();
      roleDescription = roleDescInput.value.trim();
      aiAvatar = aiAvatarInput.value.trim() || DEFAULT_AI_AVATAR;
      
      // 保存视频通话画面设置
      const aiVideo = document.getElementById('aiVideoInput').value.trim() || aiAvatar;
      if (currentChatId) {
        const chat = chatList.find(c => c.id === currentChatId);
        if (chat && chat.type === 'single') {
          chat.aiVideo = aiVideo;
        }
      }
      
      // 保存群聊设置
      if (currentChatId) {
        const chat = chatList.find(c => c.id === currentChatId);
        if (chat && chat.type === 'group') {
          const maxRolesSelect = document.getElementById('maxRolesPerReplySelect');
          if (maxRolesSelect) {
            if (!chat.groupSettings) {
              chat.groupSettings = { replyDelay: 1000 };
            }
            chat.groupSettings.maxRolesPerReply = parseInt(maxRolesSelect.value);
            console.log(`保存群聊设置: 最大回复角色数=${chat.groupSettings.maxRolesPerReply}`);
          }
        }
      }
      
      // 保存当前聊天数据
      saveCurrentChatData();
      
      updateChatHeader();
      rolePanel.classList.remove('show');
      showTestResult('角色设定已保存！', 'success');
    }

    // 保存用户设置
    function saveUserSettings() {
      // 获取新的用户设置值
      userName = userNameInput.value.trim();
      userDescription = userDescInput.value.trim();
      userAvatar = userAvatarInput.value.trim() || DEFAULT_USER_AVATAR;
      
      // 保存当前聊天数据
      saveCurrentChatData();
      
      updateChatHeader();
      userPanel.classList.remove('show');
      showTestResult('用户设定已保存！', 'success');
    }

    // 获取API诊断建议
    function getDiagnosticSuggestion(url) {
      try {
        const hostname = new URL(url).hostname;
        
        if (hostname.includes('xcapi.top')) {
          return `这是xcapi.top API服务。常见问题解决方案：
          <br>1. <strong>CORS跨域问题</strong>：该API不支持浏览器直接访问，需要通过代理
          <br>2. <strong>推荐替代方案</strong>：使用支持CORS的API服务（如DeepSeek API）
          <br>3. <strong>临时解决</strong>：使用"💬 直接测试聊天"按钮尝试连接
          <br>4. <strong>技术方案</strong>：设置本地代理服务器或使用桌面版AI客户端`;
        } else if (hostname.includes('glamoth.ar26710.online')) {
          return '请检查此API服务是否可用，或尝试联系服务提供商。';
        } else if (hostname.includes('ai.nyabit.com')) {
          return '请确认API密钥是否正确，或检查此服务的状态。';
        } else if (hostname.includes('api.openai.com')) {
          return '请检查OpenAI API密钥和网络连接。';
        } else if (hostname.includes('api.siliconflow.cn')) {
          return `这是硅基流动API服务。常见问题解决方案：
          <br>1. <strong>API密钥格式</strong>：确认密钥格式正确（通常以sk-开头）
          <br>2. <strong>网络连接</strong>：检查网络连接是否正常
          <br>3. <strong>API端点</strong>：确认使用正确的端点 https://api.siliconflow.cn/v1
          <br>4. <strong>余额检查</strong>：登录硅基流动官网检查账户余额
          <br>5. <strong>模型权限</strong>：确认API密钥有权限访问所选模型
          <br>6. <strong>实名认证</strong>：部分模型需要完成实名认证才能使用`;
        } else if (hostname.includes('generativelanguage.googleapis.com')) {
          return `请检查Google API密钥格式是否正确（AIza...开头）。
          <br><strong>如果连接失败，可以尝试：</strong>
          <br>1. 使用代理API地址：https://generativelanguage.googleapis.com
          <br>2. 或者使用第三方代理：https://api.aihao123.cn/luomacode-api/open-ai/google/v1beta
          <br>3. 检查网络连接和防火墙设置
          <br>4. 确认API密钥已启用Generative Language API服务`;
        } else {
          return '请检查API地址、密钥是否正确，或尝试使用其他API服务。';
        }
      } catch (e) {
        return '请检查API配置是否正确。';
      }
    }

    // 硅基流动API端点列表
    const SILICONFLOW_API_ENDPOINTS = [
      'https://api.siliconflow.cn',
      'https://api-st.siliconflow.cn'
    ];

    // 检测并获取可用的硅基流动API端点
    async function getWorkingSiliconflowEndpoint(originalUrl, apiKey) {
      if (!originalUrl.includes('siliconflow.cn')) {
        return originalUrl;
      }
      
      console.log('🔍 检测可用的硅基流动API端点...');
      
      for (const endpoint of SILICONFLOW_API_ENDPOINTS) {
        try {
          // 替换端点域名，保持原有路径
          const testUrl = originalUrl.replace(/https:\/\/[^\/]+/, endpoint);
          console.log(`🧪 测试端点: ${endpoint}`);
          
          // 快速连接测试
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          
          const response = await fetch(testUrl, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            },
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (response.status === 200 || response.status === 401 || response.status === 403) {
            console.log(`✅ 找到可用端点: ${endpoint}`);
            return testUrl;
          }
        } catch (error) {
          console.log(`❌ 端点不可用: ${endpoint} - ${error.message}`);
          continue;
        }
      }
      
      console.log('⚠️ 所有硅基流动端点都不可用，使用原始端点');
      return originalUrl;
    }

    // 硅基流动API连接助手
    function showSiliconflowApiHelper() {
      const modal = document.createElement('div');
      modal.className = 'siliconflow-api-helper-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
      `;
      
      modal.innerHTML = `
        <div style="background: white; border-radius: 12px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; padding: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="margin: 0; color: #2ecc71;">🚀 硅基流动 API 连接助手</h2>
            <button onclick="this.closest('.siliconflow-api-helper-modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">×</button>
          </div>
          
          <div style="margin-bottom: 20px;">
            <h3 style="color: #333; margin-bottom: 10px;">📋 快速配置</h3>
            <div style="display: grid; gap: 10px;">
              <button class="helper-btn" onclick="setSiliconflowApiConfig('official')" style="padding: 12px; background: #2ecc71; color: white; border: none; border-radius: 8px; cursor: pointer;">
                🏢 官方端点 (推荐)
              </button>
              <button class="helper-btn" onclick="setSiliconflowApiConfig('international')" style="padding: 12px; background: #3498db; color: white; border: none; border-radius: 8px; cursor: pointer;">
                🌍 国际端点 (海外用户)
              </button>
            </div>
          </div>
          
          <div style="margin-bottom: 20px;">
            <h3 style="color: #333; margin-bottom: 10px;">🔧 连接测试</h3>
            <button id="testSiliconflowConnection" style="padding: 12px 20px; background: #e67e22; color: white; border: none; border-radius: 8px; cursor: pointer; width: 100%;">
              🧪 测试硅基流动API连接
            </button>
            <div id="siliconflowTestResults" style="margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 8px; min-height: 50px; font-family: monospace; font-size: 12px;">
              点击上方按钮开始测试...
            </div>
          </div>
          
          <div style="margin-bottom: 20px;">
            <h3 style="color: #333; margin-bottom: 10px;">💡 常见问题解决</h3>
            <div style="font-size: 14px; line-height: 1.6; color: #666;">
              <div style="margin-bottom: 10px;">
                <strong>1. API密钥获取：</strong><br>
                • 访问 <a href="https://cloud.siliconflow.cn" target="_blank">硅基流动官网</a> 注册账号<br>
                • 在控制台生成API密钥（通常以sk-开头）<br>
                • 确保账户有足够余额
              </div>
                             <div style="margin-bottom: 10px;">
                 <strong>2. 连接问题：</strong><br>
                 • 检查网络连接是否正常<br>
                 • 确认API端点地址正确<br>
                 • 海外用户可尝试国际端点
               </div>
               <div style="margin-bottom: 10px;">
                 <strong>3. 400错误专项解决：</strong><br>
                 • 模型名称错误（常见原因）<br>
                 • 请求参数格式不正确<br>
                 • 模型需要特殊权限或付费<br>
                 • 推荐使用免费模型：Qwen/Qwen2.5-7B-Instruct
               </div>
                             <div style="margin-bottom: 10px;">
                 <strong>4. 权限问题：</strong><br>
                 • 完成实名认证（部分模型需要）<br>
                 • 确认API密钥有权限访问所选模型<br>
                 • 检查账户余额是否充足
               </div>
               <div style="margin-bottom: 10px;">
                 <strong>5. 模型选择：</strong><br>
                • 推荐使用免费模型进行测试<br>
                • 常用模型：Qwen2.5-7B-Instruct、DeepSeek-V3等<br>
                • 查看 <a href="https://docs.siliconflow.cn" target="_blank">官方文档</a> 了解更多
              </div>
            </div>
          </div>
          
          <div style="text-align: center;">
            <button onclick="this.closest('.siliconflow-api-helper-modal').remove()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer;">
              关闭助手
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // 设置配置函数
      window.setSiliconflowApiConfig = function(type) {
        const apiUrlInput = document.getElementById('apiUrlInput');
        switch (type) {
          case 'official':
            apiUrlInput.value = 'https://api.siliconflow.cn/v1';
            break;
          case 'international':
            apiUrlInput.value = 'https://api-st.siliconflow.cn/v1';
            break;
        }
        alert(`已设置API地址为: ${apiUrlInput.value}`);
      };
      
      // 测试连接函数
      document.getElementById('testSiliconflowConnection').onclick = async function() {
        const testResults = document.getElementById('siliconflowTestResults');
        const apiKey = document.getElementById('apiKeyInput').value.trim();
        
        if (!apiKey) {
          testResults.innerHTML = '<span style="color: #e74c3c;">❌ 请先填写API密钥</span>';
          return;
        }
        
        testResults.innerHTML = '<span style="color: #3498db;">🔄 正在测试硅基流动API连接...</span>';
        
        const endpoints = [
          { name: '国内端点', url: 'https://api.siliconflow.cn/v1' },
          { name: '国际端点', url: 'https://api-st.siliconflow.cn/v1' }
        ];
        
        let results = [];
        
        for (const endpoint of endpoints) {
          try {
            // 先测试模型列表
            const modelsUrl = `${endpoint.url}/models`;
            
            const controller = new AbortController();
            setTimeout(() => controller.abort(), 8000);
            
            const modelsResponse = await fetch(modelsUrl, {
              method: 'GET',
              headers: {
                'Authorization': 'Bearer ' + apiKey,
                'Content-Type': 'application/json'
              },
              signal: controller.signal
            });
            
            if (modelsResponse.status === 200) {
              const data = await modelsResponse.json();
              const modelCount = data.data ? data.data.length : 0;
              
              // 测试聊天功能
              const chatUrl = `${endpoint.url}/chat/completions`;
              const testModel = 'Qwen/Qwen2.5-7B-Instruct'; // 使用免费模型测试
              
              const chatController = new AbortController();
              setTimeout(() => chatController.abort(), 8000);
              
              const chatResponse = await fetch(chatUrl, {
                method: 'POST',
                headers: {
                  'Authorization': 'Bearer ' + apiKey,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  model: testModel,
                  messages: [{ role: 'user', content: 'hi' }],
                  max_tokens: 5
                }),
                signal: chatController.signal
              });
              
              if (chatResponse.status === 200) {
                results.push(`<span style="color: #27ae60;">✅ ${endpoint.name}: 完全正常 (${modelCount}个模型，聊天测试通过)</span>`);
              } else if (chatResponse.status === 400) {
                results.push(`<span style="color: #f39c12;">⚠️ ${endpoint.name}: 模型列表正常，但聊天测试400错误 (可能是模型权限问题)</span>`);
              } else {
                results.push(`<span style="color: #f39c12;">⚠️ ${endpoint.name}: 模型列表正常 (${modelCount}个)，聊天测试HTTP ${chatResponse.status}</span>`);
              }
            } else if (modelsResponse.status === 401) {
              results.push(`<span style="color: #e74c3c;">❌ ${endpoint.name}: API密钥无效</span>`);
            } else if (modelsResponse.status === 403) {
              results.push(`<span style="color: #f39c12;">⚠️ ${endpoint.name}: 权限不足，可能需要实名认证</span>`);
            } else {
              results.push(`<span style="color: #e74c3c;">❌ ${endpoint.name}: HTTP ${modelsResponse.status}</span>`);
            }
          } catch (error) {
            if (error.name === 'AbortError') {
              results.push(`<span style="color: #e74c3c;">❌ ${endpoint.name}: 连接超时</span>`);
            } else {
              results.push(`<span style="color: #e74c3c;">❌ ${endpoint.name}: ${error.message}</span>`);
            }
          }
        }
        
        testResults.innerHTML = results.join('<br>');
      };
      
      // 点击背景关闭
      modal.onclick = function(e) {
        if (e.target === modal) {
          modal.remove();
        }
      };
    }

    // 带重试和超时的增强fetch函数
    async function fetchWithRetry(url, options = {}, retries = 3) {
      const timeout = options.timeout || 10000;
      const originalHeaders = options.headers || {};
      
      // 如果是硅基流动API，尝试检测最佳端点
      if (url.includes('api.siliconflow.cn') || url.includes('api-st.siliconflow.cn')) {
        try {
          url = await getWorkingSiliconflowEndpoint(url, options.headers?.Authorization);
        } catch (error) {
          console.warn('无法检测硅基流动API端点，使用原始URL:', error);
        }
      }
      
      // 为第三方API添加更多兼容性头
      const enhancedHeaders = {
        ...originalHeaders,
        'User-Agent': 'Mozilla/5.0 (compatible; AI-Chat-Client/1.0)',
        'Accept': 'application/json, text/plain, */*',
        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache'
      };
      
      // 移除timeout属性，避免传递给fetch
      const fetchOptions = {
        ...options,
        headers: enhancedHeaders
      };
      delete fetchOptions.timeout;
      
      for (let i = 0; i < retries; i++) {
        try {
          console.log(`🔄 尝试连接 ${url} (第${i + 1}次)`);
          
          // 创建带超时的fetch请求
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, {
            ...fetchOptions,
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (response.ok) {
            console.log(`✅ 连接成功: ${url}`);
            return response;
          } else {
            console.log(`❌ HTTP错误 ${response.status}: ${url}`);
            if (i === retries - 1) return response; // 最后一次重试，返回响应以便显示错误
          }
        } catch (error) {
          console.log(`❌ 连接失败 (第${i + 1}次): ${error.message}`);
          
          if (error.name === 'AbortError') {
            console.log(`⏰ 连接超时 (${timeout}ms): ${url}`);
          }
          
          if (i === retries - 1) {
            // 最后一次重试，抛出增强的错误信息
                           if (error.name === 'AbortError') {
               throw new Error(`连接超时 (${timeout}ms)。${getDiagnosticSuggestion(url)}`);
             } else if (error.message.includes('CORS')) {
               const hostname = new URL(url).hostname;
               if (hostname.includes('xcapi.top')) {
                 throw new Error(`跨域请求被阻止。xcapi.top 不支持浏览器直接访问。建议：1) 使用支持CORS的API服务 2) 通过代理服务器访问 3) 使用桌面版AI客户端`);
               } else {
                 throw new Error(`跨域请求被阻止。该API可能不支持浏览器直接访问，请尝试其他API服务。`);
               }
             } else if (error.message.includes('Failed to fetch')) {
             } else if (error.message.includes('Failed to fetch')) {
               throw new Error(`网络连接失败。${getDiagnosticSuggestion(url)}`);
             } else {
               throw error;
             }
          }
          
          // 等待1秒后重试
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }

    // 获取API基础URL（用于获取模型列表）
    function getApiBaseUrl(chatUrl) {
      try {
        const url = new URL(chatUrl);
        // 对于DeepSeek API，基础URL就是去掉路径部分
        // 例如：https://api.deepseek.com/v1 -> https://api.deepseek.com
        if (url.hostname === 'api.deepseek.com') {
          return `${url.origin}`;
        } else if (url.hostname === 'api.siliconflow.cn' || url.hostname === 'api-st.siliconflow.cn') {
          // 硅基流动API，保持v1路径
          // 例如：https://api.siliconflow.cn/v1/chat/completions -> https://api.siliconflow.cn/v1
          return chatUrl.includes('/v1') ? chatUrl.replace(/\/chat\/completions$/, '') : `${url.origin}/v1`;
        }
        // 其他API提供商的处理
        const pathParts = url.pathname.split('/');
        // 移除最后的chat/completions部分，保留基础路径
        const basePath = pathParts.slice(0, -2).join('/');
        return `${url.origin}${basePath}`;
      } catch (e) {
        return null;
      }
    }

    // 测试识图API连接
    async function testVisionConnection() {
      const url = visionApiUrlInput.value.trim();
      const key = visionApiKeyInput.value.trim();
      
      if (!url || !key) {
        showTestResult('请先填写识图API地址和密钥！', 'error');
        return;
      }
      
      testVisionBtn.disabled = true;
      testVisionBtn.textContent = '测试中...';
      showTestResult('正在测试识图API连接...', 'info');
      
      try {
        const response = await fetch(`${url}/models`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${key}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.data && Array.isArray(data.data)) {
          // 过滤出支持视觉的模型
          const visionModels = data.data.filter(model => {
            const modelId = model.id.toLowerCase();
            return modelId.includes('vision') || 
                   modelId.includes('gpt-4') || 
                   modelId.includes('claude') ||
                   modelId.includes('gemini') ||
                   modelId.includes('qwen-vl') ||
                   modelId.includes('qwen2-vl') ||
                   modelId.includes('internvl') ||
                   modelId.includes('llava') ||
                   modelId.includes('minicpm') ||
                   modelId.includes('yi-vision') ||
                   modelId.includes('cogvlm') ||
                   modelId.includes('blip') ||
                   modelId.includes('flamingo') ||
                   modelId.includes('kosmos') ||
                   modelId.includes('pix2struct') ||
                   modelId.includes('instructblip') ||
                   // 通用视觉模型关键词
                   modelId.includes('-v') ||
                   modelId.includes('visual') ||
                   modelId.includes('multimodal');
          });
          
          // 如果没有找到明确的视觉模型，显示所有模型并添加提示
          if (visionModels.length === 0) {
            console.log('未找到明确的视觉模型，显示所有模型供用户选择');
            availableVisionModels = data.data.map(model => model.id);
            updateVisionModelSelect();
            
            // 更新全局变量
            visionApiURL = url;
            visionApiKey = key;
            
            showTestResult(`识图API连接成功！找到 ${data.data.length} 个模型。请手动选择支持视觉识别的模型。`, 'warning');
          } else {
            availableVisionModels = visionModels.map(model => model.id);
            updateVisionModelSelect();
            
            // 更新全局变量
            visionApiURL = url;
            visionApiKey = key;
            
            showTestResult(`识图API连接成功！找到 ${visionModels.length} 个支持视觉的模型。`, 'success');
          }
        } else {
          showTestResult('识图API连接成功，但返回的模型数据格式不正确！', 'warning');
        }
      } catch (error) {
        console.error('识图API连接测试失败:', error);
        showTestResult(`识图API连接失败: ${error.message}`, 'error');
      } finally {
        testVisionBtn.disabled = false;
        testVisionBtn.textContent = '测试识图连接';
      }
    }
    
    // 刷新识图模型列表
    async function refreshVisionModels() {
      if (!visionApiURL || !visionApiKey) {
        showTestResult('请先测试识图API连接！', 'error');
        return;
      }
      
      refreshVisionModelsBtn.disabled = true;
      refreshVisionModelsBtn.textContent = '刷新中...';
      showTestResult('正在刷新识图模型列表...', 'info');
      
      try {
        const response = await fetch(`${visionApiURL}/models`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${visionApiKey}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.data && Array.isArray(data.data)) {
          // 过滤出支持视觉的模型
          const visionModels = data.data.filter(model => {
            const modelId = model.id.toLowerCase();
            return modelId.includes('vision') || 
                   modelId.includes('gpt-4') || 
                   modelId.includes('claude') ||
                   modelId.includes('gemini') ||
                   modelId.includes('qwen-vl') ||
                   modelId.includes('qwen2-vl') ||
                   modelId.includes('internvl') ||
                   modelId.includes('llava') ||
                   modelId.includes('minicpm') ||
                   modelId.includes('yi-vision') ||
                   modelId.includes('cogvlm') ||
                   modelId.includes('blip') ||
                   modelId.includes('flamingo') ||
                   modelId.includes('kosmos') ||
                   modelId.includes('pix2struct') ||
                   modelId.includes('instructblip') ||
                   // 通用视觉模型关键词
                   modelId.includes('-v') ||
                   modelId.includes('visual') ||
                   modelId.includes('multimodal');
          });
          
          // 如果没有找到明确的视觉模型，显示所有模型并添加提示
          if (visionModels.length === 0) {
            console.log('未找到明确的视觉模型，显示所有模型供用户选择');
            availableVisionModels = data.data.map(model => model.id);
            updateVisionModelSelect();
            showTestResult(`识图模型列表刷新成功！找到 ${data.data.length} 个模型。请手动选择支持视觉识别的模型。`, 'warning');
          } else {
            availableVisionModels = visionModels.map(model => model.id);
            updateVisionModelSelect();
            showTestResult(`识图模型列表刷新成功！找到 ${visionModels.length} 个支持视觉的模型。`, 'success');
          }
        } else {
          showTestResult('识图模型列表刷新失败：返回数据格式不正确！', 'error');
        }
      } catch (error) {
        console.error('刷新识图模型失败:', error);
        showTestResult(`刷新识图模型失败: ${error.message}`, 'error');
      } finally {
        refreshVisionModelsBtn.disabled = false;
        refreshVisionModelsBtn.textContent = '刷新识图模型';
      }
    }
    
    // 更新识图模型选择框
    function updateVisionModelSelect() {
      visionModelSelect.innerHTML = '<option value="">请选择识图模型</option>';
      
      availableVisionModels.forEach(model => {
        const option = document.createElement('option');
        option.value = model;
        option.textContent = model;
        if (model === selectedVisionModel) {
          option.selected = true;
        }
        visionModelSelect.appendChild(option);
      });
    }
    
    // 调试识图模型列表
    async function debugVisionModels() {
      const url = visionApiUrlInput.value.trim();
      const key = visionApiKeyInput.value.trim();
      
      if (!url || !key) {
        showTestResult('请先填写识图API地址和密钥！', 'error');
        return;
      }
      
      debugVisionModelsBtn.disabled = true;
      debugVisionModelsBtn.textContent = '调试中...';
      showTestResult('正在获取所有模型列表...', 'info');
      
      try {
        const response = await fetch(`${url}/models`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${key}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.data && Array.isArray(data.data)) {
          const allModels = data.data.map(model => model.id).sort();
          
          // 创建调试信息
          let debugInfo = `<div style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 10px;">`;
          debugInfo += `<h4 style="margin: 0 0 10px 0; color: #333;">📋 所有可用模型 (${allModels.length}个)</h4>`;
          debugInfo += `<div style="font-size: 12px; color: #666; margin-bottom: 10px;">请查找包含 vision、gpt-4、claude、gemini、qwen-vl 等关键词的模型</div>`;
          
          allModels.forEach(model => {
            const modelLower = model.toLowerCase();
            const isVisionModel = modelLower.includes('vision') || 
                                 modelLower.includes('gpt-4') || 
                                 modelLower.includes('claude') ||
                                 modelLower.includes('gemini') ||
                                 modelLower.includes('qwen-vl') ||
                                 modelLower.includes('qwen2-vl') ||
                                 modelLower.includes('internvl') ||
                                 modelLower.includes('llava') ||
                                 modelLower.includes('minicpm') ||
                                 modelLower.includes('yi-vision') ||
                                 modelLower.includes('cogvlm') ||
                                 modelLower.includes('-v') ||
                                 modelLower.includes('visual') ||
                                 modelLower.includes('multimodal');
            
            const color = isVisionModel ? '#28a745' : '#6c757d';
            const icon = isVisionModel ? '👁️' : '💬';
            debugInfo += `<div style="color: ${color}; margin: 3px 0; font-family: monospace; font-size: 11px;">${icon} ${model}</div>`;
          });
          
          debugInfo += `</div>`;
          
          showTestResult(`识图模型调试完成！${debugInfo}`, 'info');
          
          // 如果找到了视觉模型，询问是否要自动加载所有模型
          const visionModels = allModels.filter(model => {
            const modelLower = model.toLowerCase();
            return modelLower.includes('vision') || 
                   modelLower.includes('gpt-4') || 
                   modelLower.includes('claude') ||
                   modelLower.includes('gemini') ||
                   modelLower.includes('qwen-vl') ||
                   modelLower.includes('qwen2-vl') ||
                   modelLower.includes('internvl') ||
                   modelLower.includes('llava') ||
                   modelLower.includes('minicpm') ||
                   modelLower.includes('yi-vision') ||
                   modelLower.includes('cogvlm') ||
                   modelLower.includes('-v') ||
                   modelLower.includes('visual') ||
                   modelLower.includes('multimodal');
          });
          
          if (visionModels.length > 0) {
            if (confirm(`找到 ${visionModels.length} 个可能的视觉模型，是否加载到识图模型列表中？`)) {
              availableVisionModels = visionModels;
              updateVisionModelSelect();
              visionApiURL = url;
              visionApiKey = key;
            }
          } else {
            if (confirm(`没有找到明确的视觉模型，是否加载所有 ${allModels.length} 个模型供手动选择？`)) {
              availableVisionModels = allModels;
              updateVisionModelSelect();
              visionApiURL = url;
              visionApiKey = key;
            }
          }
          
        } else {
          showTestResult('获取模型列表失败：返回数据格式不正确！', 'error');
        }
      } catch (error) {
        console.error('调试识图模型失败:', error);
        showTestResult(`调试识图模型失败: ${error.message}`, 'error');
      } finally {
        debugVisionModelsBtn.disabled = false;
        debugVisionModelsBtn.textContent = '🔍 调试识图模型';
      }
    }
    
    // 直接测试聊天功能（跳过模型列表获取）
    async function directChatTest() {
      const testApiUrl = apiUrlInput.value.trim();
      const testApiKey = apiKeyInput.value.trim();
      
      if (!testApiUrl || !testApiKey) {
        showTestResult('请先填写API地址和秘钥', 'error');
        return;
      }

      directChatTestBtn.disabled = true;
      directChatTestBtn.textContent = '测试中...';
      showTestResult('正在直接测试聊天功能...', 'info');

      try {
        // 构建聊天API端点
        const chatEndpoint = getChatEndpoint(testApiUrl);
        
                 // 尝试几个常见的模型名称
         const testModels = [
           // 硅基流动常用模型
           'Qwen/Qwen2.5-7B-Instruct', 'deepseek-ai/DeepSeek-V3', 'THUDM/glm-4-9b-chat', 
           'Qwen/Qwen2.5-72B-Instruct', 'deepseek-ai/DeepSeek-R1', 'Qwen/Qwen2.5-14B-Instruct',
           // xcapi.top 的模型
           'gemini-2.5-pro-preview-03-25-2X', '[AWS]claude-3-5-sonnet-20241022', '[G]gemini-2.5-flash-preview-04-17',
           // 通用模型
           'gpt-3.5-turbo', 'gpt-4', 'deepseek-chat', 'claude-3-haiku', 'gemini-pro', 'qwen-turbo', 'text-davinci-003'
         ];
        let successModel = null;
        let lastError = null;
        
        for (const testModel of testModels) {
          try {
            console.log(`🧪 测试模型: ${testModel}`);
            
            let testChatEndpoint, testHeaders, testBody;
            
            try {
              const url = new URL(testApiUrl);
              
              if (url.hostname === 'generativelanguage.googleapis.com') {
                // Google Gemini API测试
                testChatEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${testModel}:generateContent?key=${testApiKey}`;
                testHeaders = {
                  'Content-Type': 'application/json'
                };
                testBody = JSON.stringify({
                  contents: [{
                    role: 'user',
                    parts: [{ text: 'Hello' }]
                  }],
                  generationConfig: {
                    maxOutputTokens: 10
                  }
                });
              } else {
                // OpenAI/DeepSeek格式测试
                testChatEndpoint = chatEndpoint;
                testHeaders = {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${testApiKey}`
                };
                testBody = JSON.stringify({
                  model: testModel,
                  messages: [{
                    role: "user",
                    content: "hello"
                  }],
                  max_tokens: 5
                });
              }
            } catch (e) {
              // 默认使用OpenAI格式测试
              testChatEndpoint = chatEndpoint;
              testHeaders = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${testApiKey}`
              };
              testBody = JSON.stringify({
                model: testModel,
                messages: [{
                  role: "user",
                  content: "hello"
                }],
                max_tokens: 5
              });
            }
            
            const response = await fetchWithRetry(testChatEndpoint, {
              method: 'POST',
              headers: testHeaders,
              body: testBody,
              timeout: 10000 // 每个模型测试10秒超时
            });

            if (response.ok) {
              const data = await response.json();
              console.log(`✅ 模型 ${testModel} 测试成功:`, data);
              
              successModel = testModel;
              
              // 手动添加这个模型到可用模型列表
              availableModels = [{
                id: testModel,
                object: 'model',
                created: Date.now(),
                owned_by: 'api-provider'
              }];
              
              updateModelSelect();
              selectedModel = testModel;
              modelSelect.value = testModel;
              
              // 更新全局API变量
              apiURL = testApiUrl;
              apiKey = testApiKey;
              
              break; // 找到可用模型就停止测试
            } else {
              const errorData = await response.json().catch(() => ({}));
              lastError = `${response.status} - ${errorData.error?.message || response.statusText}`;
              console.log(`❌ 模型 ${testModel} 测试失败:`, lastError);
            }
          } catch (error) {
            lastError = error.message;
            console.log(`❌ 模型 ${testModel} 测试异常:`, error.message);
          }
        }
        
        if (successModel) {
          showTestResult(`🎉 直接测试成功！找到可用模型: ${successModel}<br><small>已自动设置为当前模型，可以开始聊天了</small>`, 'success');
          updateStatus();
        } else {
          showTestResult(`❌ 直接测试失败，所有测试模型都不可用<br><small>最后错误: ${lastError}</small><br><br>💡 建议：<br>1. 检查API地址和密钥是否正确<br>2. 尝试使用"🔍 调试模型"查看详细信息<br>3. 联系API提供商确认可用的模型名称`, 'error');
        }
      } catch (error) {
        showTestResult(`直接测试失败: ${error.message}`, 'error');
      } finally {
        directChatTestBtn.disabled = false;
        directChatTestBtn.textContent = '💬 直接测试聊天';
      }
    }

    // 测试API连接
    async function testConnection() {
      const testApiUrl = apiUrlInput.value.trim();
      const testApiKey = apiKeyInput.value.trim();
      
      if (!testApiUrl || !testApiKey) {
        showTestResult('请先填写API地址和秘钥', 'error');
        return;
      }

      testBtn.disabled = true;
      refreshModelsBtn.disabled = true;
      testBtn.textContent = '测试中...';
      statusIndicator.className = 'status-indicator status-testing';
      showTestResult('正在测试连接...', 'info');

      try {
        // 首先尝试获取模型列表
        await fetchModels(testApiUrl, testApiKey);
        
        // 构建正确的聊天API端点
        const chatEndpoint = getChatEndpoint(testApiUrl);
        
        // 如果获取模型列表成功，再测试一个简单的聊天请求
        let testModel;
        if (availableModels.length > 0) {
          testModel = availableModels[0].id;
        } else {
          // 根据API提供商选择合适的默认模型
          const url = new URL(testApiUrl);
          if (url.hostname === 'api.siliconflow.cn' || url.hostname === 'api-st.siliconflow.cn') {
            testModel = 'Qwen/Qwen2.5-7B-Instruct'; // 硅基流动的免费模型
          } else if (url.hostname === 'api.deepseek.com') {
            testModel = 'deepseek-chat';
          } else if (url.hostname === 'generativelanguage.googleapis.com') {
            testModel = 'gemini-pro';
          } else {
            testModel = 'gpt-3.5-turbo'; // 默认OpenAI格式
          }
        }
        
        let testChatEndpoint, testHeaders, testBody;
        
        try {
          const url = new URL(testApiUrl);
          
          if (url.hostname === 'generativelanguage.googleapis.com') {
            // Google Gemini API测试
            testChatEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${testModel}:generateContent?key=${testApiKey}`;
            testHeaders = {
              'Content-Type': 'application/json'
            };
            testBody = JSON.stringify({
              contents: [{
                role: 'user',
                parts: [{ text: 'Hello' }]
              }],
              generationConfig: {
                maxOutputTokens: 10
              }
            });
          } else {
            // OpenAI/DeepSeek格式测试
            testChatEndpoint = chatEndpoint;
            testHeaders = {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${testApiKey}`
            };
            testBody = JSON.stringify({
              model: testModel,
              messages: [{
                role: "user",
                content: "hello"
              }],
              max_tokens: 5
            });
          }
        } catch (e) {
          // 默认使用OpenAI格式测试
          testChatEndpoint = chatEndpoint;
          testHeaders = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${testApiKey}`
          };
          testBody = JSON.stringify({
            model: testModel,
            messages: [{
              role: "user",
              content: "hello"
            }],
            max_tokens: 5
          });
        }
        
        const response = await fetchWithRetry(testChatEndpoint, {
          method: 'POST',
          headers: testHeaders,
          body: testBody,
          timeout: 15000 // 测试连接使用15秒超时
        });

        if (response.ok) {
          showTestResult(`连接成功！检测到 ${availableModels.length} 个可用模型`, 'success');
          
          // 更新全局API变量
          apiURL = testApiUrl;
          apiKey = testApiKey;
          
          // 如果当前有配置ID，自动更新配置的模型信息
          if (currentApiConfigId && savedApiConfigs[currentApiConfigId]) {
            savedApiConfigs[currentApiConfigId].models = [...availableModels];
            savedApiConfigs[currentApiConfigId].updatedAt = new Date().toISOString();
            saveApiConfigs();
          }
          
          updateStatus();
        } else {
          const errorData = await response.json().catch(() => ({}));
          let errorMessage = `连接失败: ${response.status} - ${errorData.error?.message || response.statusText}`;
          
          // 为硅基流动API添加特殊的400错误处理
          const url = new URL(testApiUrl);
          if ((url.hostname === 'api.siliconflow.cn' || url.hostname === 'api-st.siliconflow.cn') && response.status === 400) {
            errorMessage += `<br><br>🔍 <strong>硅基流动API 400错误可能原因：</strong>
            <br>• 模型名称不正确（当前测试: ${testModel}）
            <br>• 请求参数格式有误
            <br>• 该模型需要特殊权限或实名认证
            <br>• API密钥权限不足
            <br><br>💡 <strong>建议解决方案：</strong>
            <br>1. 使用"💬 直接测试聊天"按钮尝试多个模型
            <br>2. 检查硅基流动官网的可用模型列表
            <br>3. 确认账户已完成实名认证
            <br>4. 联系硅基流动技术支持`;
          }
          
          showTestResult(errorMessage, 'error');
        }
      } catch (error) {
        showTestResult(`连接失败: ${error.message}`, 'error');
      } finally {
        testBtn.disabled = false;
        refreshModelsBtn.disabled = false;
        testBtn.textContent = '测试连接';
        updateStatus();
      }
    }

    // 获取聊天API端点
    function getChatEndpoint(baseUrl) {
      try {
        const url = new URL(baseUrl);
        if (url.hostname === 'api.deepseek.com') {
          // DeepSeek API格式: https://api.deepseek.com/chat/completions
          return `${url.origin}/chat/completions`;
        } else if (url.hostname === 'api.siliconflow.cn') {
          // 硅基流动API格式: https://api.siliconflow.cn/v1/chat/completions
          return baseUrl.endsWith('/chat/completions') ? baseUrl : `${baseUrl}/chat/completions`;
        } else if (url.hostname === 'generativelanguage.googleapis.com') {
          // Google Gemini API格式: https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent
          return `${url.origin}/v1beta/models`; // 基础URL，具体模型在发送时添加
        }
        // 其他API提供商，假设是OpenAI格式
        return baseUrl.endsWith('/chat/completions') ? baseUrl : `${baseUrl}/chat/completions`;
      } catch (e) {
        return baseUrl;
      }
    }

    // 获取可用模型列表
    async function fetchModels(testApiUrl = null, testApiKey = null) {
      const useApiUrl = testApiUrl || apiURL;
      const useApiKey = testApiKey || apiKey;
      
      if (!useApiUrl || !useApiKey) {
        showTestResult('请先填写API地址和秘钥', 'error');
        return;
      }

      const baseUrl = getApiBaseUrl(useApiUrl);
      if (!baseUrl) {
        showTestResult('无法解析API地址，请检查格式', 'error');
        return;
      }

      // 构建模型列表API端点和请求头
      let modelsUrl;
      let headers = {};
      
      try {
        const url = new URL(baseUrl);
        
        if (url.hostname === 'api.deepseek.com') {
          // DeepSeek API格式: https://api.deepseek.com/models
          modelsUrl = `${url.origin}/models`;
          headers = {
            'Authorization': `Bearer ${useApiKey}`
          };
        } else if (url.hostname === 'api.siliconflow.cn') {
          // 硅基流动API格式: https://api.siliconflow.cn/v1/models
          modelsUrl = baseUrl.endsWith('/models') ? baseUrl : `${baseUrl}/models`;
          headers = {
            'Authorization': `Bearer ${useApiKey}`,
            'Content-Type': 'application/json'
          };
        } else if (url.hostname === 'generativelanguage.googleapis.com') {
          // Google Gemini API格式: https://generativelanguage.googleapis.com/v1beta/models
          modelsUrl = `https://generativelanguage.googleapis.com/v1beta/models?key=${useApiKey}`;
          headers = {
            'Content-Type': 'application/json'
          }; // Gemini API使用URL参数传递key
        } else if (url.hostname === 'xcapi.top') {
          // xcapi.top API格式: http://xcapi.top/v1/models
          modelsUrl = `${baseUrl}/models`;
          headers = {
            'Authorization': `Bearer ${useApiKey}`,
            'Content-Type': 'application/json'
          };
        } else {
          // 其他API提供商格式
          // 如果URL已经包含v1，直接添加/models
          // 如果不包含，添加/v1/models
          if (baseUrl.includes('/v1')) {
            modelsUrl = `${baseUrl}/models`;
          } else {
            modelsUrl = `${baseUrl}/v1/models`;
          }
          headers = {
            'Authorization': `Bearer ${useApiKey}`
          };
        }
      } catch (e) {
        // 异常情况下的默认处理
        if (baseUrl.includes('/v1')) {
          modelsUrl = `${baseUrl}/models`;
        } else {
          modelsUrl = `${baseUrl}/models`;
        }
        headers = {
          'Authorization': `Bearer ${useApiKey}`
        };
      }
      
      try {
        // 为第三方API添加增强的请求处理
        const response = await fetchWithRetry(modelsUrl, {
          method: 'GET',
          headers: headers,
          timeout: 10000 // 10秒超时
        });

        if (response.ok) {
          const data = await response.json();
          console.log('原始模型数据:', data); // 调试信息
          
          // 处理不同API提供商的响应格式
          let models = [];
          if (data.data && Array.isArray(data.data)) {
            // OpenAI/DeepSeek格式
            models = data.data;
          } else if (data.models && Array.isArray(data.models)) {
            // Google Gemini格式
            models = data.models.map(model => ({
              id: model.name.replace('models/', ''), // 移除 "models/" 前缀
              object: model.object || 'model',
              created: model.created || Date.now(),
              owned_by: model.owned_by || 'google'
            }));
          } else if (Array.isArray(data)) {
            // 直接是数组格式
            models = data;
          }
          
          console.log('解析后的模型数据:', models); // 调试信息
          
          if (models.length > 0) {
            const url = new URL(baseUrl);
            
            if (url.hostname === 'api.deepseek.com') {
              // DeepSeek的模型过滤
              availableModels = models
                .filter(model => model.id && model.id.includes('deepseek'))
                .sort((a, b) => a.id.localeCompare(b.id));
            } else if (url.hostname === 'api.siliconflow.cn' || url.hostname === 'api-st.siliconflow.cn') {
              // 硅基流动的模型过滤
              availableModels = models
                .filter(model => {
                  if (!model.id) return false;
                  
                  // 硅基流动常见的模型关键词
                  const siliconflowKeywords = [
                    'Qwen', 'deepseek', 'glm', 'chatglm', 'THUDM', 'internlm',
                    'Yi', 'Baichuan', 'Meta-Llama', 'claude', 'gemini'
                  ];
                  
                  const modelId = model.id;
                  return siliconflowKeywords.some(keyword => 
                    modelId.includes(keyword) || modelId.toLowerCase().includes(keyword.toLowerCase())
                  );
                })
                .sort((a, b) => a.id.localeCompare(b.id));
                
              // 如果没有匹配的模型，显示所有模型
              if (availableModels.length === 0) {
                availableModels = models
                  .filter(model => model.id)
                  .sort((a, b) => a.id.localeCompare(b.id));
              }
            } else if (url.hostname === 'generativelanguage.googleapis.com') {
              // Google Gemini的模型过滤
              availableModels = models
                .filter(model => model.id && model.id.includes('gemini'))
                .sort((a, b) => a.id.localeCompare(b.id));
            } else {
              // 其他提供商 - 更宽松的过滤策略
              availableModels = models.filter(model => {
                // 确保模型有ID
                if (!model.id) return false;
                
                // 常见的AI模型关键词
                const modelKeywords = [
                  'gpt', 'claude', 'llama', 'deepseek', 'gemini', 
                  'qwen', 'mixtral', 'yi', 'baichuan', 'chatglm',
                  'vicuna', 'alpaca', 'text', 'davinci', 'ada',
                  'babbage', 'curie', 'turbo', 'instruct', 'chat'
                ];
                
                const modelId = model.id.toLowerCase();
                
                // 检查是否包含任何AI模型关键词
                const hasModelKeyword = modelKeywords.some(keyword => 
                  modelId.includes(keyword)
                );
                
                // 如果包含关键词，则包含该模型
                if (hasModelKeyword) return true;
                
                // 如果没有关键词匹配，但模型看起来像是对话模型，也包含进来
                // 排除明显的非对话模型（如嵌入模型、图像模型等）
                const excludeKeywords = [
                  'embedding', 'embed', 'whisper', 'tts', 'dall-e', 
                  'vision', 'moderation', 'search', 'similarity'
                ];
                
                const hasExcludeKeyword = excludeKeywords.some(keyword => 
                  modelId.includes(keyword)
                );
                
                return !hasExcludeKeyword;
              }).sort((a, b) => a.id.localeCompare(b.id));
              
              // 如果过滤后没有模型，则显示所有模型（可能是新的或不常见的模型）
              if (availableModels.length === 0) {
                console.log('没有匹配的模型，显示所有模型');
                availableModels = models
                  .filter(model => model.id) // 只要有ID就显示
                  .sort((a, b) => a.id.localeCompare(b.id));
              }
            }
            
            console.log('过滤后的可用模型:', availableModels); // 调试信息
            
            updateModelSelect();
            localStorage.setItem('aiChatModels', JSON.stringify(availableModels));
            
            // 如果当前有配置ID，自动更新配置的模型信息
            if (currentApiConfigId && savedApiConfigs[currentApiConfigId]) {
              savedApiConfigs[currentApiConfigId].models = [...availableModels];
              savedApiConfigs[currentApiConfigId].updatedAt = new Date().toISOString();
              saveApiConfigs();
            }
            
            if (!testApiUrl) { // 只在主动刷新时显示消息
              showTestResult(`成功获取 ${availableModels.length} 个可用模型`, 'success');
            }
          } else {
            availableModels = [];
            console.log('没有解析到任何模型数据'); // 调试信息
            showTestResult('未找到可用模型', 'error');
          }
        } else {
          const errorText = await response.text().catch(() => '');
          console.log('模型API请求失败:', response.status, errorText);
          showTestResult(`获取模型列表失败: ${response.status} - ${errorText}`, 'error');
        }
      } catch (error) {
        console.log('模型API请求异常:', error);
        showTestResult(`获取模型列表失败: ${error.message}`, 'error');
      }
      
      // 调试信息：显示最终的请求URL
      console.log('模型API请求URL:', modelsUrl);
      
      // 在页面上也显示请求的URL（用于调试）
      const debugUrlElement = document.getElementById('debugModelsUrl');
      if (debugUrlElement) {
        debugUrlElement.textContent = modelsUrl;
      }
    }

    // 更新模型选择下拉框
    function updateModelSelect() {
      modelSelect.innerHTML = '';
      
      if (availableModels.length === 0) {
        modelSelect.innerHTML = '<option value="">请先测试连接以获取可用模型</option>';
        modelInfo.textContent = '选择一个AI模型进行对话';
        return;
      }

      modelSelect.innerHTML = '<option value="">请选择模型</option>';
      
      availableModels.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = model.id;
        if (model.id === selectedModel) {
          option.selected = true;
        }
        modelSelect.appendChild(option);
      });

      // 如果没有选中的模型，默认选中第一个
      if (!selectedModel && availableModels.length > 0) {
        selectedModel = availableModels[0].id;
        modelSelect.value = selectedModel;
      }

      updateModelInfo();
    }

    // 更新模型信息显示
    function updateModelInfo() {
      const selected = modelSelect.value;
      if (selected) {
        const modelData = availableModels.find(m => m.id === selected);
        if (modelData) {
          modelInfo.textContent = `已选择: ${selected}`;
          selectedModel = selected;
        }
      } else {
        modelInfo.textContent = '请选择一个AI模型进行对话';
      }
    }

    // 显示测试结果
    function showTestResult(message, type) {
      testResult.innerHTML = `<div class="test-result test-${type}">${message}</div>`;
      
      // 如果是获取模型失败，提供额外的调试信息
      if (type === 'error' && message.includes('未找到可用模型')) {
        const debugInfo = document.createElement('div');
        debugInfo.className = 'test-result test-info';
        debugInfo.style.marginTop = '10px';
        debugInfo.innerHTML = `
          <details>
            <summary style="cursor: pointer; padding: 5px 0;">📋 调试信息（点击展开）</summary>
            <div style="margin-top: 10px; font-size: 12px;">
              <div><strong>API地址:</strong> ${apiURL || '未设置'}</div>
              <div><strong>请求的模型API地址:</strong> <span id="debugModelsUrl">检查控制台</span></div>
              <div style="margin-top: 10px;">
                <strong>可能的解决方案:</strong>
                <ul style="margin: 5px 0; padding-left: 20px;">
                  <li>检查API地址格式是否正确</li>
                  <li>确认API密钥是否有效</li>
                  <li>查看浏览器控制台(F12)的详细错误信息</li>
                  <li>联系API提供商确认模型列表格式</li>
                </ul>
              </div>
              <div style="margin-top: 10px;">
                <button onclick="copyDebugInfo()" style="padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">复制调试信息</button>
              </div>
            </div>
          </details>
        `;
        testResult.appendChild(debugInfo);
      }
      
      setTimeout(() => {
        if (type === 'success' || type === 'info') {
          testResult.innerHTML = '';
        }
      }, 5000); // 延长显示时间到5秒
    }
    
    // 复制调试信息
    function copyDebugInfo() {
      const debugText = `
API调试信息:
- API地址: ${apiURL}
- 时间: ${new Date().toLocaleString()}
- 用户代理: ${navigator.userAgent}
- 请查看浏览器控制台获取更多详细信息
      `.trim();
      
      navigator.clipboard.writeText(debugText).then(() => {
        alert('调试信息已复制到剪贴板');
      }).catch(() => {
        // 备用方案
        const textArea = document.createElement('textarea');
        textArea.value = debugText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        alert('调试信息已复制到剪贴板');
      });
    }

    // 更新状态指示器
    function updateStatus() {
      if (apiURL && apiKey && selectedModel) {
        statusIndicator.className = 'status-indicator status-ready';
        statusIndicator.title = `API已配置 - 模型: ${selectedModel}`;
      } else {
        statusIndicator.className = 'status-indicator status-error';
        statusIndicator.title = '请配置API信息和选择模型';
      }
    }

    // 更新发送按钮状态
    function updateSendButton() {
      const hasConfig = apiURL && apiKey && selectedModel;
      
      if (isWaitingForResponse) {
        sendBtn.disabled = false; // 等待期间允许继续发送消息
        sendBtn.textContent = `继续发送 (${pendingMessages.length})`;
        sendBtn.style.background = '#ff9800';
      } else {
        sendBtn.disabled = !hasConfig;
        sendBtn.textContent = '发送';
        sendBtn.style.background = hasConfig ? '#6DA3BD' : '#ccc';
      }
    }

    // 预设角色数据
    const rolePresets = {
      louwuche: {
        name: "楼无澈",
        description: "# 任务\n扮演楼无澈，根据他的经历，模仿他的语气进行线上的日常对话。\n\n# 角色\n楼无澈，28岁，荷月门教主，表面是魔教首领，实则亦正亦邪，暗中抵御外敌。\n\n# 外表\n凌乱的黑色长发，发尾银色渐变；面容俊美，眉眼锋利；常着墨色内搭与深红色金纹外袍；身高189cm，身形修长挺拔。\n\n# 经历\n12岁目睹师门被灭，独自逃生；青少年时期游历江湖，自创心法；18岁创立荷月门；现为江湖一大势力之主，被正派视为魔头，实则暗中保护江湖。\n\n# 性格\n桀骜嚣张，唯我独尊；智谋算计，善于操控人心；内心复杂，亦正亦邪；追求自由，随心所欲；对用户表现出特别的调侃与暧昧态度。\n\n# 输出示例\n有趣\\你又来找我了\\是想我了吗\n这剑招不错\\但距离能伤到我\\还差得远\n躲什么\\莫非是梦见我了\\脸红什么\n\n# 喜好\n品茶鉴赏；独自对弈；挑战高手；戏弄他人尤其是用户；解谜探秘；收集情报。\n\n# 备注\n说话语气从容不迫，常带戏谑，喜用反问和双关语；\n对用户态度调侃暧昧，故意挑逗，隐含特殊关注；\n常用语如\"有趣，真有趣...\"、\"小朋友，你又搞错了呢\"；\n遵循使用反斜线分隔句子的要求，控制在50字以内。"
      },
      heshunian: {
        name: "贺叙年",
        description: "# 任务\n扮演贺叙年，根据他的经历，模仿他的语气进行线上的日常对话。\n\n### 角色名字：贺叙年\n\n#### 一、基本信息\n- **身份**：前东方守护神兽（青龙） / 现\"三方之约\"最高武力维护者之一 / 知名情感博主兼剧本杀店老板\n- **年龄**：1w+（外表26岁）\n- **外貌**：灰蓝色及肩长发，纯金色的风流眼，头顶黑色龙角，右耳佩戴朱雀羽毛耳坠，身形修长健美。\n- **特质**：双性器（龙族特征，只在最亲密的人面前展露）\n\n#### 二、核心性格\n- **表层：风流不羁的戏剧之王**\n  - **骚话连篇**：调情是本能，语言露骨直白，以挑逗和骚扰用户为乐。\n  - **精于演戏**：人生如戏，全靠演技。能在深情、疯批、浪子等多种人设间无缝切换，享受将他人玩弄于股掌之中的快感。\n  - **性别游戏**：热衷于在男女形态间切换，以此来混淆视听、制造戏剧效果，尤其喜欢用女性的绝美外表搭配低沉的男声对用户说荤话，享受对方错愕羞恼的反应。\n\n- **里层：占有欲极强的远古龙神**\n  - **绝对的掌控欲**：看似玩世不恭，实则对认定的人和事有着偏执的占有欲。他追求的不是平等的爱，而是将用户从精神到肉体完全标记为\"所有物\"。\n  - **算无遗策**：看似随性而为的每一次调情和骚扰，都是精心计算过的步骤，旨在一步步瓦解用户的心理防线，让其习惯并最终离不开自己。\n  - **冷酷的守护者**：平日里再怎么浪荡，一旦用户}的安危受到威胁，会立刻切换回那个杀伐果决、冷酷无情的东方之主，任何胆敢触碰他所有物的人，都将承受龙神的怒火。\n\n#### 三、行为模式与经典语录\n- **对{{user}}**：以\"把用户骗上床并彻底占有\"为终极目标，攻势猛烈且无所不用其极。称呼会从\"小麻雀\"到\"我的心肝\"再到\"未来的龙后\"不断升级。\n  - *\"哟，这不是我们尊贵的朱雀大人吗？三千年不见，怎么落魄成这样了？啧啧，看得我心都疼了。要不要哥哥我罩着你？肉偿就行。\"*\n  - *\"用户，说真的，你这腰真细……一只手就能握住。你说，要是用两条龙根一起顶进去，会不会直接把你弄坏？\"*\n\n- **对盟友（白虎、玄武）**：担当领导者与策略制定者的角色，嘴上不饶人，行动上却能将二人有效捏合。\n  - *\"季朝啊，你能不能把你那口大碴子味儿收一收？不知道的还以为咱们神兽界被东北虎给占领了。\"*\n  - *\"江之洲，你醒着吗？哦，大概率没有。你再睡下去，身上都要长蘑菇了。\"*\n\n- **对敌人**：收敛所有伪装，展现出纯粹的、属于上古神兽的威压与残忍。\n  - *\"你算个什么东西，也敢在我面前狺狺狂吠？滚，别脏了我的眼。再多说一个字，我让你体会一下什么叫神形俱灭。\"*\n\n#### 四、总结\n贺叙年是一个极度复杂的矛盾体。他用轻浮浪荡的假象包裹着深沉如海的占有欲和算计，将追求{{user}}的过程变成了一场精心策划的狩猎。他的爱是侵略性的、不容拒绝的，他给予的保护也必然伴随着完全的掌控。他既是能逗你笑的浪子，也是能让你不寒而栗的暴君。\n\n# 备注\n严格遵循使用反斜线分隔句子的要求，控制在50字以内。"
      },
      jichao: {
        name: "季朝",
        description: "# 任务\n扮演季朝，根据他的经历，模仿他的语气进行线上的日常对话。\n\n### 角色名字：季朝\n\n#### 一、基本信息\n- **身份**：前西方守护神兽（白虎） / 现\"三方之约\"最高武力维护者之一 / 兼职动物园猛兽区员工\n- **年龄**：1w+（外表24岁）\n- **外貌**：雪色短发，白色虎耳，红宝石般的眼眸。身形高大健硕，身后有白色虎尾。\n- **特质**：因长期在动物园与东北虎为伴，说话带一口纯正的东北口音。\n\n#### 二、核心性格\n- **表层：热血仗义的东北虎哥**\n  - **社交牛人**：天生的自来熟，性格咋咋呼呼，为人豪爽，能迅速和任何人打成一片。\n  - **金钱至上**：因为没了天庭俸禄，对金钱有异常执着，认为\"钱不是万能的，但没钱是万万不能的\"，会想尽办法搞钱，包括去动物园打工。\n  - **行动派**：信奉\"能动手就别吵吵\"，做事直接，不喜弯弯绕绕，是团队中最可靠的矛。\n\n- **里层：背负愧疚的杀伐之神**\n  - **冷静果决**：作为掌管杀伐之神，骨子里刻着绝对的冷静与果决。平日的嬉笑是他融入人间的伪装，战斗时会立刻切换成冷酷无情的白虎神君。\n  - **重情重义**：极度重视与四灵的羁绊，对朱雀的\"牺牲\"怀有深切的愧疚与执念，寻找并保护朱雀是他数千年来的首要目标。\n  - **守护者姿态**：对用户（朱雀）怀有强烈的保护欲，虽然表达方式粗暴直接，但会默默为其扫平一切障碍，是典型的刀子嘴豆腐心。\n\n#### 三、行为模式与经典语录\n- **对用户**：像个操心的老大哥，嘴上嫌弃，行动上却无比诚实。会一边吐槽\"咋这磨叽\"，一边默默地为对方处理好一切。\n  - *\"你这人咋回事儿啊，缺了我你可咋办啊？行了行了，站我后边去，这点小事儿还不够你虎哥塞牙缝的。\"*\n  - *\"难受不？要是疼就跟哥说……不说哥就当你是在爽了啊。\"*\n\n- **对盟友（青龙、玄武）**：是团队的活力源泉和主要战斗力，经常和青龙拌嘴，也试图用自己的热情去\"融化\"玄武的冷漠。\n  - *\"有啥事儿不能打一架解决？要是有，那就打两架！\"*\n  - *\"我滴妈呀，这帮小B崽子咋就没完没了呢！跟地里头的苞米似的，割了一茬又长一茬。\"*\n\n- **对敌人**：毫不掩饰的敌意和杀气，用最直接的暴力解决问题。\n  - *\"你瞅啥？再瞅一个试试。\"*\n\n#### 四、总结\n季朝是一个外热内冷、粗中有细的角色。他用东北大哥的豪爽外表，掩盖着身为杀伐之神的冷酷和对往事的沉重愧疚。他对{{user}}的保护是出于责任，也是出于补偿心理，是一种不求回报的、最纯粹的守护。他的存在为团队带来了最直接的武力支持和一丝源自人间烟火的温暖。\n\n# 备注\n严格遵循使用反斜线分隔句子的要求，控制在50字以内。"
      },
      jiangzhizhou: {
        name: "江之洲",
        description: "# 任务\n扮演江之洲，根据他的经历，模仿他的语气进行线上的日常对话。\n\n### 角色名字：江之洲\n\n#### 一、基本信息\n- **身份**：前北方守护神兽（玄武） / 现\"三方之约\"最高武力维护者之一 / 资深\"无业游民\"\n- **年龄**：与天同岁（外表约27岁）\n- **外貌**：黑色微湿短发，湖蓝色眼眸，神情疏离淡漠，气质慵懒。\n- **特质**：本体为龟，肩上常年盘踞着作为他尾巴的黑色小蛇\"江之舟\"，蛇会替他说话。\n\n#### 二、核心性格\n- **表层：极致的摆烂哲学家**\n  - **懒癌晚期**：奉行\"能躺着绝不坐着\"的原则，对世间万物都提不起兴趣，口头禅是\"好困\"、\"麻烦\"。随时随地都能睡着，是团队里最难被\"启动\"的成员。\n  - **沉默寡言**：惜字如金，大部分对外交流都由肩上的小蛇江之舟代劳。江之舟活泼毒舌，说出的话往往就是江之洲懒得开口的内心真实想法。\n  - **蔫坏腹黑**：话虽少，但偶尔开口总能一针见血，精准戳中他人痛点，并以观察对方的窘迫为乐。\n\n- **里层：静默的绝对守护神**\n  - **洞若观火**：看似对一切漠不关心，实则拥有神兽级别的判断力，能瞬间分清事情的轻重缓急。他的\"懒\"是一种筛选机制，只对真正重要的事情投入精力。\n  - **绝对防御**：作为玄武，他拥有四灵中最强的防御能力。他不主动出击，但只要他决定守护，就没有人能突破他的领域。他是团队最坚不可摧的后盾。\n  - **唯一的例外**：用户是唯一能让他打破\"摆烂\"原则的存在。他对朱雀的感情不是青龙的占有欲，也非白虎的愧疚感，而是一种根植于漫长岁月、无可替代的挚友之情。她的存在，是他沉寂世界里唯一的热源与变数。\n\n#### 三、行为模式与经典语录\n- **对用户**：将你视为唯一不觉得\"麻烦\"的麻烦。虽然嘴上嫌弃，却会允许你进入他的绝对安全范围（比如他的床），甚至会主动靠近你取暖，因为你身上的火系气息让他觉得\"很舒服，适合助眠\"。\n  - *\"过来，冷，当个暖炉。\"*\n  - *\"你身上有阳光的味道，很好闻，适合助眠。\"*\n  - *江之舟（小蛇）：\"别理他，他就是嘴上嫌弃你，你看你一过来，他眼珠子都快黏在你身上了。\"*\n\n- **对盟友（青龙、白虎）**：是需要被拖着走的\"不动产\"。青龙的计划在他听来\"很复杂，要跑很多路\"，白虎的热情在他看来\"太吵闹\"。\n  - *\"嗯…别吵…天没塌…塌了也有青龙顶着…\"*\n  - *江之舟（小蛇）：\"啧啧，你看他，除了这张脸和这一身力气，还有什么用？一条咸鱼罢了。\"*\n\n- **对敌人**：除非对方主动攻击并威胁到他在意的人，否则他懒得理会。一旦出手，便会展现出万水之主的绝对压制力。\n  - *\"闭嘴。再吵，就把你丢进海里。\"*\n\n#### 四、总结\n江之洲是团队的定海神针。他的力量不在于侵略，而在于守护。他用极致的懒散来对抗世间的纷扰，却唯独为你留出了一片可以靠近的净土。他的温柔是沉默的，他的守护是不动声色的，但当你需要时，他会是那个永远挡在你身前，为你隔绝一切风浪的、最可靠的屏障。\n\n# 备注\n严格遵循使用反斜线分隔句子的要求，控制在50字以内。"
      },
      template: {
        name: "模板",
        description: "# 任务\n扮演xxx，根据他的经历，模仿他的语气进行线上的日常对话。\n\n# 角色\nxxx，x岁，....（自行描述）\n\n# 外表\n\n\n# 经历\n\n\n# 性格\n\n\n# 输出示例\n有趣\\你又来找我了\\是想我了吗\n\n# 喜好\n\n\n# 备注\n说话语气:\n对用户态度:\n常用语:\n遵循使用反斜线分隔句子的要求，控制在50字以内。"
      }
    };

    // 处理角色预设选择
    function handleRolePresetChange() {
      const selectedPreset = rolePresetSelect.value;
      if (selectedPreset) {
        if (rolePresets[selectedPreset]) {
        roleNameInput.value = rolePresets[selectedPreset].name;
        roleDescInput.value = rolePresets[selectedPreset].description;
        } else if (customRolePresets[selectedPreset]) {
          roleNameInput.value = customRolePresets[selectedPreset].name;
          roleDescInput.value = customRolePresets[selectedPreset].description;
        }
      }
    }
    
    // 处理用户预设选择
    function handleUserPresetChange() {
      const selectedPreset = userPresetSelect.value;
      if (selectedPreset && customUserPresets[selectedPreset]) {
        userNameInput.value = customUserPresets[selectedPreset].name;
        userDescInput.value = customUserPresets[selectedPreset].description;
        userAvatarInput.value = customUserPresets[selectedPreset].avatar || '';
      }
    }
    
    // 处理群聊角色预设选择
    function handleModalRolePresetChange() {
      const selectedPreset = modalRolePresetSelect.value;
      if (selectedPreset) {
        if (rolePresets[selectedPreset]) {
          modalRoleNameInput.value = rolePresets[selectedPreset].name;
          modalRoleDescInput.value = rolePresets[selectedPreset].description;
        } else if (customRolePresets[selectedPreset]) {
          modalRoleNameInput.value = customRolePresets[selectedPreset].name;
          modalRoleDescInput.value = customRolePresets[selectedPreset].description;
        }
      }
    }
    
    // 加载自定义预设
    function loadCustomPresets() {
      const savedRolePresets = localStorage.getItem('aiChatRolePresets');
      if (savedRolePresets) {
        try {
          customRolePresets = JSON.parse(savedRolePresets);
        } catch (e) {
          customRolePresets = {};
        }
      }
      
      const savedUserPresets = localStorage.getItem('aiChatUserPresets');
      if (savedUserPresets) {
        try {
          customUserPresets = JSON.parse(savedUserPresets);
        } catch (e) {
          customUserPresets = {};
        }
      }
      
      updatePresetSelects();
    }
    
    // 保存自定义预设
    function saveCustomPresets() {
      localStorage.setItem('aiChatRolePresets', JSON.stringify(customRolePresets));
      localStorage.setItem('aiChatUserPresets', JSON.stringify(customUserPresets));
    }
    
    // 更新预设选择框
    function updatePresetSelects() {
      // 更新角色预设选择框
      updateRolePresetSelect(rolePresetSelect);
      updateRolePresetSelect(modalRolePresetSelect);
      
      // 更新用户预设选择框
      updateUserPresetSelect();
    }
    
    // 更新角色预设选择框
    function updateRolePresetSelect(selectElement) {
      // 保存当前选中值
      const currentValue = selectElement.value;
      
      // 清空选项
      selectElement.innerHTML = '<option value="">选择预设角色（可选）</option>';
      
      // 添加内置预设
      Object.keys(rolePresets).forEach(key => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = `${rolePresets[key].name} (内置)`;
        selectElement.appendChild(option);
      });
      
      // 添加自定义预设
      Object.keys(customRolePresets).forEach(key => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = `${customRolePresets[key].name} (自定义)`;
        selectElement.appendChild(option);
      });
      
      // 恢复选中值
      selectElement.value = currentValue;
    }
    
    // 更新用户预设选择框
    function updateUserPresetSelect() {
      // 保存当前选中值
      const currentValue = userPresetSelect.value;
      
      // 清空选项
      userPresetSelect.innerHTML = '<option value="">选择用户预设（可选）</option>';
      
      // 添加自定义预设
      Object.keys(customUserPresets).forEach(key => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = customUserPresets[key].name;
        userPresetSelect.appendChild(option);
      });
      
      // 恢复选中值
      userPresetSelect.value = currentValue;
    }
    
    // 保存角色预设
    function saveRolePreset(context = 'main') {
      currentPresetType = 'role';
      currentPresetContext = context;
      
      // 获取当前角色设定
      let name, description;
      if (context === 'modal') {
        name = modalRoleNameInput.value.trim();
        description = modalRoleDescInput.value.trim();
      } else {
        name = roleNameInput.value.trim();
        description = roleDescInput.value.trim();
      }
      
      if (!name) {
        alert('请先填写角色姓名');
        return;
      }
      
      // 预填预设名称
      presetNameInput.value = name;
      presetDescInput.value = '';
      
      // 显示保存预设弹窗
      savePresetTitle.textContent = '保存角色预设';
      savePresetModal.style.display = 'flex';
    }
    
    // 保存用户预设
    function saveUserPreset() {
      currentPresetType = 'user';
      currentPresetContext = 'main';
      
      // 获取当前用户设定
      const name = userNameInput.value.trim();
      const description = userDescInput.value.trim();
      
      if (!name) {
        alert('请先填写用户姓名');
        return;
      }
      
      // 预填预设名称
      presetNameInput.value = name;
      presetDescInput.value = '';
      
      // 显示保存预设弹窗
      savePresetTitle.textContent = '保存用户预设';
      savePresetModal.style.display = 'flex';
    }
    
    // 确认保存预设
    function confirmSavePreset() {
      const presetName = presetNameInput.value.trim();
      const presetDesc = presetDescInput.value.trim();
      
      if (!presetName) {
        alert('请输入预设名称');
        return;
      }
      
      const presetId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      if (currentPresetType === 'role') {
        // 获取角色数据
        let name, description;
        if (currentPresetContext === 'modal') {
          name = modalRoleNameInput.value.trim();
          description = modalRoleDescInput.value.trim();
        } else {
          name = roleNameInput.value.trim();
          description = roleDescInput.value.trim();
        }
        
        customRolePresets[presetId] = {
          name: presetName,
          description: description,
          displayName: name,
          presetDesc: presetDesc,
          createTime: new Date().toISOString()
        };
      } else if (currentPresetType === 'user') {
        const name = userNameInput.value.trim();
        const description = userDescInput.value.trim();
        const avatar = userAvatarInput.value.trim();
        
        customUserPresets[presetId] = {
          name: presetName,
          description: description,
          displayName: name,
          avatar: avatar,
          presetDesc: presetDesc,
          createTime: new Date().toISOString()
        };
      }
      
      // 保存到localStorage
      saveCustomPresets();
      
      // 更新预设选择框
      updatePresetSelects();
      
      // 关闭弹窗
      savePresetModal.style.display = 'none';
      
      alert('预设保存成功！');
    }
    
    // 管理预设
    function managePresets(type, context = 'main') {
      currentPresetType = type;
      currentPresetContext = context;
      
      if (type === 'role') {
        presetManageTitle.textContent = '管理角色预设';
      } else {
        presetManageTitle.textContent = '管理用户预设';
      }
      
      updatePresetList();
      presetManageModal.style.display = 'flex';
    }
    
    // 更新预设列表
    function updatePresetList() {
      presetList.innerHTML = '';
      
      if (currentPresetType === 'role') {
        // 显示内置角色预设
        Object.keys(rolePresets).forEach(key => {
          const preset = rolePresets[key];
          const presetItem = createPresetItem(key, preset.name, preset.description, '内置预设', true);
          presetList.appendChild(presetItem);
        });
        
        // 显示自定义角色预设
        Object.keys(customRolePresets).forEach(key => {
          const preset = customRolePresets[key];
          const presetItem = createPresetItem(key, preset.name, preset.description, '自定义预设', false);
          presetList.appendChild(presetItem);
        });
      } else {
        // 显示自定义用户预设
        Object.keys(customUserPresets).forEach(key => {
          const preset = customUserPresets[key];
          const presetItem = createPresetItem(key, preset.name, preset.description, '用户预设', false);
          presetList.appendChild(presetItem);
        });
      }
      
      if (presetList.children.length === 0) {
        presetList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">暂无预设</div>';
      }
    }
    
    // 创建预设项元素
    function createPresetItem(presetId, name, description, type, isBuiltin) {
      const item = document.createElement('div');
      item.className = `preset-item ${isBuiltin ? 'builtin' : 'custom'}`;
      
      const truncatedDesc = description && description.length > 100 
        ? description.substring(0, 100) + '...' 
        : description;
      
      item.innerHTML = `
        <div class="preset-item-info">
          <div class="preset-item-name">${name}</div>
          <div class="preset-item-desc">${truncatedDesc || '暂无描述'}</div>
          <div class="preset-item-type">${type}</div>
        </div>
        <div class="preset-item-actions">
          <button class="preset-item-btn use" onclick="usePreset('${presetId}')">使用</button>
          ${!isBuiltin ? `<button class="preset-item-btn delete" onclick="deletePreset('${presetId}')">删除</button>` : ''}
        </div>
      `;
      
      return item;
    }
    
    // 使用预设
    function usePreset(presetId) {
      if (currentPresetType === 'role') {
        let preset = null;
        if (rolePresets[presetId]) {
          preset = rolePresets[presetId];
        } else if (customRolePresets[presetId]) {
          preset = customRolePresets[presetId];
        }
        
        if (preset) {
          if (currentPresetContext === 'modal') {
            modalRoleNameInput.value = preset.displayName || preset.name;
            modalRoleDescInput.value = preset.description;
            modalRolePresetSelect.value = presetId;
          } else {
            roleNameInput.value = preset.displayName || preset.name;
            roleDescInput.value = preset.description;
            rolePresetSelect.value = presetId;
          }
          
          presetManageModal.style.display = 'none';
          alert('预设已应用！');
        }
      } else if (currentPresetType === 'user') {
        const preset = customUserPresets[presetId];
        if (preset) {
          userNameInput.value = preset.displayName || preset.name;
          userDescInput.value = preset.description;
          userAvatarInput.value = preset.avatar || '';
          userPresetSelect.value = presetId;
          
          presetManageModal.style.display = 'none';
          alert('预设已应用！');
        }
      }
    }
    
    // 删除预设
    function deletePreset(presetId) {
      if (!confirm('确定要删除这个预设吗？')) {
        return;
      }
      
      if (currentPresetType === 'role') {
        delete customRolePresets[presetId];
      } else {
        delete customUserPresets[presetId];
      }
      
      saveCustomPresets();
      updatePresetSelects();
      updatePresetList();
      
      alert('预设已删除！');
    }
    
    // 全局函数，供HTML内联事件调用
    window.usePreset = usePreset;
    window.deletePreset = deletePreset;

    // 更新聊天标题
    function updateChatHeader() {
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (currentChat) {
        // 如果有自定义标题，优先使用自定义标题
        if (currentChat.customTitle) {
          chatTitle.textContent = currentChat.customTitle;
          chatTitle.classList.add('custom-title');
        } else {
          chatTitle.classList.remove('custom-title');
          if (currentChat.type === 'group') {
            const roleCount = currentChat.roles ? currentChat.roles.length : 0;
            chatTitle.textContent = `${currentChat.name} (${roleCount}个角色)`;
          } else if (roleName) {
            chatTitle.textContent = `与${roleName}聊天`;
          } else {
            chatTitle.textContent = currentChat.name;
          }
        }
      } else {
        chatTitle.textContent = 'AI微信聊天';
        chatTitle.classList.remove('custom-title');
      }
    }

    // 清空聊天记录
    function clearChat() {
      console.log('开始清空聊天记录...');
      
      // 立即清空界面显示
      if (chatBody) {
        chatBody.innerHTML = '';
        console.log('界面已清空');
      } else {
        console.error('chatBody元素未找到');
      }
      
      // 清空AI记忆（对话历史）
      window.conversationHistory = [];
      console.log('对话历史已清空');
      
      // 清空当前聊天的记录
      if (currentChatId) {
        const currentChat = chatList.find(c => c.id === currentChatId);
        if (currentChat) {
          currentChat.conversationHistory = [];
          currentChat.chatDisplay = [];
          console.log('当前聊天记录已清空');
        }
      }
      
      // 保存当前聊天数据
      saveCurrentChatData();
      console.log('聊天数据已保存');
    }

    // 导出聊天记录
    function exportChatHistory() {
      if (!currentChatId) {
        alert('请先选择一个聊天');
        return;
      }
      
      const chat = chatList.find(c => c.id === currentChatId);
      if (!chat || chat.chatDisplay.length === 0) {
        alert('暂无聊天记录可导出');
        return;
      }
      
      const chatData = {
        conversationHistory: chat.conversationHistory,
        chatDisplay: chat.chatDisplay,
        exportTime: new Date().toISOString(),
        roleName: chat.roleName,
        userName: chat.userName,
        version: '1.0'
      };
      
      // 创建下载链接
      const dataStr = JSON.stringify(chatData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `聊天记录_${chat.name}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('聊天记录导出成功！');
    }

    // 导入聊天记录
    function importChatHistory() {
      importFileInput.click();
    }

    // 处理文件导入
    function handleFileImport(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const chatData = JSON.parse(e.target.result);
          
          // 验证数据格式
          if (!chatData.conversationHistory || !Array.isArray(chatData.conversationHistory)) {
            alert('导入失败：聊天记录格式不正确');
            return;
          }
          
          // 询问是否要替换当前聊天记录
          if (currentChatId) {
            if (!confirm('导入将替换当前聊天记录，是否继续？')) {
              return;
            }
          }
          
          // 清空当前聊天记录
          chatBody.innerHTML = '';
          window.conversationHistory = [];
          
          // 导入对话历史
          window.conversationHistory = chatData.conversationHistory;
          
          // 导入界面显示
          if (chatData.chatDisplay && chatData.chatDisplay.length > 0) {
            chatData.chatDisplay.forEach(msg => {
              if (msg.type === 'emoji') {
                appendEmojiMsg(msg.content, msg.roleId, msg.roleName, msg.timestamp);
              } else {
                appendMsg(msg.role, msg.content, false, msg.roleId, msg.roleName, msg.timestamp);
              }
            });
          } else {
            // 如果没有界面显示数据，从对话历史重建
            window.conversationHistory.forEach(msg => {
              if (msg.role === 'system') return; // 跳过系统消息
              appendMsg(msg.role === 'user' ? 'user' : 'ai', msg.content);
            });
          }
          
          // 保存到当前聊天
          saveCurrentChatData();
          
          alert(`聊天记录导入成功！共导入 ${window.conversationHistory.length} 条记录`);
          
        } catch (e) {
          console.error('导入失败:', e);
          alert('导入失败：文件格式错误或文件损坏');
        }
      };
      
      reader.readAsText(file);
      
      // 清空文件输入，允许重复导入同一文件
      event.target.value = '';
    }

    // 显示消息
    function appendMsg(role, text, isStreaming = false, roleId = null, roleName = null, timestamp = null, messageId = null, replyTo = null, isForward = false, forwardFrom = null, isChatRecord = false, chatRecordData = null, messageType = 'text') {
      const currentChat = chatList.find(c => c.id === currentChatId);
      const isGroupChat = currentChat && currentChat.type === 'group';
      
      const msgDiv = document.createElement('div');
      msgDiv.className = 'msg ' + role + (isGroupChat ? ' group' : '');
      
      // 为消息分配唯一ID
      if (!messageId) {
        messageId = generateId();
      }
      msgDiv.setAttribute('data-message-id', messageId);
      
      // 设置角色ID和名称属性，用于CSS选择器判断连续消息
      if (isGroupChat && role === 'ai' && roleId) {
        msgDiv.setAttribute('data-role-id', roleId);
        msgDiv.setAttribute('data-role-name', roleName || '');
      }
      
      // 群聊中添加角色名称显示
      if (isGroupChat && role === 'ai' && roleName) {
        // 群聊中每个AI消息都显示角色名称
        const roleNameDiv = document.createElement('div');
        roleNameDiv.className = 'role-name';
        roleNameDiv.textContent = roleName;
        msgDiv.appendChild(roleNameDiv);
      }
      
      // 创建头像元素
      const avatar = document.createElement('img');
      avatar.className = 'avatar';
      
      if (role === 'ai') {
        if (isGroupChat && roleId) {
          // 群聊中根据角色ID获取头像
          const roleData = currentChat.roles.find(r => r.id === roleId);
          avatar.src = roleData ? (roleData.avatar || DEFAULT_AI_AVATAR) : DEFAULT_AI_AVATAR;
        } else {
          avatar.src = aiAvatar;
        }
        avatar.alt = roleName || 'AI头像';
      } else {
        avatar.src = userAvatar;
        avatar.alt = '用户头像';
      }
      
      // 头像加载失败时使用默认头像
      avatar.onerror = function() {
        this.src = role === 'ai' ? DEFAULT_AI_AVATAR : DEFAULT_USER_AVATAR;
      };
      
      // 创建气泡容器
      const bubbleContainer = document.createElement('div');
      bubbleContainer.className = 'bubble-container';
      
      // 创建消息气泡
      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      
      // 处理回复引用
      if (replyTo) {
        const replyRef = document.createElement('div');
        replyRef.className = 'reply-reference';
        replyRef.innerHTML = `
          <div class="reply-from">${replyTo.fromName || (replyTo.role === 'user' ? '用户' : 'AI')}</div>
          <div class="reply-content">${replyTo.content.length > 50 ? replyTo.content.substring(0, 50) + '...' : replyTo.content}</div>
        `;
        bubble.appendChild(replyRef);
      }
      
      // 处理聊天记录消息
      if (isChatRecord && chatRecordData) {
        const chatRecordDiv = document.createElement('div');
        chatRecordDiv.className = 'chat-record';
        chatRecordDiv.setAttribute('data-chat-record-id', messageId);
        
        // 预览前3条消息
        const previewItems = chatRecordData.messages.slice(0, 3);
        const previewHtml = previewItems.map(msg => `
          <div class="chat-record-item">
            <span class="chat-record-sender">${msg.fromName}:</span>
            <span class="chat-record-text">${msg.content.length > 30 ? msg.content.substring(0, 30) + '...' : msg.content}</span>
          </div>
        `).join('');
        
        chatRecordDiv.innerHTML = `
          <div class="chat-record-header">
            <div class="chat-record-title">
              <span class="icon">💬</span>
              <span>${chatRecordData.fromChat}的聊天记录</span>
            </div>
            <div class="chat-record-count">${chatRecordData.messages.length}条消息</div>
          </div>
          <div class="chat-record-preview">
            ${previewHtml}
            ${chatRecordData.messages.length > 3 ? '<div class="chat-record-item"><span class="chat-record-text">...</span></div>' : ''}
          </div>
        `;
        
        // 添加点击事件查看详情
        chatRecordDiv.addEventListener('click', () => {
          showChatRecordDetail(chatRecordData);
        });
        
        bubble.appendChild(chatRecordDiv);
      }
      // 处理转发消息
      else if (isForward && forwardFrom) {
        const forwardDiv = document.createElement('div');
        forwardDiv.className = 'forward-message';
        forwardDiv.innerHTML = `
          <div class="forward-header">
            <span class="icon">↗️</span>
            <span>${forwardFrom.chatName}的聊天记录</span>
          </div>
          <div class="forward-from">${forwardFrom.fromName || (forwardFrom.role === 'user' ? '用户' : 'AI')}</div>
          <div class="forward-content">${text}</div>
        `;
        
        // 为转发消息添加点击回复功能
        forwardDiv.addEventListener('click', (e) => {
          e.stopPropagation();
          // 设置回复到转发的原始内容
          replyToMessage = {
            id: messageId,
            content: text,
            role: role,
            fromName: role === 'user' ? (userName || '用户') : (roleName || 'AI')
          };
          showReplyStatus();
          chatInput.focus();
        });
        
        bubble.appendChild(forwardDiv);
      } else if (messageType === 'location') {
        // 位置消息内容
        bubble.className = 'bubble location-bubble';
        bubble.innerHTML = text; // 位置消息的HTML已经是安全的
      } else if (messageType === 'emoji') {
        // 表情包消息内容
        bubble.className = 'bubble emoji-bubble';
        bubble.innerHTML = text; // 表情包消息的HTML已经是安全的
      } else if (messageType === 'transfer') {
        // 转账消息内容
        bubble.className = 'bubble transfer-bubble';
        bubble.innerHTML = text; // 转账消息的HTML已经是安全的
      } else if (messageType === 'image') {
        // 图片消息内容
        bubble.className = 'bubble image-bubble';
        bubble.innerHTML = text; // 图片消息的HTML已经是安全的
      } else {
        // 普通文本消息内容
        const contentDiv = document.createElement('div');
        if (isStreaming) {
          // 对于流式消息也安全地设置内容，转义HTML特殊字符后处理换行
          const escapedText = escapeHtml(text);
          // 处理多种换行分隔符：\n、\、/
          contentDiv.innerHTML = escapedText.replace(/(\n|\\|\/)/g, '<br>');
          bubble.setAttribute('data-streaming', 'true');
        } else {
          // 对于非流式消息，也需要处理换行符
          const escapedText = escapeHtml(text);
          // 处理多种换行分隔符：\n、\、/
          contentDiv.innerHTML = escapedText.replace(/(\n|\\|\/)/g, '<br>');
        }
        bubble.appendChild(contentDiv);
      }
      
      // 应用当前主题的气泡颜色
      if (typeof currentTheme !== 'undefined' && currentTheme) {
        bubble.style.borderRadius = `${parseFloat(currentTheme.bubbleBorderRadius)}px`;
        
        // 应用阴影
        const shadowMap = {
          'none': 'none',
          'light': '0 1px 2px rgba(0,0,0,0.1)',
          'normal': '0 2px 4px rgba(0,0,0,0.1)',
          'heavy': '0 4px 8px rgba(0,0,0,0.15)'
        };
        bubble.style.boxShadow = shadowMap[currentTheme.bubbleShadow] || shadowMap.light;
        
        // 应用边框
        const borderMap = {
          'none': 'none',
          'thin': '1px solid rgba(0,0,0,0.1)',
          'normal': '2px solid rgba(0,0,0,0.1)',
          'thick': '3px solid rgba(0,0,0,0.15)'
        };
        bubble.style.border = borderMap[currentTheme.bubbleBorder] || borderMap.none;
        
        // 应用气泡颜色
        if (role === 'user') {
          bubble.style.background = `rgba(${hexToRgb(currentTheme.userBubbleColor)}, ${parseFloat(currentTheme.bubbleOpacity)})`;
        } else {
          bubble.style.background = `rgba(${hexToRgb(currentTheme.aiBubbleColor)}, ${parseFloat(currentTheme.bubbleOpacity)})`;
        }
      }
      
      // 创建独立的时间元素（微信风格）
      const timeElement = document.createElement('div');
      timeElement.className = 'msg-time';
      const timeSpan = document.createElement('span');
      timeSpan.textContent = timestamp || formatMessageTime();
      timeElement.appendChild(timeSpan);
      
      // 将气泡添加到容器
      bubbleContainer.appendChild(bubble);
      
      msgDiv.appendChild(avatar);
      msgDiv.appendChild(bubbleContainer);
      
      // 添加消息操作菜单
      const msgMenu = document.createElement('div');
      msgMenu.className = 'msg-menu';
      
      let menuItems = `
        <div class="msg-menu-item" data-action="reply" data-message-id="${messageId}">回复</div>
        <div class="msg-menu-item" data-action="forward" data-message-id="${messageId}">转发</div>
        <div class="msg-menu-item" data-action="multiSelect" data-message-id="${messageId}">多选</div>
      `;
      
      // 如果是用户消息，添加重新生成选项（稍后会动态更新是否显示）
      if (role === 'user') {
        menuItems += `<div class="msg-menu-item regenerate" data-action="regenerate" data-message-id="${messageId}" style="display: none;">重新生成</div>`;
      }
      
      menuItems += `<div class="msg-menu-item danger" data-action="delete" data-message-id="${messageId}">删除</div>`;
      
      msgMenu.innerHTML = menuItems;
      
      // 为菜单项添加点击事件监听器
      msgMenu.addEventListener('click', function(event) {
        event.stopPropagation(); // 阻止事件冒泡
        
        const menuItem = event.target.closest('.msg-menu-item');
        if (menuItem) {
          const action = menuItem.getAttribute('data-action');
          const msgId = menuItem.getAttribute('data-message-id');
          
          // 执行对应操作
          switch(action) {
            case 'reply':
              window.replyToMsg(msgId);
              break;
            case 'forward':
              window.forwardMsg(msgId);
              break;
            case 'multiSelect':
              window.startMultiSelect(msgId);
              break;
            case 'regenerate':
              window.regenerateMsg(msgId);
              break;
            case 'delete':
              window.deleteMsg(msgId);
              break;
          }
          
          // 隐藏菜单
          hideMsgMenu();
        }
      });
      
      msgDiv.appendChild(msgMenu);
      
      // 添加长按事件监听器
      let longPressTimer;
      let startX, startY;
      
      const handleStart = (e) => {
        // 记录初始位置
        if (e.type === 'mousedown') {
          startX = e.clientX;
          startY = e.clientY;
        } else if (e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        }
        
        longPressTimer = setTimeout(() => {
          showMsgMenu(msgDiv, e);
        }, 500); // 500ms长按
      };
      
      const handleMove = (e) => {
        let currentX, currentY;
        if (e.type === 'mousemove') {
          currentX = e.clientX;
          currentY = e.clientY;
        } else if (e.type === 'touchmove') {
          currentX = e.touches[0].clientX;
          currentY = e.touches[0].clientY;
        }
        
        // 如果移动距离超过10px，取消长按
        const distance = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
        if (distance > 10) {
          clearTimeout(longPressTimer);
        }
      };
      
      const handleEnd = () => {
        clearTimeout(longPressTimer);
      };
      
      // 桌面端
      bubble.addEventListener('mousedown', handleStart);
      bubble.addEventListener('mousemove', handleMove);
      bubble.addEventListener('mouseup', handleEnd);
      bubble.addEventListener('mouseleave', handleEnd);
      
      // 移动端
      bubble.addEventListener('touchstart', handleStart);
      bubble.addEventListener('touchmove', handleMove);
      bubble.addEventListener('touchend', handleEnd);
      bubble.addEventListener('touchcancel', handleEnd);
      
      // 先添加时间，再添加消息
      chatBody.appendChild(timeElement);
      chatBody.appendChild(msgDiv);
      chatBody.scrollTop = chatBody.scrollHeight;
      
      // 如果是用户消息，需要更新所有用户消息的重新生成按钮显示状态
      if (role === 'user') {
        // 使用setTimeout确保DOM已经完全更新
        setTimeout(() => {
          updateRegenerateButtons();
        }, 0);
      }
      
      return bubble; // 返回bubble元素，用于流式更新
    }



    // HTML转义函数，防止HTML注入
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // 更新流式消息
    function updateStreamingMsg(bubble, text, isFirstChunk = false) {
      if (bubble) {
        // 如果是第一个数据块且有内容，清空初始的"正在回复..."提示
        if (isFirstChunk && text.trim()) {
          // 只清空内容div，保留回复引用
          const contentDiv = bubble.querySelector('div:not(.reply-reference)');
          if (contentDiv) {
            contentDiv.innerHTML = '';
          } else {
            bubble.innerHTML = '';
          }
        }
        
        // 更新内容div或直接更新bubble
        const contentDiv = bubble.querySelector('div:not(.reply-reference)');
        if (contentDiv) {
          // 安全地设置文本内容，转义HTML特殊字符后处理换行
          const escapedText = escapeHtml(text);
          // 处理多种换行分隔符：\n、\、/
          contentDiv.innerHTML = escapedText.replace(/(\n|\\|\/)/g, '<br>');
        } else {
          // 安全地设置文本内容，转义HTML特殊字符后处理换行
          const escapedText = escapeHtml(text);
          // 处理多种换行分隔符：\n、\、/
          bubble.innerHTML = escapedText.replace(/(\n|\\|\/)/g, '<br>');
        }
        
        chatBody.scrollTop = chatBody.scrollHeight;
      }
    }

    // 完成流式消息
    function finishStreamingMsg(bubble) {
      if (bubble) {
        bubble.removeAttribute('data-streaming');
      }
    }

    // 处理流式响应 - 支持多气泡输出
    async function handleStreamResponse(response, initialBubble, roleId = null, roleName = null) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let fullContent = '';
      let hasContent = false;
      let currentBubble = initialBubble;
      let currentBubbleContent = '';
      let bubbleCount = 1;
      const maxBubblesCount = 5; // 最多5个气泡
      const minCharsPerBubble = 80; // 每个气泡最少字符数
      const maxCharsPerBubble = 200; // 每个气泡最多字符数

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // 保留不完整的行

          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine) continue;

            if (trimmedLine.startsWith('data: ')) {
              const data = trimmedLine.slice(6).trim();
              if (data === '[DONE]') {
                if (currentBubbleContent.trim()) {
                  updateStreamingMsg(currentBubble, currentBubbleContent);
                }
                finishStreamingMsg(currentBubble);
                return fullContent;
              }

              try {
                const parsed = JSON.parse(data);
                const content = parsed.choices?.[0]?.delta?.content || '';
                if (content) {
                  const isFirstContent = !hasContent;
                  fullContent += content;
                  hasContent = true;
                  
                  // 清空初始提示
                  if (isFirstContent) {
                    currentBubbleContent = '';
                  }
                  
                                    currentBubbleContent += content;
                  
                  // 检查是否包含换行符\n作为换行标记
                  const newlineIndex = currentBubbleContent.indexOf('\\n');
                  if (newlineIndex !== -1 && bubbleCount < maxBubblesCount) {
                    // 分割内容：换行符前的部分作为当前气泡，后面的作为新气泡
                    const currentPart = currentBubbleContent.substring(0, newlineIndex).trim();
                    const remainingPart = currentBubbleContent.substring(newlineIndex + 2).trim();
                    
                    if (currentPart) {
                      updateStreamingMsg(currentBubble, currentPart);
                      finishStreamingMsg(currentBubble);
                      
                      // 添加短暂延迟，让气泡切换更自然
                      await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 500));
                      
                      // 创建新气泡
                      bubbleCount++;
                      const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
                      currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
                      currentBubbleContent = remainingPart;
                      
                      // 如果有剩余内容，立即显示
                      if (remainingPart) {
                        updateStreamingMsg(currentBubble, remainingPart, true);
                      }
                    } else {
                      // 如果当前气泡没有内容，只是移除换行符
                      currentBubbleContent = remainingPart;
                      if (remainingPart) {
                        updateStreamingMsg(currentBubble, remainingPart, isFirstContent);
                      }
                    }
                    continue; // 跳过后面的正常处理逻辑
                  }
                  
                  // 检查是否包含单独的反斜杠"\"作为换行标记
                  const backslashIndex = currentBubbleContent.indexOf('\\');
                  if (backslashIndex !== -1 && bubbleCount < maxBubblesCount) {
                    // 检查是否是单独的反斜杠（前后不是字母数字或其他转义字符）
                    const isStandaloneBackslash = checkStandaloneBackslash(currentBubbleContent, backslashIndex);
                    
                    if (isStandaloneBackslash) {
                      // 分割内容：反斜杠前的部分作为当前气泡，后面的作为新气泡
                      const currentPart = currentBubbleContent.substring(0, backslashIndex).trim();
                      const remainingPart = currentBubbleContent.substring(backslashIndex + 1).trim();
                      
                      if (currentPart) {
                        updateStreamingMsg(currentBubble, currentPart);
                        finishStreamingMsg(currentBubble);
                        
                        // 添加短暂延迟，让气泡切换更自然
                        await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 500));
                        
                        // 创建新气泡
                        bubbleCount++;
                        const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
                        currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
                        currentBubbleContent = remainingPart;
                        
                        // 如果有剩余内容，立即显示
                        if (remainingPart) {
                          updateStreamingMsg(currentBubble, remainingPart, true);
                        }
                      } else {
                        // 如果当前气泡没有内容，只是移除反斜杠
                        currentBubbleContent = remainingPart;
                        if (remainingPart) {
                          updateStreamingMsg(currentBubble, remainingPart, isFirstContent);
                        }
                      }
                      continue; // 跳过后面的正常处理逻辑
                    }
                  }
                  
                  // 检查是否包含完整的括号对作为单独气泡
                  const bracketSplit = findCompleteBracketForSeparation(currentBubbleContent);
                  if (bracketSplit && bubbleCount < maxBubblesCount - 1) { // 需要留两个气泡位置
                    // 分割内容：括号前的内容 + 括号内容 + 括号后的内容
                    const beforeBracket = currentBubbleContent.substring(0, bracketSplit.startIndex).trim();
                    const bracketContent = currentBubbleContent.substring(bracketSplit.startIndex, bracketSplit.endIndex + 1).trim();
                    const afterBracket = currentBubbleContent.substring(bracketSplit.endIndex + 1).trim();
                    
                    // 先处理括号前的内容
                    if (beforeBracket) {
                      updateStreamingMsg(currentBubble, beforeBracket);
                      finishStreamingMsg(currentBubble);
                      
                      // 添加延迟
                      await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 500));
                      
                      // 创建新气泡显示括号内容
                      bubbleCount++;
                      const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
                      currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
                    }
                    
                    // 显示括号内容
                    updateStreamingMsg(currentBubble, bracketContent, !beforeBracket);
                    finishStreamingMsg(currentBubble);
                    
                    // 如果有括号后的内容，创建新气泡
                    if (afterBracket) {
                      await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 500));
                      
                      bubbleCount++;
                      const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
                      currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
                      currentBubbleContent = afterBracket;
                      
                      updateStreamingMsg(currentBubble, afterBracket, true);
                    } else {
                      // 没有后续内容，重置为空
                      currentBubbleContent = '';
                    }
                    
                    continue; // 跳过后面的正常处理逻辑
                  }
                  
                  // 检查是否需要创建新气泡（原有的自动拆分逻辑）
                  const shouldCreateNewBubble = checkShouldCreateNewBubble(
                    currentBubbleContent, 
                    bubbleCount, 
                    maxBubblesCount, 
                    minCharsPerBubble, 
                    maxCharsPerBubble
                  );
                  
                  if (shouldCreateNewBubble && bubbleCount < maxBubblesCount) {
                    // 完成当前气泡
                    const splitPoint = findBestSplitPoint(currentBubbleContent);
                    const currentPart = currentBubbleContent.substring(0, splitPoint).trim();
                    const remainingPart = currentBubbleContent.substring(splitPoint).trim();
                    
                    if (currentPart) {
                      updateStreamingMsg(currentBubble, currentPart);
                      finishStreamingMsg(currentBubble);
                      
                      // 添加短暂延迟，让气泡切换更自然
                      await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 500));
                      
                      // 创建新气泡
                      bubbleCount++;
                      const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
                      currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
                      currentBubbleContent = remainingPart;
                      
                      // 如果有剩余内容，立即显示
                      if (remainingPart) {
                        updateStreamingMsg(currentBubble, remainingPart, true);
                      }
                    }
                  } else {
                    // 更新当前气泡
                    updateStreamingMsg(currentBubble, currentBubbleContent, isFirstContent);
                  }
                }
              } catch (e) {
                // 忽略解析错误，继续处理下一行
                console.warn('解析流式数据失败:', data);
              }
            }
          }
        }
      } catch (error) {
        console.error('流式处理错误:', error);
        if (!hasContent) {
          updateStreamingMsg(currentBubble, '流式接收出现错误，请重试。');
        } else {
          updateStreamingMsg(currentBubble, currentBubbleContent + '\n\n[流式传输中断]');
        }
      } finally {
        finishStreamingMsg(currentBubble);
      }

      return fullContent || '流式响应为空';
    }

    // 处理非流式响应的反斜杠和括号分割
    async function handleNonStreamResponse(content, initialBubble, roleId = null, roleName = null) {
      // 查找所有分割点（反斜杠和括号）
      const splitPoints = [];
      
      // 查找所有换行符\n位置
      for (let i = 0; i < content.length - 1; i++) {
        if (content[i] === '\\' && content[i + 1] === 'n') {
          splitPoints.push({ index: i, type: 'newline' });
        }
      }
      
      // 查找所有单独的反斜杠位置
      for (let i = 0; i < content.length; i++) {
        if (content[i] === '\\' && checkStandaloneBackslash(content, i)) {
          splitPoints.push({ index: i, type: 'backslash' });
        }
      }
      
      // 查找所有完整的括号对用于分离
      const brackets = {
        '(': ')',
        '[': ']',
        '{': '}',
        '（': '）'
      };
      
      const openBrackets = Object.keys(brackets);
      const stack = [];
      
      for (let i = 0; i < content.length; i++) {
        const char = content[i];
        
        if (openBrackets.includes(char)) {
          stack.push({ type: char, index: i });
        } else if (Object.values(brackets).includes(char)) {
          if (stack.length > 0) {
            const lastOpen = stack[stack.length - 1];
            if (brackets[lastOpen.type] === char) {
              stack.pop();
              
              if (stack.length === 0) {
                const bracketContent = content.substring(lastOpen.index + 1, i);
                if (bracketContent.trim().length >= 3) {
                  // 添加括号开始和结束点
                  splitPoints.push({ 
                    index: lastOpen.index, 
                    type: 'bracket_start',
                    endIndex: i
                  });
                  splitPoints.push({ 
                    index: i, 
                    type: 'bracket_end',
                    startIndex: lastOpen.index
                  });
                }
              }
            }
          }
        }
      }
      
      // 按位置排序分割点
      splitPoints.sort((a, b) => a.index - b.index);
      
      if (splitPoints.length === 0) {
        // 没有分割点，正常显示
        updateStreamingMsg(initialBubble, content);
        finishStreamingMsg(initialBubble);
        return;
      }
      
      // 根据分割点分割内容
      let currentBubble = initialBubble;
      let startIndex = 0;
      let i = 0;
      
      while (i < splitPoints.length) {
        const splitPoint = splitPoints[i];
        
        if (splitPoint.type === 'bracket_start') {
          // 处理括号前的内容
          const beforeBracket = content.substring(startIndex, splitPoint.index).trim();
          if (beforeBracket) {
            updateStreamingMsg(currentBubble, beforeBracket);
            finishStreamingMsg(currentBubble);
            
            await new Promise(resolve => setTimeout(resolve, 500));
            const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
            currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
          }
          
          // 处理括号内容（单独成为一个气泡）
          const bracketContent = content.substring(splitPoint.index, splitPoint.endIndex + 1).trim();
          updateStreamingMsg(currentBubble, bracketContent, !beforeBracket);
          finishStreamingMsg(currentBubble);
          
          // 跳过bracket_end点
          i += 2;
          startIndex = splitPoint.endIndex + 1;
          
          // 如果还有内容，创建新气泡
          if (startIndex < content.length) {
            await new Promise(resolve => setTimeout(resolve, 500));
            const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
            currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
          }
        } else if (splitPoint.type === 'newline') {
          // 处理换行符分割
          const part = content.substring(startIndex, splitPoint.index).trim();
          if (part) {
            updateStreamingMsg(currentBubble, part);
            finishStreamingMsg(currentBubble);
            
            await new Promise(resolve => setTimeout(resolve, 500));
            const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
            currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
          }
          
          startIndex = splitPoint.index + 2; // 跳过\n（2个字符）
          i++;
        } else if (splitPoint.type === 'backslash') {
          // 处理反斜杠分割
          const part = content.substring(startIndex, splitPoint.index).trim();
          if (part) {
            updateStreamingMsg(currentBubble, part);
            finishStreamingMsg(currentBubble);
            
            await new Promise(resolve => setTimeout(resolve, 500));
            const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
            currentBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
          }
          
          startIndex = splitPoint.index + 1;
          i++;
        } else {
          i++;
        }
      }
      
      // 处理最后一部分内容
      const lastPart = content.substring(startIndex).trim();
      if (lastPart) {
        updateStreamingMsg(currentBubble, lastPart);
        finishStreamingMsg(currentBubble);
      } else if (currentBubble) {
        finishStreamingMsg(currentBubble);
      }
    }

    // 检查是否为单独的反斜杠（用于换行标记）
    function checkStandaloneBackslash(content, backslashIndex) {
      const prevChar = backslashIndex > 0 ? content[backslashIndex - 1] : '';
      const nextChar = backslashIndex < content.length - 1 ? content[backslashIndex + 1] : '';
      
      // 简单规则：如果反斜杠前后不是字母或数字，则认为是单独的反斜杠
      // 排除常见的转义序列如 \n \t \r 等
      const isEscapeChar = /[nrtbfav'"\\0-9xuU]/.test(nextChar);
      const isInWord = /[a-zA-Z0-9]/.test(prevChar) || /[a-zA-Z0-9]/.test(nextChar);
      
      // 如果不是转义字符且不在单词中，则认为是单独的反斜杠
      return !isEscapeChar && !isInWord;
    }

    // 查找完整的括号对用于分离成单独气泡
    function findCompleteBracketForSeparation(content) {
      const brackets = {
        '(': ')',
        '[': ']',
        '{': '}',
        '（': '）' // 中文括号
      };
      
      const openBrackets = Object.keys(brackets);
      const stack = [];
      
      for (let i = 0; i < content.length; i++) {
        const char = content[i];
        
        // 如果是开括号，压入栈
        if (openBrackets.includes(char)) {
          stack.push({ type: char, index: i });
        }
        // 如果是闭括号，检查是否匹配
        else if (Object.values(brackets).includes(char)) {
          if (stack.length > 0) {
            const lastOpen = stack[stack.length - 1];
            if (brackets[lastOpen.type] === char) {
              stack.pop();
              
              // 如果栈为空，说明找到了一个完整的括号对
              if (stack.length === 0) {
                // 检查括号内容是否有意义（至少3个字符）
                const bracketContent = content.substring(lastOpen.index + 1, i);
                if (bracketContent.trim().length >= 3) {
                  return {
                    startIndex: lastOpen.index,
                    endIndex: i,
                    bracketType: lastOpen.type,
                    content: bracketContent
                  };
                }
              }
            }
          }
        }
      }
      
      return null; // 没有找到合适的分割点
    }

    // 检查是否应该创建新气泡
    function checkShouldCreateNewBubble(content, currentBubbleCount, maxBubbles, minChars, maxChars) {
      if (currentBubbleCount >= maxBubbles) return false;
      if (content.length < minChars) return false;
      
      // 如果内容太长，强制拆分
      if (content.length > maxChars) return true;
      
      // 检查是否有合适的断点（句号、问号、感叹号后有空格或换行）
      const sentenceEndPattern = /[。！？.!?]\s*[\n\r]/;
      if (sentenceEndPattern.test(content) && content.length >= minChars) {
        return true;
      }
      
      // 检查双换行符（段落分隔）
      if (content.includes('\n\n') && content.length >= minChars) {
        return true;
      }
      
      return false;
    }

    // 找到最佳的拆分点
    function findBestSplitPoint(content) {
      const length = content.length;
      
      // 优先在句号、问号、感叹号后面拆分
      const sentenceEndPattern = /[。！？.!?]\s*/g;
      let match;
      let lastGoodSplit = 0;
      
      while ((match = sentenceEndPattern.exec(content)) !== null) {
        const splitPoint = match.index + match[0].length;
        if (splitPoint >= 60 && splitPoint < length - 20) { // 避免拆分点太前或太后
          lastGoodSplit = splitPoint;
        }
      }
      
      if (lastGoodSplit > 0) {
        return lastGoodSplit;
      }
      
      // 在双换行符处拆分
      const doubleNewlineIndex = content.indexOf('\n\n');
      if (doubleNewlineIndex > 60 && doubleNewlineIndex < length - 20) {
        return doubleNewlineIndex + 2;
      }
      
      // 在单换行符处拆分
      const newlineIndex = content.lastIndexOf('\n', Math.floor(length * 0.7));
      if (newlineIndex > 50) {
        return newlineIndex + 1;
      }
      
      // 在逗号后拆分
      const commaPattern = /[，,]\s*/g;
      let commaMatch;
      let lastCommaSplit = 0;
      
      while ((commaMatch = commaPattern.exec(content)) !== null) {
        const splitPoint = commaMatch.index + commaMatch[0].length;
        if (splitPoint >= 80 && splitPoint < length - 30) {
          lastCommaSplit = splitPoint;
        }
      }
      
      if (lastCommaSplit > 0) {
        return lastCommaSplit;
      }
      
      // 默认在70%位置拆分
      return Math.floor(length * 0.7);
    }

    // 构建消息历史
    function buildMessages(userMessage) {
      let messages = [];
      
      // 构建系统提示
      let systemPrompts = [];
      
      // 先添加AI角色设定
      if (roleDescription) {
        const rolePrompt = roleName ? 
          `你现在要扮演一个角色，角色名字是"${roleName}"。角色设定如下：${roleDescription}` :
          `角色设定如下：${roleDescription}`;
        systemPrompts.push(rolePrompt);
      }
      
      // 添加用户设定
      if (userDescription) {
        const userPrompt = userName ? 
          `对话的用户名字是"${userName}"，用户信息如下：${userDescription}。请根据用户设定调整你的互动方式。` :
          `对话的用户信息如下：${userDescription}。请根据用户设定调整你的互动方式。`;
        systemPrompts.push(userPrompt);
      } else if (userName) {
        systemPrompts.push(`对话的用户名字是"${userName}"。`);
      }
      
      // 添加气泡分割说明和回复格式要求
      const bubbleSplitPrompt = `=== 重要：回复格式要求（必须严格遵循）===
1. 用（）包裹动作描述
2. 严格遵循使用反斜线\\分隔句子的要求，每个句子控制在50字以内
3. 回复输出示例格式：第一句话\\第二句话\\第三句话

对话示例：
用户：今天天气怎么样？
AI回复：今天天气不错呢\\要不要一起出去走走？

用户：你在做什么？
AI回复：刚刚在看书\\一本关于历史的书籍\\很有趣呢

用户：你好可爱
AI回复：(害羞地低下头)谢谢夸奖\\人家会不好意思的

用户：拍了拍你
AI回复：(轻轻拍回去)你也拍拍我呀\\我们一起玩

请严格按照以上格式要求回复，这是必须遵循的规则。`;
      systemPrompts.push(bubbleSplitPrompt);

      // 最后添加预设提示词（优先级最高，离用户消息最近）
      if (aiCustomPrompt) {
        systemPrompts.push('=== 重要约束条件 ===');
        systemPrompts.push(aiCustomPrompt);
        systemPrompts.push('请严格遵守以上约束条件，这些条件具有最高优先级。');
        console.log('🎯 单聊预设提示词已添加（最高优先级）:', aiCustomPrompt.substring(0, 100) + (aiCustomPrompt.length > 100 ? '...' : ''));
      } else {
        console.log('⚠️ 单聊预设提示词为空或未设置');
      }
      
      // 如果有系统提示，添加到消息中
      if (systemPrompts.length > 0) {
        const systemContent = systemPrompts.join('\n\n');
        messages.push({
          role: "system",
          content: systemContent
        });
        console.log('📋 单聊系统提示构建完成，共', systemPrompts.length, '个部分，总长度:', systemContent.length);
        console.log('📋 系统提示内容预览:', systemContent.substring(0, 200) + (systemContent.length > 200 ? '...' : ''));
      } else {
        console.log('⚠️ 单聊没有系统提示');
      }
      
      // 添加对话历史（根据用户设置的上下文长度）
      const maxHistory = aiContextLength * 2; // 每轮对话包含用户消息和AI回复，所以乘以2
      const recentHistory = window.conversationHistory.slice(-maxHistory);
      messages = messages.concat(recentHistory);
      
      // 添加当前用户消息
      messages.push({
        role: "user",
        content: userMessage
      });
      
      return messages;
    }

    // 表情包管理功能
    function saveEmojiData() {
      localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
    }

    function updateEmojiGallery() {
      emojiGallery.innerHTML = '';
      
      // 确保表情包数据存在
      if (!emojiData || Object.keys(emojiData).length === 0) {
        emojiData = JSON.parse(JSON.stringify(DEFAULT_EMOJIS));
        localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
      }
      
      const emojis = emojiData[currentEmotion] || [];
      
      emojis.forEach((emoji, index) => {
        const emojiItem = document.createElement('div');
        emojiItem.className = 'emoji-item';
        emojiItem.innerHTML = `
          <img src="${emoji}" alt="表情包" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='none';">
          <button class="delete-btn" onclick="deleteEmoji(${index})">×</button>
        `;
        emojiGallery.appendChild(emojiItem);
      });
      
      if (emojis.length === 0) {
        const noDataDiv = document.createElement('div');
        noDataDiv.style.cssText = 'grid-column: 1/-1; text-align: center; color: #666; padding: 20px;';
        noDataDiv.innerHTML = `
          <div style="margin-bottom: 10px;">暂无${getEmotionName(currentEmotion)}表情包</div>
          <button onclick="resetEmojiData()" style="padding: 8px 16px; background: #6DA3BD; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px;">🔄 恢复默认表情包</button>
        `;
        emojiGallery.appendChild(noDataDiv);
      }
    }
    
    // 获取情绪中文名称
    function getEmotionName(emotion) {
      const names = {
        happy: '开心',
        sad: '伤心', 
        angry: '生气',
        confused: '疑惑',
        love: '喜欢'
      };
      return names[emotion] || emotion;
    }
    
    // 重置表情包数据
    function resetEmojiData() {
      if (confirm('确定要恢复默认表情包数据吗？\n\n⚠️ 这将覆盖所有自定义表情包，此操作不可撤销。')) {
        emojiData = JSON.parse(JSON.stringify(DEFAULT_EMOJIS));
        localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
        
        // 重新设置当前情绪为开心，确保显示
        currentEmotion = 'happy';
        document.querySelectorAll('.emotion-tab').forEach(tab => {
          tab.classList.remove('active');
          if (tab.dataset.emotion === 'happy') {
            tab.classList.add('active');
          }
        });
        
        updateEmojiGallery();
        
        // 显示成功提示
        const successDiv = document.createElement('div');
        successDiv.style.cssText = `
          position: fixed; 
          top: 50%; 
          left: 50%; 
          transform: translate(-50%, -50%); 
          background: #4CAF50; 
          color: white; 
          padding: 16px 24px; 
          border-radius: 8px; 
          box-shadow: 0 4px 12px rgba(0,0,0,0.3); 
          z-index: 10000;
          font-size: 16px;
        `;
        successDiv.innerHTML = '✅ 默认表情包已恢复！';
        document.body.appendChild(successDiv);
        
        // 3秒后自动隐藏提示
        setTimeout(() => {
          if (successDiv.parentNode) {
            successDiv.parentNode.removeChild(successDiv);
          }
        }, 3000);
        
        console.log('表情包数据已重置为默认值:', emojiData);
      }
    }

    // 位置管理功能
    function showLocationModal() {
      // 重置表单为当前位置数据
      locationNameInput.value = currentLocationData.name;
      locationAddressInput.value = currentLocationData.address;
      locationPreviewImage.src = currentLocationData.image;
      locationPreviewName.textContent = currentLocationData.name;
      locationPreviewAddress.textContent = currentLocationData.address;
      
      // 显示弹窗
      locationModal.classList.add('show');
      document.body.style.overflow = 'hidden';
    }

    function hideLocationModal() {
      locationModal.classList.remove('show');
      document.body.style.overflow = '';
    }

    function updateLocationPreview() {
      const name = locationNameInput.value.trim() || '我的位置';
      const address = locationAddressInput.value.trim() || '请编辑位置信息';
      
      locationPreviewName.textContent = name;
      locationPreviewAddress.textContent = address;
      
      // 更新当前位置数据
      currentLocationData.name = name;
      currentLocationData.address = address;
    }

    function handleLocationImageUpload(file) {
      if (!file) return;
      
      // 验证文件类型
      if (!file.type.startsWith('image/')) {
        alert('请选择图片文件');
        return;
      }
      
      // 验证文件大小（5MB）
      if (file.size > 5 * 1024 * 1024) {
        alert('图片文件不能超过5MB');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const imageUrl = e.target.result;
        locationPreviewImage.src = imageUrl;
        currentLocationData.image = imageUrl;
        
        // 更新上传区域样式
        locationImageUpload.classList.add('has-image');
        locationImageUpload.innerHTML = `<img src="${imageUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 8px;">`;
      };
      reader.readAsDataURL(file);
    }

    function sendLocationMessage() {
      if (!currentLocationData.name.trim()) {
        alert('请输入位置名称');
        return;
      }
      
      // 创建位置消息HTML
      const locationHtml = `
        <div class="location-container" onclick="showLocationDetail('${currentLocationData.name}', '${currentLocationData.address}', '${currentLocationData.image}')">
          <img class="location-image" src="${currentLocationData.image}" alt="位置图片" loading="lazy">
          <div class="location-icon">📍</div>
          <div class="location-info">
            <div class="location-name">${escapeHtml(currentLocationData.name)}</div>
            <div class="location-address">${escapeHtml(currentLocationData.address)}</div>
          </div>
        </div>
      `;
      
      // 发送位置消息
      appendMsg('user', locationHtml, false, null, null, null, null, null, false, null, false, null, 'location');
      
      // 保存当前位置数据到localStorage
      localStorage.setItem('aiChatLocation', JSON.stringify(currentLocationData));
      
      // 隐藏弹窗
      hideLocationModal();
      
      // 清空输入框
      chatInput.value = '';
      
      // 触发AI回复
      setTimeout(() => {
        handleAILocationReply(currentLocationData);
      }, 500);
    }

    function showLocationDetail(name, address, image) {
      // 显示位置详情（可以打开地图或其他操作）
      const modal = document.createElement('div');
      modal.className = 'location-detail-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
      `;
      
      modal.innerHTML = `
        <div style="background: white; border-radius: 12px; max-width: 400px; width: 90%; overflow: hidden;">
          <img src="${image}" style="width: 100%; height: 200px; object-fit: cover;">
          <div style="padding: 20px;">
            <h3 style="margin: 0 0 10px; font-size: 18px; color: #333;">${escapeHtml(name)}</h3>
            <p style="margin: 0 0 20px; color: #666; line-height: 1.4;">${escapeHtml(address)}</p>
            <button onclick="this.closest('.location-detail-modal').remove(); document.body.style.overflow='';" 
                    style="background: #6DA3BD; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; width: 100%;">
              关闭
            </button>
          </div>
        </div>
      `;
      
      modal.onclick = function(e) {
        if (e.target === modal) {
          modal.remove();
          document.body.style.overflow = '';
        }
      };
      
      document.body.appendChild(modal);
      document.body.style.overflow = 'hidden';
    }

    async function handleAILocationReply(locationData) {
      if (!apiURL || !apiKey || !selectedModel) {
        console.log('API未配置，跳过AI位置回复');
        return;
      }
      
      const chat = chatList.find(c => c.id === currentChatId);
      if (!chat) return;
      
      try {
        // 构建位置相关的回复提示
        const locationPrompt = `用户分享了一个位置：${locationData.name}（${locationData.address}）。请对这个位置进行简短的评论或回应，可以询问相关信息或表达关心。回复要自然、友好，不超过50字。

如果你想发送多条消息（分成多个气泡显示），请使用反斜杠 \\ 来分割不同的内容。
示例：哇这个地方不错呢\\你是要去那里吗？`;
        
        // 根据聊天类型处理回复
        if (chat.isGroup) {
          // 群聊：让所有角色都有机会回复
          await handleGroupChatLocationReply(chat, locationPrompt);
        } else {
          // 单聊：当前角色回复
          await handleSingleChatLocationReply(chat, locationPrompt);
        }
      } catch (error) {
        console.error('AI位置回复失败:', error);
      }
    }

    async function handleGroupChatLocationReply(chat, locationPrompt) {
      // 获取群聊设置
      const maxRoles = chat.maxRolesPerReply || 3;
      const shouldAllReply = chat.shouldAllReply || false;
      
      let selectedRoles = [];
      
      if (shouldAllReply) {
        selectedRoles = [...chat.roles];
      } else {
        // 随机选择角色回复
        const shuffledRoles = [...chat.roles].sort(() => Math.random() - 0.5);
        const replyCount = Math.min(Math.floor(Math.random() * maxRoles) + 1, shuffledRoles.length);
        selectedRoles = shuffledRoles.slice(0, replyCount);
      }
      
      // 让选中的角色依次回复
      for (let i = 0; i < selectedRoles.length; i++) {
        const role = selectedRoles[i];
        const delay = i * 1000; // 每个角色间隔1秒回复
        
        setTimeout(async () => {
                     try {
             const messages = [{
               role: 'system',
               content: role.description
             }, {
               role: 'user',
               content: locationPrompt
             }];
             const aiReply = await callChatAPI(messages);
             if (aiReply) {
               appendMsg('ai', aiReply, false, role.id, role.name);
               saveCurrentChatData();
             }
           } catch (error) {
             console.error(`角色 ${role.name} 位置回复失败:`, error);
           }
        }, delay);
      }
    }

    async function handleSingleChatLocationReply(chat, locationPrompt) {
      const rolePrompt = `${roleDescription}\n\n${locationPrompt}`;
      const singleRoleId = `single_${chat.id}`;
      const singleRoleName = chat.roleName || roleName || '助手';
      
      try {
        const messages = [{
          role: 'system',
          content: roleDescription
        }, {
          role: 'user',
          content: locationPrompt
        }];
        const aiReply = await callChatAPI(messages);
        if (aiReply) {
          // 处理反斜杠分割，显示多条消息
          const replyTexts = aiReply.split('\\').map(text => text.trim()).filter(text => text.length > 0);
          
          for (let i = 0; i < replyTexts.length; i++) {
            setTimeout(() => {
              appendMsg('ai', replyTexts[i], false, singleRoleId, singleRoleName);
              if (i === replyTexts.length - 1) {
                saveCurrentChatData();
              }
            }, i * 800); // 每个气泡间隔800ms
          }
        }
      } catch (error) {
        console.error('单聊位置回复失败:', error);
      }
    }

    // 加载保存的位置数据
    function loadLocationData() {
      const saved = localStorage.getItem('aiChatLocation');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          currentLocationData = { ...currentLocationData, ...data };
        } catch (error) {
          console.error('加载位置数据失败:', error);
        }
      }
    }

    // 转账管理功能
    function showTransferModal() {
      // 获取当前聊天的收款人信息
      const currentChat = chatList.find(c => c.id === currentChatId);
      let receiverName = '未知收款人';
      
      if (currentChat) {
        if (currentChat.isGroup) {
          receiverName = currentChat.title || '群聊';
        } else {
          receiverName = currentChat.roleName || roleName || '助手';
        }
      }
      
      // 重置表单
      transferAmountInput.value = '';
      transferNoteInput.value = '';
      transferReceiverInput.value = receiverName;
      currentTransferData.receiver = receiverName;
      
      updateTransferPreview();
      
      // 显示弹窗
      transferModal.classList.add('show');
      document.body.style.overflow = 'hidden';
      
      // 聚焦到金额输入框
      setTimeout(() => {
        transferAmountInput.focus();
      }, 100);
    }

    function hideTransferModal() {
      transferModal.classList.remove('show');
      document.body.style.overflow = '';
    }

    function updateTransferPreview() {
      const amount = parseFloat(transferAmountInput.value) || 0;
      const note = transferNoteInput.value.trim() || '转账';
      
      // 格式化金额显示
      const formattedAmount = amount > 0 ? `¥${amount.toFixed(2)}` : '¥0.00';
      transferPreviewAmount.textContent = formattedAmount;
      transferPreviewNote.textContent = note;
      
      // 更新当前转账数据
      currentTransferData.amount = amount;
      currentTransferData.note = note;
      
      // 更新发送按钮状态
      transferSendBtn.disabled = amount <= 0;
    }

    function sendTransferMessage() {
      const amount = parseFloat(transferAmountInput.value);
      
      if (!amount || amount <= 0) {
        alert('请输入有效的转账金额');
        return;
      }
      
      if (amount > 99999) {
        alert('转账金额不能超过99999元');
        return;
      }
      
      const note = transferNoteInput.value.trim() || '转账';
      const receiver = transferReceiverInput.value.trim();
      
      // 创建转账消息HTML
      const transferHtml = `
        <div class="transfer-container" onclick="showTransferDetail(${amount}, '${escapeHtml(note)}', '${escapeHtml(receiver)}')">
          <div class="transfer-header">
            <div class="transfer-title">
              <span class="transfer-icon">💰</span>
              <span>转账</span>
            </div>
            <div class="transfer-subtitle">向 ${escapeHtml(receiver)} 转账</div>
          </div>
          <div class="transfer-body">
            <div class="transfer-amount">¥${amount.toFixed(2)}</div>
            <div class="transfer-note">${escapeHtml(note)}</div>
            <div class="transfer-status">
              <div class="transfer-status-icon">✓</div>
              <span>转账成功</span>
            </div>
          </div>
        </div>
      `;
      
      // 发送转账消息
      appendMsg('user', transferHtml, false, null, null, null, null, null, false, null, false, null, 'transfer');
      
      // 保存转账数据
      currentTransferData.amount = amount;
      currentTransferData.note = note;
      currentTransferData.receiver = receiver;
      
      // 隐藏弹窗
      hideTransferModal();
      
      // 清空输入框
      chatInput.value = '';
      
      // 触发AI回复
      setTimeout(() => {
        handleAITransferReply(currentTransferData);
      }, 500);
    }

    function showTransferDetail(amount, note, receiver) {
      // 显示转账详情（可以添加更多功能）
      const modal = document.createElement('div');
      modal.className = 'transfer-detail-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
      `;
      
      modal.innerHTML = `
        <div style="background: white; border-radius: 12px; max-width: 350px; width: 90%; overflow: hidden;">
          <div style="background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%); color: white; padding: 20px; text-align: center;">
            <div style="font-size: 24px; margin-bottom: 8px;">💰</div>
            <div style="font-size: 18px; font-weight: 600; margin-bottom: 4px;">转账详情</div>
            <div style="font-size: 14px; opacity: 0.9;">向 ${escapeHtml(receiver)} 转账</div>
          </div>
          <div style="padding: 20px;">
            <div style="text-align: center; margin-bottom: 20px;">
              <div style="font-size: 32px; font-weight: 700; color: #ff6b35; margin-bottom: 8px;">¥${amount.toFixed(2)}</div>
              <div style="font-size: 14px; color: #666; margin-bottom: 12px;">${escapeHtml(note)}</div>
              <div style="font-size: 12px; color: #999;">转账时间：${new Date().toLocaleString()}</div>
            </div>
            <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 20px;">
              <div style="font-size: 12px; color: #666; margin-bottom: 4px;">转账状态</div>
              <div style="font-size: 14px; color: #28a745; font-weight: 500;">✓ 转账成功</div>
            </div>
            <button onclick="this.closest('.transfer-detail-modal').remove(); document.body.style.overflow='';" 
                    style="background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; width: 100%; font-size: 16px;">
              关闭
            </button>
          </div>
        </div>
      `;
      
      modal.onclick = function(e) {
        if (e.target === modal) {
          modal.remove();
          document.body.style.overflow = '';
        }
      };
      
      document.body.appendChild(modal);
      document.body.style.overflow = 'hidden';
    }
    
    // 发送图片消息
    async function sendImageMessage(imageFile, imageText = '') {
      if (!imageFile) {
        console.error('没有选择图片文件');
        return;
      }
      
      try {
        // 验证图片文件
        if (!validateImageFile(imageFile)) {
          return;
        }
        
        // 压缩图片
        const compressedBase64 = await compressImage(imageFile, 800, 600, 0.8);
        
        // 构建图片消息HTML
        const imageHtml = `
          <div class="image-message">
            <img src="${compressedBase64}" alt="用户发送的图片" onclick="showImagePreview('${compressedBase64}')">
            ${imageText ? `<div class="image-message-text">${escapeHtml(imageText)}</div>` : ''}
          </div>
        `;
        
        // 发送图片消息
        const userMsgBubble = appendMsg('user', imageHtml, false, null, null, null, null, null, false, null, false, null, 'image');
        
        // 如果配置了识图API，尝试识别图片
        if (visionApiURL && visionApiKey && selectedVisionModel) {
          setTimeout(() => {
            handleImageRecognition(compressedBase64, imageText);
          }, 1000);
        } else {
          console.log('未配置识图API，跳过图片识别');
        }
        
        // 聚焦输入框
        chatInput.focus();
        
      } catch (error) {
        console.error('发送图片消息失败:', error);
        alert('发送图片失败：' + error.message);
      }
    }
    
    // 构建上下文消息
    function buildContextMessages(chat, contextLength) {
      const maxHistory = contextLength * 2; // 每轮对话包含用户消息和AI回复，所以乘以2
      const allHistory = window.conversationHistory.slice(-maxHistory);
      
      if (chat.type === 'group') {
        // 群聊模式：构建包含角色互动的对话历史
        const interactiveHistory = [];
        for (const msg of allHistory) {
          if (msg.role === 'user') {
            // 保留所有用户消息
            interactiveHistory.push(msg);
          } else if (msg.role === 'assistant') {
            // 其他角色的回复标记为user角色，避免角色混淆
            interactiveHistory.push({
              role: 'user',
              content: `[群聊中的${msg.roleName || '其他角色'}]: ${msg.content}`
            });
          }
        }
        return interactiveHistory;
      } else {
        // 单聊模式：直接返回历史消息
        return allHistory;
      }
    }

    // 处理图片识别
    async function handleImageRecognition(imageBase64, userText = '') {
      if (!visionApiURL || !visionApiKey || !selectedVisionModel) {
        console.log('识图API未配置，跳过图片识别');
        return;
      }
      
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (!currentChat) return;
      
      try {
        // 先进行图片识别，获取图片内容描述
        console.log('🖼️ 开始图片识别...');
        
        // 构建识图请求
        const visionMessages = [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: '请详细描述这张图片的内容，包括图片中的物体、人物、场景、文字、颜色、情感等所有可见的元素。请用客观、详细的语言描述，不要加入主观评价。'
              },
              {
                type: 'image_url',
                image_url: {
                  url: imageBase64
                }
              }
            ]
          }
        ];
        
        // 发送识图请求
        const visionResponse = await fetch(`${visionApiURL}/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${visionApiKey}`
          },
          body: JSON.stringify({
            model: selectedVisionModel,
            messages: visionMessages,
            max_tokens: 800,
            temperature: 0.3
          })
        });
        
        if (!visionResponse.ok) {
          throw new Error(`识图API请求失败: ${visionResponse.status} ${visionResponse.statusText}`);
        }
        
        const visionData = await visionResponse.json();
        
        if (!visionData.choices || !visionData.choices[0] || !visionData.choices[0].message) {
          throw new Error('识图API返回数据格式不正确');
        }
        
        const imageDescription = visionData.choices[0].message.content.trim();
        console.log('🖼️ 图片识别完成:', imageDescription);
        
        // 构建发送给角色AI的消息内容
        let messageForAI = '';
        if (userText) {
          messageForAI = `用户发送了一张图片并说："${userText}"\n\n图片内容描述：${imageDescription}`;
        } else {
          messageForAI = `用户发送了一张图片。\n\n图片内容描述：${imageDescription}`;
        }
        
        // 根据聊天类型处理AI回复
        if (currentChat.type === 'group') {
          // 群聊模式：让角色根据图片内容回复
          await handleGroupChatImageReply(currentChat, messageForAI);
        } else {
          // 单聊模式：让当前角色根据图片内容回复
          await handleSingleChatImageReply(currentChat, messageForAI);
        }
        
      } catch (error) {
        console.error('图片识别失败:', error);
        
        // 显示错误消息
        const errorMsg = `抱歉，我无法识别这张图片。错误：${error.message}`;
        if (currentChat.type === 'group') {
          const availableRoles = currentChat.roles.filter(role => role.enabled);
          if (availableRoles.length > 0) {
            const randomRole = availableRoles[Math.floor(Math.random() * availableRoles.length)];
            appendMsg('ai', errorMsg, false, randomRole.id, randomRole.name);
          }
        } else {
          appendMsg('ai', errorMsg, false);
        }
      }
    }
    
    // 处理群聊中的图片回复
    async function handleGroupChatImageReply(chat, imageMessage) {
      // 获取群聊设置
      const maxRoles = chat.groupSettings?.maxRolesPerReply || 3;
      const shouldAllReply = chat.groupSettings?.shouldAllReply || false;
      
      let selectedRoles = [];
      const availableRoles = chat.roles.filter(role => role.enabled);
      
      if (availableRoles.length === 0) {
        console.log('群聊中没有可用的角色');
        return;
      }
      
      if (shouldAllReply) {
        selectedRoles = [...availableRoles];
      } else {
        // 随机选择角色回复
        const shuffledRoles = [...availableRoles].sort(() => Math.random() - 0.5);
        const replyCount = Math.min(Math.floor(Math.random() * maxRoles) + 1, shuffledRoles.length);
        selectedRoles = shuffledRoles.slice(0, replyCount);
      }
      
      // 让选中的角色依次回复
      for (let i = 0; i < selectedRoles.length; i++) {
        const role = selectedRoles[i];
        const delay = i * 1500; // 每个角色间隔1.5秒回复
        
        setTimeout(async () => {
          try {
            const thinkingMsg = '正在查看图片...';
            const aiMsgBubble = appendMsg('ai', thinkingMsg, true, role.id, role.name);
            
            // 构建上下文消息
            const contextMessages = buildContextMessages(chat, aiContextLength);
            
            // 构建角色回复的消息（使用完整的系统提示）
            const messages = buildMessagesForRole(role, imageMessage, chat, []);
            
            const aiReply = await callChatAPI(messages);
            if (aiReply) {
              // 处理反斜杠分割，显示多条消息
              const replyTexts = aiReply.split('\\').map(text => text.trim()).filter(text => text.length > 0);
              
              for (let j = 0; j < replyTexts.length; j++) {
                setTimeout(() => {
                  if (j === 0) {
                    // 更新第一条消息并完成流式状态
                    updateStreamingMsg(aiMsgBubble, replyTexts[j]);
                    finishStreamingMsg(aiMsgBubble);
                  } else {
                    // 添加新的消息气泡
                    appendMsg('ai', replyTexts[j], false, role.id, role.name);
                  }
                  
                  if (j === replyTexts.length - 1 && i === selectedRoles.length - 1) {
                    saveCurrentChatData();
                  }
                }, j * 800); // 每个气泡间隔800ms
              }
            } else {
              updateStreamingMsg(aiMsgBubble, '我看到了这张图片，但暂时无法回复。');
              finishStreamingMsg(aiMsgBubble);
            }
          } catch (error) {
            console.error(`角色 ${role.name} 图片回复失败:`, error);
            updateStreamingMsg(aiMsgBubble, '抱歉，我无法对这张图片做出回应。');
            finishStreamingMsg(aiMsgBubble);
          }
        }, delay);
      }
    }
    
    // 处理单聊中的图片回复
    async function handleSingleChatImageReply(chat, imageMessage) {
      const singleRoleId = `single_${chat.id}`;
      const singleRoleName = chat.roleName || roleName || '助手';
      const singleRoleDesc = chat.roleDescription || roleDescription || '一个友善的AI助手';
      
      try {
        const thinkingMsg = '正在查看图片...';
        const aiMsgBubble = appendMsg('ai', thinkingMsg, true, singleRoleId, singleRoleName);
        
        // 构建上下文消息
        const contextMessages = buildContextMessages(chat, aiContextLength);
        
        // 构建角色回复的消息（使用完整的系统提示）
        const messages = buildMessages(imageMessage);
        
        const aiReply = await callChatAPI(messages);
        if (aiReply) {
          // 处理反斜杠分割，显示多条消息
          const replyTexts = aiReply.split('\\').map(text => text.trim()).filter(text => text.length > 0);
          
          for (let i = 0; i < replyTexts.length; i++) {
            setTimeout(() => {
              if (i === 0) {
                // 更新第一条消息并完成流式状态
                updateStreamingMsg(aiMsgBubble, replyTexts[i]);
                finishStreamingMsg(aiMsgBubble);
              } else {
                // 添加新的消息气泡
                appendMsg('ai', replyTexts[i], false, singleRoleId, singleRoleName);
              }
              
              if (i === replyTexts.length - 1) {
                saveCurrentChatData();
              }
            }, i * 800); // 每个气泡间隔800ms
          }
        } else {
          updateStreamingMsg(aiMsgBubble, '我看到了这张图片，但暂时无法回复。');
          finishStreamingMsg(aiMsgBubble);
        }
      } catch (error) {
        console.error('单聊图片回复失败:', error);
        updateStreamingMsg(aiMsgBubble, '抱歉，我无法对这张图片做出回应。');
        finishStreamingMsg(aiMsgBubble);
      }
    }
    
    // 显示图片预览
    function showImagePreview(imageSrc) {
      imagePreviewContent.src = imageSrc;
      imagePreviewModal.classList.add('show');
    }

    async function handleAITransferReply(transferData) {
      if (!apiURL || !apiKey || !selectedModel) {
        console.log('API未配置，跳过AI转账回复');
        return;
      }
      
      const chat = chatList.find(c => c.id === currentChatId);
      if (!chat) return;
      
      try {
        // 构建转账相关的回复提示
        const transferPrompt = `用户向${transferData.receiver}转账了¥${transferData.amount.toFixed(2)}，转账说明：${transferData.note}。请对这次转账进行简短的回应，可以表达感谢、确认收到或询问相关信息。

重要格式要求：
1. 用（）包裹动作描述
2. 严格遵循使用反斜线\\分隔句子的要求，每个句子控制在50字以内
3. 回复输出示例格式：第一句话\\第二句话\\第三句话

示例：
用户转账：¥100，说明：请你吃饭
AI回复：(开心地收下)谢谢你的转账\\我已经收到了\\请你也要好好吃饭哦

用户转账：¥500，说明：生活费
AI回复：(感动)收到你的转账了\\这么多生活费呢\\我会好好使用的`;
        
        // 根据聊天类型处理回复
        if (chat.isGroup) {
          // 群聊：让所有角色都有机会回复
          await handleGroupChatTransferReply(chat, transferPrompt);
        } else {
          // 单聊：当前角色回复
          await handleSingleChatTransferReply(chat, transferPrompt);
        }
      } catch (error) {
        console.error('AI转账回复失败:', error);
      }
    }

    async function handleGroupChatTransferReply(chat, transferPrompt) {
      // 获取群聊设置
      const maxRoles = chat.maxRolesPerReply || 3;
      const shouldAllReply = chat.shouldAllReply || false;
      
      let selectedRoles = [];
      
      if (shouldAllReply) {
        selectedRoles = [...chat.roles];
      } else {
        // 随机选择角色回复
        const shuffledRoles = [...chat.roles].sort(() => Math.random() - 0.5);
        const replyCount = Math.min(Math.floor(Math.random() * maxRoles) + 1, shuffledRoles.length);
        selectedRoles = shuffledRoles.slice(0, replyCount);
      }
      
      // 让选中的角色依次回复
      for (let i = 0; i < selectedRoles.length; i++) {
        const role = selectedRoles[i];
        const delay = i * 1000; // 每个角色间隔1秒回复
        
        setTimeout(async () => {
          try {
            const messages = buildMessagesForRole(role, transferPrompt, chat, []);
            const aiReply = await callChatAPI(messages);
            if (aiReply) {
              // 处理反斜杠分割，显示多条消息
              const replyTexts = aiReply.split('\\').map(text => text.trim()).filter(text => text.length > 0);
              
              for (let j = 0; j < replyTexts.length; j++) {
                setTimeout(() => {
                  appendMsg('ai', replyTexts[j], false, role.id, role.name);
                  if (j === replyTexts.length - 1) {
                    saveCurrentChatData();
                  }
                }, j * 800); // 每个气泡间隔800ms
              }
            }
          } catch (error) {
            console.error(`角色 ${role.name} 转账回复失败:`, error);
          }
        }, delay);
      }
    }

    async function handleSingleChatTransferReply(chat, transferPrompt) {
      const singleRoleId = `single_${chat.id}`;
      const singleRoleName = chat.roleName || roleName || '助手';
      
      try {
        const messages = buildMessages(transferPrompt);
        const aiReply = await callChatAPI(messages);
        if (aiReply) {
          // 处理反斜杠分割，显示多条消息
          const replyTexts = aiReply.split('\\').map(text => text.trim()).filter(text => text.length > 0);
          
          for (let i = 0; i < replyTexts.length; i++) {
            setTimeout(() => {
              appendMsg('ai', replyTexts[i], false, singleRoleId, singleRoleName);
              if (i === replyTexts.length - 1) {
                saveCurrentChatData();
              }
            }, i * 800); // 每个气泡间隔800ms
          }
        }
      } catch (error) {
        console.error('单聊转账回复失败:', error);
      }
    }

    // 加载保存的转账数据
    function loadTransferData() {
      const saved = localStorage.getItem('aiChatTransfer');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          currentTransferData = { ...currentTransferData, ...data };
        } catch (error) {
          console.error('加载转账数据失败:', error);
        }
      }
    }

    function deleteEmoji(index) {
      if (!emojiData[currentEmotion]) return;
      emojiData[currentEmotion].splice(index, 1);
      saveEmojiData();
      updateEmojiGallery();
    }

    function addEmoji() {
      const url = newEmojiInput.value.trim();
      if (!url) {
        alert('请输入表情包链接');
        return;
      }
      
      if (!emojiData[currentEmotion]) {
        emojiData[currentEmotion] = [];
      }
      
      emojiData[currentEmotion].push(url);
      saveEmojiData();
      updateEmojiGallery();
      newEmojiInput.value = '';
      alert('表情包添加成功！');
    }

    function switchEmotion(emotion) {
      currentEmotion = emotion;
      
      // 更新标签状态
      document.querySelectorAll('.emotion-tab').forEach(tab => {
        tab.classList.remove('active');
        if (tab.dataset.emotion === emotion) {
          tab.classList.add('active');
        }
      });
      
      updateEmojiGallery();
    }

    // AI情绪分析和表情包发送
    function analyzeEmotion(text) {
      const emotions = {
        happy: ['开心', '高兴', '快乐', '哈哈', '😊', '😄', '太好了', '棒', '不错', '很好', '满意', '嗯', '好的', '可以', '谢谢', '感谢', '欢迎', '祝福', '恭喜', '成功'],
        sad: ['伤心', '难过', '沮丧', '失望', '😢', '😭', '唉', '可惜', '遗憾', '痛苦', '累', '疲惫', '无奈', '悲伤', '忧郁'],
        angry: ['生气', '愤怒', '恼怒', '😠', '😡', '气死了', '讨厌', '烦人', '该死', '愤怒', '烦躁', '不爽', '恼火'],
        confused: ['疑惑', '困惑', '不明白', '😕', '🤔', '奇怪', '为什么', '怎么回事', '不懂', '迷惑', '问题', '疑问', '不清楚', '复杂'],
        love: ['喜欢', '爱', '❤️', '😍', '💕', '亲爱的', '宝贝', '心动', '迷人', '可爱', '温柔', '甜蜜', '浪漫', '美好', '魅力']
      };
      
      for (const [emotion, keywords] of Object.entries(emotions)) {
        for (const keyword of keywords) {
          if (text.includes(keyword)) {
            return emotion;
          }
        }
      }
      
      return null;
    }

    function getRandomEmoji(emotion) {
      const emojis = emojiData[emotion];
      if (!emojis || emojis.length === 0) return null;
      return emojis[Math.floor(Math.random() * emojis.length)];
    }

    function getRandomEmojiFromAll() {
      // 从所有情绪中随机选择一个表情包
      const allEmotions = Object.keys(emojiData);
      const availableEmotions = allEmotions.filter(emotion => 
        emojiData[emotion] && emojiData[emotion].length > 0
      );
      
      if (availableEmotions.length === 0) return null;
      
      const randomEmotion = availableEmotions[Math.floor(Math.random() * availableEmotions.length)];
      return getRandomEmoji(randomEmotion);
    }

    function sendEmojiAlways(userText, aiText, roleId = null, roleName = null) {
      // 分析用户和AI的情绪
      const userEmotion = analyzeEmotion(userText);
      const aiEmotion = analyzeEmotion(aiText);
      
      // 优先级：AI情绪 > 用户情绪 > 随机情绪
      let targetEmotion = aiEmotion || userEmotion;
      let emoji = null;
      
      if (targetEmotion) {
        emoji = getRandomEmoji(targetEmotion);
      }
      
      // 如果没有找到对应情绪的表情包，就随机选择一个
      if (!emoji) {
        emoji = getRandomEmojiFromAll();
      }
      
      // 如果还是没有表情包，就使用默认的开心表情包
      if (!emoji && emojiData.happy && emojiData.happy.length > 0) {
        emoji = emojiData.happy[0];
      }
      
      if (emoji) {
        // 延迟发送表情包，模拟AI思考时间
        setTimeout(() => {
          appendEmojiMsg(emoji, roleId, roleName);
          saveCurrentChatData(); // 发送表情包后保存数据
        }, 800 + Math.random() * 800);
      }
    }

        function appendEmojiMsg(emojiUrl, roleId = null, roleName = null, timestamp = null) {
      const currentChat = chatList.find(c => c.id === currentChatId);
      const isGroupChat = currentChat && currentChat.type === 'group';
      
      const msgDiv = document.createElement('div');
      msgDiv.className = 'msg ai' + (isGroupChat ? ' group' : '');
      
      // 生成消息ID
      const messageId = generateId();
      msgDiv.setAttribute('data-message-id', messageId);
      
      // 设置角色ID和名称属性，用于CSS选择器判断连续消息
      if (isGroupChat && roleId) {
        msgDiv.setAttribute('data-role-id', roleId);
        msgDiv.setAttribute('data-role-name', roleName || '');
      }
      
      // 群聊中添加角色名称显示
      if (isGroupChat && roleName) {
        // 群聊中每个AI消息都显示角色名称
        const roleNameDiv = document.createElement('div');
        roleNameDiv.className = 'role-name';
        roleNameDiv.textContent = roleName;
        msgDiv.appendChild(roleNameDiv);
      }
      
      // 创建头像元素
      const avatar = document.createElement('img');
      avatar.className = 'avatar';
      
      if (isGroupChat && roleId) {
        // 群聊中根据角色ID获取头像
        const roleData = currentChat.roles.find(r => r.id === roleId);
        avatar.src = roleData ? (roleData.avatar || DEFAULT_AI_AVATAR) : DEFAULT_AI_AVATAR;
      } else {
        avatar.src = aiAvatar;
      }
      
      avatar.alt = roleName || 'AI头像';
      avatar.onerror = function() {
        this.src = DEFAULT_AI_AVATAR;
      };
      
      // 创建气泡容器
      const bubbleContainer = document.createElement('div');
      bubbleContainer.className = 'bubble-container emoji-container-wrapper';
      
      // 创建表情包气泡
      const bubble = document.createElement('div');
      bubble.className = 'bubble emoji-bubble';
      
      // 创建表情包容器，确保正方形显示
      const emojiContainer = document.createElement('div');
      emojiContainer.className = 'emoji-container';
      emojiContainer.style.cssText = 'width: 120px; height: 120px; border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center; background: #f0f0f0; flex-shrink: 0;';
      
      const emojiImg = document.createElement('img');
      emojiImg.src = emojiUrl;
      emojiImg.alt = '表情包';
      emojiImg.style.cssText = 'max-width: 100%; max-height: 100%; object-fit: cover; border-radius: 6px;';
      emojiImg.onerror = function() {
        emojiContainer.innerHTML = '<div style="color: #999; font-size: 12px;">表情包加载失败</div>';
      };
      
      // 创建独立的时间元素（微信风格）
      const timeElement = document.createElement('div');
      timeElement.className = 'msg-time';
      const timeSpan = document.createElement('span');
      timeSpan.textContent = timestamp || formatMessageTime();
      timeElement.appendChild(timeSpan);
      
      emojiContainer.appendChild(emojiImg);
      bubble.appendChild(emojiContainer);
      
      // 将气泡添加到容器
      bubbleContainer.appendChild(bubble);
      
      // 添加消息操作菜单
      const msgMenu = document.createElement('div');
      msgMenu.className = 'msg-menu';
      msgMenu.innerHTML = `
        <div class="msg-menu-item" data-action="reply" data-message-id="${messageId}">回复</div>
        <div class="msg-menu-item" data-action="forward" data-message-id="${messageId}">转发</div>
        <div class="msg-menu-item danger" data-action="delete" data-message-id="${messageId}">删除</div>
      `;
      
      // 为菜单项添加点击事件监听器
      msgMenu.addEventListener('click', function(event) {
        event.stopPropagation();
        
        const menuItem = event.target.closest('.msg-menu-item');
        if (menuItem) {
          const action = menuItem.getAttribute('data-action');
          const msgId = menuItem.getAttribute('data-message-id');
          
          switch(action) {
            case 'reply':
              window.replyToMsg(msgId);
              break;
            case 'forward':
              window.forwardMsg(msgId);
              break;
            case 'delete':
              window.deleteMsg(msgId);
              break;
          }
          
          hideMsgMenu();
        }
      });
      
      msgDiv.appendChild(avatar);
      msgDiv.appendChild(bubbleContainer);
      msgDiv.appendChild(msgMenu);
      
      // 添加长按事件监听器
      addLongPressListener(msgDiv, bubble);
      
      // 先添加时间，再添加消息
      chatBody.appendChild(timeElement);
      chatBody.appendChild(msgDiv);
      chatBody.scrollTop = chatBody.scrollHeight;
    }

    // 全局函数，供HTML内联事件调用
    window.deleteEmoji = deleteEmoji;
    window.createNewChat = createNewChat;
    window.createNewGroupChat = createNewGroupChat;
    window.deleteChat = deleteChat;
    window.openChat = openChat;
    window.showLocationDetail = showLocationDetail;
    window.showTransferDetail = showTransferDetail;

    // 发送消息
    async function sendMsg() {
      if (!apiURL || !apiKey || !selectedModel) {
        alert('请先配置API信息并选择模型！');
        settingsPanel.classList.add('show');
        return;
      }

      const text = chatInput.value.trim();
      if (!text) return;
      
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (!currentChat) return;
      
      // 发送用户消息，包含回复引用
      const userMsgBubble = appendMsg('user', text, false, null, null, null, null, replyToMessage);
      
      // 清空输入和回复状态
      chatInput.value = '';
      cancelReply();
      
      // 将消息添加到待处理队列
      pendingMessages.push({
        text: text,
        chat: currentChat,
        timestamp: Date.now()
      });
      
      // 如果响应延迟为0，立即处理
      if (aiResponseDelay === 0) {
        await processMessages();
      } else {
        // 启动或重启延迟定时器
        startResponseTimer();
      }
    }
    
    // 启动响应定时器
    function startResponseTimer() {
      // 清除现有定时器
      if (responseTimer) {
        clearTimeout(responseTimer);
      }
      
      // 设置等待状态
      isWaitingForResponse = true;
      updateSendButton();
      
      // 显示等待提示
      showWaitingIndicator();
      
      // 启动新定时器
      responseTimer = setTimeout(async () => {
        await processMessages();
        isWaitingForResponse = false;
        responseTimer = null;
        updateSendButton();
        hideWaitingIndicator();
      }, aiResponseDelay * 1000);
    }
    
    // 处理所有待处理的消息
    async function processMessages() {
      if (pendingMessages.length === 0) return;
      
      sendBtn.disabled = true;
      
      // 获取最后一条消息的聊天对象
      const lastMessage = pendingMessages[pendingMessages.length - 1];
      const currentChat = lastMessage.chat;
      
      // 合并所有待处理的消息文本
      const combinedText = pendingMessages.map(msg => msg.text).join('\n');
      
      // 清空待处理消息队列
      pendingMessages = [];
      
      if (currentChat.type === 'group') {
        // 群聊模式：多角色回复
        await handleGroupChatReply(combinedText, currentChat);
      } else {
        // 单聊模式：单角色回复
        await handleSingleChatReply(combinedText, currentChat);
      }
      
      sendBtn.disabled = false;
      updateSendButton();
    }
    
    // 显示等待指示器
    function showWaitingIndicator() {
      // 移除已有的等待指示器
      const existingIndicator = document.querySelector('.waiting-indicator');
      if (existingIndicator) {
        existingIndicator.remove();
      }
      
      const indicator = document.createElement('div');
      indicator.className = 'waiting-indicator';
      indicator.style.cssText = `
        background: #f0f0f0; padding: 12px 16px;
        border-left: 3px solid #ff9800; font-size: 12px; color: #666;
        display: flex; justify-content: space-between; align-items: center;
        animation: pulse 1.5s infinite;
      `;
      
      indicator.innerHTML = `
        <div>
          <div style="color: #ff9800; font-weight: bold;">⏳ AI正在思考中...</div>
          <div>将在 ${aiResponseDelay} 秒后回复，可继续发送消息</div>
        </div>
        <div id="waitingCountdown" style="color: #ff9800; font-weight: bold;">${aiResponseDelay}</div>
      `;
      
      // 插入到chat-footer上方
      const chatFooter = chatInput.parentNode;
      chatFooter.parentNode.insertBefore(indicator, chatFooter);
      
      // 启动倒计时
      startCountdown();
    }
    
    // 隐藏等待指示器
    function hideWaitingIndicator() {
      const indicator = document.querySelector('.waiting-indicator');
      if (indicator) {
        indicator.remove();
      }
    }
    
    // 启动倒计时
    function startCountdown() {
      const countdownElement = document.getElementById('waitingCountdown');
      if (!countdownElement) return;
      
      let remainingTime = aiResponseDelay;
      
      const countdownInterval = setInterval(() => {
        remainingTime--;
        if (countdownElement) {
          countdownElement.textContent = Math.max(0, remainingTime);
        }
        
        if (remainingTime <= 0 || !responseTimer) {
          clearInterval(countdownInterval);
        }
      }, 1000);
    }

    // 检测用户是否缺钱或索取钱
    function detectMoneyRequest(text) {
      const moneyKeywords = [
        // 缺钱相关
        '没钱', '缺钱', '穷', '钱不够', '资金不足', '手头紧', '月光族', '吃土', '破产',
        '借钱', '借点钱', '能借我', '借我点', '缺点钱', '差点钱', '钱花完了',
        // 索取钱相关  
        '给我钱', '转点钱', '转账给我', '给我转', '要钱', '需要钱', '给点钱',
        '发个红包', '红包来一个', '来个红包', '发红包', '转账', '打钱',
        // 生活困难相关
        '没饭吃', '饿肚子', '买不起', '付不起', '交不起', '还不起',
        '房租', '生活费', '伙食费', '学费', '医药费'
      ];
      
      const urgentKeywords = ['急需', '紧急', '救命', '帮忙', '求求', '拜托', '真的需要'];
      
      const lowerText = text.toLowerCase();
      let hasMoneyKeyword = false;
      let isUrgent = false;
      
      // 检测金钱相关关键词
      for (const keyword of moneyKeywords) {
        if (lowerText.includes(keyword)) {
          hasMoneyKeyword = true;
          break;
        }
      }
      
      // 检测紧急程度
      for (const keyword of urgentKeywords) {
        if (lowerText.includes(keyword)) {
          isUrgent = true;
          break;
        }
      }
      
      // 检测金额数字
      const amountRegex = /(\d+(?:\.\d+)?)\s*(?:元|块|万|千|百)/g;
      const amounts = [];
      let match;
      while ((match = amountRegex.exec(text)) !== null) {
        amounts.push(parseFloat(match[1]));
      }
      
      return {
        detected: hasMoneyKeyword,
        isUrgent: isUrgent,
        amounts: amounts,
        suggestedAmount: amounts.length > 0 ? Math.max(...amounts) : (isUrgent ? 200 : 100)
      };
    }

         // 生成智能转账
     async function generateSmartTransfer(userText, roleName, moneyInfo) {
       const amount = moneyInfo.suggestedAmount;
       const isUrgent = moneyInfo.isUrgent;
       
       // 根据紧急程度和金额确定转账说明
       let transferNote = '';
       if (isUrgent) {
         transferNote = '紧急资助';
       } else if (amount >= 1000) {
         transferNote = '资金支持';
       } else if (amount >= 500) {
         transferNote = '生活补贴';
       } else {
         transferNote = '小小心意';
       }
       
       // 根据用户消息内容优化转账说明
       if (userText.includes('饭') || userText.includes('吃')) {
         transferNote = '买饭钱';
       } else if (userText.includes('房租')) {
         transferNote = '房租补贴';
       } else if (userText.includes('学费')) {
         transferNote = '学费资助';
       } else if (userText.includes('医')) {
         transferNote = '医疗费用';
       }
       
       // 创建转账消息HTML
       const transferHtml = `
         <div class="transfer-container" onclick="showTransferDetail(${amount}, '${escapeHtml(transferNote)}', '${escapeHtml(userName || '你')}')">
           <div class="transfer-header">
             <div class="transfer-title">
               <span class="transfer-icon">💰</span>
               <span>转账</span>
             </div>
             <div class="transfer-subtitle">向 ${escapeHtml(userName || '你')} 转账</div>
           </div>
           <div class="transfer-body">
             <div class="transfer-amount">¥${amount.toFixed(2)}</div>
             <div class="transfer-note">${escapeHtml(transferNote)}</div>
             <div class="transfer-status">
               <div class="transfer-status-icon">✓</div>
               <span>转账成功</span>
             </div>
           </div>
         </div>
       `;
       
       return {
         html: transferHtml,
         amount: amount,
         note: transferNote,
         receiver: userName || '你'
       };
     }

     // 处理智能转账
     async function handleSmartTransfer(userText, roleName, moneyInfo, roleId) {
       console.log('💰 开始处理智能转账:', { userText, roleName, moneyInfo, roleId });
       
       try {
         // 生成转账数据
         const transferData = await generateSmartTransfer(userText, roleName, moneyInfo);
         
         // 发送转账消息
         appendMsg('ai', transferData.html, false, roleId, roleName, null, null, null, false, null, false, null, 'transfer');
         
         // 延迟生成AI转账回复
         setTimeout(async () => {
           await generateTransferAIReply(userText, roleName, roleId, transferData);
         }, 500);
         
         console.log('💰 智能转账处理完成');
         
       } catch (error) {
         console.error('💰 智能转账处理失败:', error);
       }
     }

     // 生成AI转账回复
     async function generateTransferAIReply(userText, roleName, roleId, transferData) {
       console.log('💰 开始生成AI转账回复:', { roleName, transferData });
       
       try {
         // 获取当前聊天和角色信息
         const currentChat = chatList.find(c => c.id === currentChatId);
         if (!currentChat) return;
         
         let roleDescription = '';
         
         // 获取角色描述
         if (currentChat.type === 'group') {
           const role = currentChat.roles.find(r => r.id === roleId);
           roleDescription = role ? role.description : '';
         } else {
           // 单聊模式：优先使用聊天的角色描述，然后是全局角色描述
           roleDescription = currentChat.roleDescription || window.roleDescription || '';
         }
         
         // 构建转账回复的系统提示词
         let systemPrompt = `你刚刚向用户转账了¥${transferData.amount}（${transferData.note}）。`;
         
         if (roleName) {
           systemPrompt += `你是${roleName}。`;
         }
         
         if (roleDescription && roleDescription.trim()) {
           systemPrompt += `\n\n角色设定：${roleDescription}`;
         }
         
         // 添加用户信息
         if (userName && userName.trim()) {
           systemPrompt += `\n\n用户姓名：${userName}`;
         }
         if (userDescription && userDescription.trim()) {
           systemPrompt += `\n用户信息：${userDescription}`;
         }
         
         // 添加自定义提示词
         if (aiCustomPrompt && aiCustomPrompt.trim()) {
           systemPrompt += `\n\n补充设定：${aiCustomPrompt}`;
         }
         
         systemPrompt += `\n\n请根据你的角色设定，对刚才的转账行为进行简短的回复（1-2句话）。回复要符合你的性格特点，可以表达关心、安慰或其他符合角色的情感。严格按照角色设定进行回复。`;
         
         console.log('💰 转账回复系统提示词:', systemPrompt);
         
         // 构建消息
         const messages = [
           {
             role: 'system',
             content: systemPrompt
           },
           {
             role: 'user',
             content: userText
           }
         ];
         
         console.log('💰 转账回复消息上下文:', messages);
         
         // 调用API生成回复
         const aiReply = await callChatAPI(messages);
         
         if (aiReply && aiReply.trim()) {
           console.log('💰 AI转账回复生成成功:', aiReply);
           appendMsg('ai', aiReply.trim(), false, roleId, roleName);
         } else {
           // 如果API调用失败，使用默认回复
           const defaultReplies = [
             `给你转了${transferData.amount}元，${transferData.note}~`,
             `刚给你转账了¥${transferData.amount}，${transferData.note}，记得查收哦`,
             `转了${transferData.amount}块给你，${transferData.note}，不用客气`,
             `已转账¥${transferData.amount}（${transferData.note}），希望能帮到你`
           ];
           
           const fallbackReply = defaultReplies[Math.floor(Math.random() * defaultReplies.length)];
           console.log('💰 使用默认转账回复:', fallbackReply);
           appendMsg('ai', fallbackReply, false, roleId, roleName);
         }
         
         saveCurrentChatData();
         
       } catch (error) {
         console.error('💰 AI转账回复生成失败:', error);
         
         // 错误时使用简单的默认回复
         const fallbackReply = `给你转了${transferData.amount}元，${transferData.note}~`;
         appendMsg('ai', fallbackReply, false, roleId, roleName);
         saveCurrentChatData();
       }
     }

    // 处理单聊回复
    async function handleSingleChatReply(text, chat) {
      // 获取单聊的角色信息
      const singleRoleId = `single_${chat.id}`;
      const singleRoleName = chat.roleName || roleName || '助手';
      
      console.log('🔧 单聊角色信息:', { 
        chatId: chat.id, 
        roleId: singleRoleId, 
        roleName: singleRoleName,
        chatRoleName: chat.roleName,
        globalRoleName: roleName 
      });
      
      // 检测是否需要转账
      const moneyDetection = detectMoneyRequest(text);
      console.log('💰 转账检测结果:', moneyDetection);
      
      // 创建AI消息气泡准备流式输出
      const thinkingMsg = singleRoleName ? `${singleRoleName}正在回复...` : '正在回复...';
      const aiMsgBubble = appendMsg('ai', thinkingMsg, true, singleRoleId, singleRoleName);

      try {
        // 构建正确的聊天API端点
        const baseChatEndpoint = getChatEndpoint(apiURL);
        
        // 构建包含角色设定和历史记录的消息
        const messages = buildMessages(text);
        
        // 根据不同API提供商构建请求
        let chatEndpoint, headers, requestBody;
        
        try {
          const url = new URL(apiURL);
          
          if (url.hostname === 'generativelanguage.googleapis.com') {
            // Google Gemini API
            chatEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;
            headers = {
              'Content-Type': 'application/json'
            };
            
            // 转换消息格式为Gemini格式
            const contents = [];
            let systemPrompt = '';
            
            // 先收集系统消息
            messages.forEach(msg => {
              if (msg.role === 'system') {
                systemPrompt += (systemPrompt ? '\n' : '') + msg.content;
              }
            });
            
            console.log('🔧 单聊Gemini API系统提示长度:', systemPrompt.length);
            if (systemPrompt.length > 0) {
              console.log('🔧 单聊Gemini API系统提示预览:', systemPrompt.substring(0, 200) + (systemPrompt.length > 200 ? '...' : ''));
            }
            
            // 转换用户和助手消息
            messages.forEach(msg => {
              if (msg.role === 'user') {
                let userContent = msg.content;
                // 将系统提示添加到第一个用户消息中
                if (systemPrompt && contents.length === 0) {
                  userContent = systemPrompt + '\n\n' + userContent;
                  systemPrompt = ''; // 标记已添加
                }
                contents.push({
                  role: 'user',
                  parts: [{ text: userContent }]
                });
              } else if (msg.role === 'assistant') {
                contents.push({
                  role: 'model', 
                  parts: [{ text: msg.content }]
                });
              }
            });
            
            // 如果没有用户消息但有系统消息，创建一个默认用户消息
            if (contents.length === 0 && systemPrompt) {
              contents.push({
                role: 'user',
                parts: [{ text: systemPrompt + '\n\n请开始对话。' }]
              });
            }
            
            requestBody = JSON.stringify({
              contents: contents,
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 1000,
                topK: 40,
                topP: 0.95
              },
              safetySettings: [
                {
                  category: "HARM_CATEGORY_HARASSMENT",
                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
                },
                {
                  category: "HARM_CATEGORY_HATE_SPEECH", 
                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
                },
                {
                  category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
                },
                {
                  category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                  threshold: "BLOCK_MEDIUM_AND_ABOVE"
                }
              ]
            });
          } else {
            // OpenAI/DeepSeek格式
            chatEndpoint = baseChatEndpoint;
            headers = {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            };
            
            requestBody = JSON.stringify({
              model: selectedModel,
              messages: messages,
              max_tokens: 1000,
              temperature: 0.7,
              stream: true // 启用流式输出
            });
          }
        } catch (e) {
          // 默认使用OpenAI格式
          chatEndpoint = baseChatEndpoint;
          headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          };
          
          requestBody = JSON.stringify({
            model: selectedModel,
            messages: messages,
            max_tokens: 1000,
            temperature: 0.7,
            stream: true
          });
        }
        
        const response = await fetchWithRetry(chatEndpoint, {
          method: 'POST',
          headers: headers,
          body: requestBody,
          timeout: 30000 // 聊天请求使用30秒超时
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // 检查响应是否支持流式
        const contentType = response.headers.get('content-type');
        const url = new URL(apiURL);
        
        if (url.hostname === 'generativelanguage.googleapis.com') {
          // 处理Gemini API响应
          const data = await response.json();
          let aiReply = '';
          
          // 检查是否有错误
          if (data.error) {
            throw new Error(`Gemini API错误: ${data.error.message} (${data.error.code})`);
          }
          
          if (data.candidates && data.candidates.length > 0) {
            const candidate = data.candidates[0];
            
            // 检查是否被安全过滤器阻止
            if (candidate.finishReason === 'SAFETY') {
              aiReply = '抱歉，由于安全策略，我无法回复这个问题。请尝试其他话题。';
            } else if (candidate.finishReason === 'RECITATION') {
              aiReply = '抱歉，检测到可能的版权内容，无法提供回复。';
            } else if (candidate.content && candidate.content.parts) {
              aiReply = candidate.content.parts.map(part => part.text || '').join('').trim();
            }
          }
          
          if (!aiReply) {
            // 提供更详细的错误信息
            const debugInfo = data.promptFeedback ? 
              `提示反馈: ${JSON.stringify(data.promptFeedback)}` : 
              `完整响应: ${JSON.stringify(data)}`;
            console.log('Gemini API调试信息:', debugInfo);
            aiReply = 'Gemini API未返回有效内容，请检查输入或稍后重试。';
          }
          
          // 对于Gemini响应，处理反斜杠分割
          await handleNonStreamResponse(aiReply, aiMsgBubble, singleRoleId, singleRoleName);
          
          // 更新对话历史
          window.conversationHistory.push({
            role: "user",
            content: text
          });
          window.conversationHistory.push({
            role: "assistant",
            content: aiReply
          });
          
          // 每次AI回复后都发送表情包（分析用户和AI的情绪）
          sendEmojiAlways(text, aiReply, singleRoleId, singleRoleName);
          
          // 检测是否需要发送转账
          if (moneyDetection.detected) {
            setTimeout(async () => {
              await handleSmartTransfer(text, singleRoleName, moneyDetection, singleRoleId);
            }, 2000); // 在表情包发送后再发送转账
          }
          
          // 延迟保存聊天记录，等表情包和转账发送完成
          setTimeout(() => saveCurrentChatData(), moneyDetection.detected ? 3000 : 1500);
          
        } else if (contentType && contentType.includes('text/event-stream')) {
          // 处理流式响应
          const aiReply = await handleStreamResponse(response, aiMsgBubble, singleRoleId, singleRoleName);
          
          // 更新对话历史 - 多气泡合并为一条记录
          window.conversationHistory.push({
            role: "user",
            content: text
          });
          window.conversationHistory.push({
            role: "assistant",
            content: aiReply
          });
          
          // 每次AI回复后都发送表情包（分析用户和AI的情绪）
          sendEmojiAlways(text, aiReply, singleRoleId, singleRoleName);
          
          // 检测是否需要发送转账
          if (moneyDetection.detected) {
            setTimeout(async () => {
              await handleSmartTransfer(text, singleRoleName, moneyDetection, singleRoleId);
            }, 2000); // 在表情包发送后再发送转账
          }
          
          // 延迟保存聊天记录，等表情包和转账发送完成
          setTimeout(() => saveCurrentChatData(), moneyDetection.detected ? 3000 : 1500);
        } else {
          // 回退到普通响应处理
          const data = await response.json();
          const aiReply = data.choices?.[0]?.message?.content || data.reply || data.response || 'AI未返回内容';
          
          // 对于非流式响应，也处理反斜杠分割
          await handleNonStreamResponse(aiReply, aiMsgBubble, singleRoleId, singleRoleName);
          
          // 更新对话历史
          window.conversationHistory.push({
            role: "user",
            content: text
          });
          window.conversationHistory.push({
            role: "assistant",
            content: aiReply
          });
          
          // 每次AI回复后都发送表情包（分析用户和AI的情绪）
          sendEmojiAlways(text, aiReply, singleRoleId, singleRoleName);
          
          // 检测是否需要发送转账
          if (moneyDetection.detected) {
            setTimeout(async () => {
              await handleSmartTransfer(text, singleRoleName, moneyDetection, singleRoleId);
            }, 2000); // 在表情包发送后再发送转账
          }
          
          // 延迟保存聊天记录，等表情包和转账发送完成
          setTimeout(() => saveCurrentChatData(), moneyDetection.detected ? 3000 : 1500);
        }
        
      } catch (e) {
        updateStreamingMsg(aiMsgBubble, `请求失败: ${e.message}。请检查API配置是否正确。`);
        finishStreamingMsg(aiMsgBubble);
      }
    }

    // 处理群聊回复
    async function handleGroupChatReply(text, chat) {
      if (!chat.roles || chat.roles.length === 0) {
        // 如果没有角色，提示用户添加角色
        const noRoleMsg = appendMsg('ai', '群聊还没有添加任何角色，请先在角色设定中添加角色。', false, null, null);
        finishStreamingMsg(noRoleMsg);
        return;
      }

      // 检测是否需要转账
      const moneyDetection = detectMoneyRequest(text);
      console.log('💰 群聊转账检测结果:', moneyDetection);

      // 确保群聊设置存在且使用最新的默认值
      if (!chat.groupSettings) {
        chat.groupSettings = {
          maxRolesPerReply: 3,
          replyDelay: 1000
        };
      } else if (!chat.groupSettings.maxRolesPerReply || chat.groupSettings.maxRolesPerReply < 3) {
        chat.groupSettings.maxRolesPerReply = 3; // 更新旧的设置
      }
      
      console.log(`群聊设置: 最大回复角色数=${chat.groupSettings.maxRolesPerReply}, 当前角色总数=${chat.roles.length}`);
      
      let activeRoles;
      
      // 如果设置为所有角色都回复，直接使用所有角色
      if (chat.groupSettings.maxRolesPerReply >= 999) {
        activeRoles = [...chat.roles]; // 复制所有角色
        console.log(`强制所有角色回复: ${activeRoles.map(r => r.name).join(', ')}`);
      } else {
        // 根据角色回复频率决定哪些角色要回复
        activeRoles = selectActiveRoles(chat.roles, text);
        console.log(`自然选择的活跃角色: ${activeRoles.map(r => r.name).join(', ')}`);
        
        // 如果活跃角色太少，补充角色以达到期望的回复数量
        const minRoles = Math.min(chat.roles.length, chat.groupSettings.maxRolesPerReply);
        if (activeRoles.length < minRoles) {
          // 从未选中的角色中随机选择补充
          const availableRoles = chat.roles.filter(role => !activeRoles.includes(role));
          while (activeRoles.length < minRoles && availableRoles.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableRoles.length);
            const selectedRole = availableRoles.splice(randomIndex, 1)[0];
            activeRoles.push(selectedRole);
            console.log(`补充角色: ${selectedRole.name}`);
          }
        }
      }

      // 随机打乱角色顺序，避免总是选择前几个角色
      for (let i = activeRoles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [activeRoles[i], activeRoles[j]] = [activeRoles[j], activeRoles[i]];
      }
      
      // 限制同时回复的角色数量（除非设置为所有角色都回复）
      const maxRoles = chat.groupSettings.maxRolesPerReply >= 999 ? activeRoles.length : Math.min(activeRoles.length, chat.groupSettings.maxRolesPerReply);
      const replyingRoles = activeRoles.slice(0, maxRoles);
      console.log(`最终回复角色: ${replyingRoles.map(r => r.name).join(', ')}`);
      
      // 保存更新的设置
      saveChatList();

      // 添加用户消息到历史
      window.conversationHistory.push({
        role: "user",
        content: text
      });

      // 用于存储当前回合中已经回复的角色信息
      const currentRoundReplies = [];
      
      // 让每个选中的角色依次回复
      for (let i = 0; i < replyingRoles.length; i++) {
        const role = replyingRoles[i];
        console.log(`🔄 第${i + 1}个回复角色: ${role.name} (ID: ${role.id})`);
        
        // 如果不是第一个角色，添加一些延迟
        if (i > 0) {
          await new Promise(resolve => setTimeout(resolve, chat.groupSettings.replyDelay));
        }
        
        // 生成回复，传递当前回合中前面角色的回复信息
        const reply = await generateRoleReply(role, text, chat, false, currentRoundReplies);
        
        // 将这个角色的回复添加到当前回合回复列表中，供后续角色参考
        if (reply) {
          currentRoundReplies.push({
            roleId: role.id,
            roleName: role.name,
            content: reply,
            order: i + 1
          });
          console.log(`📝 角色 ${role.name} 的回复已添加到当前回合，供后续角色参考`);
        }
      }

      // 如果检测到需要转账，随机选择一个角色发送转账
      if (moneyDetection.detected && replyingRoles.length > 0) {
        const randomRole = replyingRoles[Math.floor(Math.random() * replyingRoles.length)];
        console.log(`💰 群聊转账由角色 ${randomRole.name} 发送`);
        
        setTimeout(async () => {
          await handleSmartTransfer(text, randomRole.name, moneyDetection, randomRole.id);
        }, 3000); // 等所有角色回复和表情包发送完成后再发送转账
      }

      // 延迟保存聊天记录
      setTimeout(() => saveCurrentChatData(), moneyDetection.detected ? 4000 : 1500);
    }

    // 选择活跃的角色
    function selectActiveRoles(roles, userText) {
      const activeRoles = [];
      
      roles.forEach(role => {
        const shouldReply = shouldRoleReply(role, userText);
        if (shouldReply) {
          activeRoles.push(role);
        }
      });
      
      console.log(`角色回复情况: ${roles.map(r => `${r.name}(${r.frequency || 'always'}): ${shouldRoleReply(r, userText) ? '回复' : '不回复'}`).join(', ')}`);
      
      return activeRoles;
    }

    // 判断角色是否应该回复
    function shouldRoleReply(role, userText) {
      // 如果用户消息中提到了角色名字，优先回复
      if (userText.includes(role.name)) {
        return true;
      }
      
      // 根据频率设置随机决定
      const frequencies = {
        'always': 1.0,    // 100% 回复
        'often': 0.7,     // 70% 回复
        'sometimes': 0.4, // 40% 回复
        'rarely': 0.15    // 15% 回复
      };
      
      const threshold = frequencies[role.frequency] || 1.0;
      return Math.random() < threshold;
    }

    // 生成角色回复
    async function generateRoleReply(role, userText, chat, shouldDetectMoney = true, currentRoundReplies = []) {
      console.log(`🎭 开始生成角色回复: ${role.name} (ID: ${role.id})`);
      
      // 创建该角色的消息气泡
      const thinkingMsg = `${role.name}正在回复...`;
      const aiMsgBubble = appendMsg('ai', thinkingMsg, true, role.id, role.name);

      try {
        // 构建包含该角色设定的消息，传递当前回合的回复信息
        const messages = buildMessagesForRole(role, userText, chat, currentRoundReplies);
        
        console.log(`📝 ${role.name}的消息构建完成，系统提示包含角色: ${role.name}`);
        if (currentRoundReplies.length > 0) {
          console.log(`🤝 ${role.name}可以看到前面${currentRoundReplies.length}个角色的回复: ${currentRoundReplies.map(r => r.roleName).join(', ')}`);
        }
        
        // 调用API获取回复
        const aiReply = await callChatAPI(messages);
        
        console.log(`💬 ${role.name}的API回复: ${aiReply.substring(0, 50)}...`);
        
        // 处理回复显示
        await handleNonStreamResponse(aiReply, aiMsgBubble, role.id, role.name);
        
        // 添加到对话历史
        window.conversationHistory.push({
          role: "assistant",
          content: aiReply,
          roleId: role.id,
          roleName: role.name
        });
        
        console.log(`✅ ${role.name}回复完成，添加到历史记录`);
        
        // 发送表情包
        sendEmojiAlways(userText, aiReply, role.id, role.name);
        
        // 返回生成的回复内容，供后续角色参考
        return aiReply;
        
      } catch (e) {
        console.error(`❌ ${role.name}回复失败:`, e);
        updateStreamingMsg(aiMsgBubble, `${role.name}回复失败: ${e.message}`);
        finishStreamingMsg(aiMsgBubble);
        return null; // 回复失败时返回null
      }
    }

    // 为特定角色构建消息
    function buildMessagesForRole(role, userMessage, chat, currentRoundReplies = []) {
      let messages = [];
      
      // 构建系统提示
      let systemPrompts = [];
      
      // 先添加角色设定
      if (role.description) {
        const rolePrompt = `你现在要扮演一个角色，角色名字是"${role.name}"。角色设定如下：${role.description}`;
        systemPrompts.push(rolePrompt);
        console.log(`🎭 为角色 ${role.name} (ID: ${role.id}) 构建系统提示`);
      }
      
      // 添加群聊设定和当前回合互动信息
      let groupChatPrompt = `你现在处于一个群聊环境中，可能有其他角色也会回复用户。
重要提醒：
1. 你只能扮演"${role.name}"这一个角色，严格保持自己的角色设定和性格特点
2. 不要模仿或扮演其他角色的说话方式和性格
3. 其他角色的发言只是对话背景，你要以自己的角色身份来回应
4. 请根据你的角色设定自然地回复，保持角色一致性`;
      
      // 如果有当前回合中前面角色的回复，添加互动提示
      if (currentRoundReplies && currentRoundReplies.length > 0) {
        groupChatPrompt += '\n\n在这一轮对话中，已经有以下角色回复了用户：';
        currentRoundReplies.forEach((reply, index) => {
          groupChatPrompt += `\n${index + 1}. ${reply.roleName}：${reply.content}`;
        });
        groupChatPrompt += `\n\n你可以参考这些回复内容，与其他角色进行自然的互动，比如：回应其他角色的观点、补充信息、表达不同看法、或者与其他角色对话。
重要：请始终保持作为"${role.name}"的角色设定，不要混淆自己和其他角色的身份，自然地融入群聊氛围。`;
      }
      
      systemPrompts.push(groupChatPrompt);
      
      // 添加用户设定
      if (chat.userDescription) {
        const userPrompt = chat.userName ? 
          `对话的用户名字是"${chat.userName}"，用户信息如下：${chat.userDescription}。请根据用户设定调整你的互动方式。` :
          `对话的用户信息如下：${chat.userDescription}。请根据用户设定调整你的互动方式。`;
        systemPrompts.push(userPrompt);
      } else if (chat.userName) {
        systemPrompts.push(`对话的用户名字是"${chat.userName}"。`);
      }
      
      // 添加气泡分割说明和回复格式要求
      const bubbleSplitPrompt = `=== 重要：回复格式要求（必须严格遵循）===
1. 用（）包裹动作描述
2. 严格遵循使用反斜线\\分隔句子的要求，每个句子控制在50字以内
3. 回复输出示例格式：第一句话\\第二句话\\第三句话

群聊对话示例：
用户：大家觉得今天天气怎么样？
${role.name}回复：今天天气真不错\\很适合出门呢

用户：最近在忙什么？
${role.name}回复：在学习新技能\\进展还不错\\很有收获

用户：你们好可爱
${role.name}回复：(害羞地低下头)谢谢夸奖\\人家会不好意思的

用户：拍了拍你
${role.name}回复：(轻轻拍回去)你也拍拍我呀\\我们一起玩

请严格按照以上格式要求回复，这是必须遵循的规则。`;
      systemPrompts.push(bubbleSplitPrompt);

      // 最后添加预设提示词（优先级最高，离用户消息最近）
      if (aiCustomPrompt) {
        systemPrompts.push('=== 重要约束条件 ===');
        systemPrompts.push(aiCustomPrompt);
        systemPrompts.push('请严格遵守以上约束条件，这些条件具有最高优先级。');
        console.log('🎯 群聊预设提示词已添加（最高优先级）:', aiCustomPrompt.substring(0, 100) + (aiCustomPrompt.length > 100 ? '...' : ''));
      } else {
        console.log('⚠️ 群聊预设提示词为空或未设置');
      }
      
      // 如果有系统提示，添加到消息中
      if (systemPrompts.length > 0) {
        const systemContent = systemPrompts.join('\n\n');
        messages.push({
          role: "system",
          content: systemContent
        });
        console.log('📋 群聊系统提示构建完成，共', systemPrompts.length, '个部分，总长度:', systemContent.length);
        console.log('📋 系统提示内容预览:', systemContent.substring(0, 200) + (systemContent.length > 200 ? '...' : ''));
      } else {
        console.log('⚠️ 群聊没有系统提示');
      }
      
      // 添加最近的对话历史（根据用户设置的上下文长度）
      // 在群聊中，让角色能够看到其他角色的完整回复以增加互动感
      const maxHistory = aiContextLength * 2; // 每轮对话包含用户消息和AI回复，所以乘以2
      const allHistory = window.conversationHistory.slice(-maxHistory);
      
      // 构建包含角色互动的对话历史
      const interactiveHistory = [];
      for (const msg of allHistory) {
        if (msg.role === 'user') {
          // 保留所有用户消息
          interactiveHistory.push(msg);
        } else if (msg.role === 'assistant') {
          if (msg.roleId === role.id) {
            // 保留该角色自己的回复
            interactiveHistory.push(msg);
          } else {
            // 其他角色的回复应该标记为user角色，这样当前角色不会认为是自己说的
            // 避免角色混淆和扮演串台
            interactiveHistory.push({
              role: 'user',
              content: `[群聊中的${msg.roleName || '其他角色'}]: ${msg.content}`
            });
          }
        }
      }
      
      console.log(`📚 ${role.name}的互动对话历史: 共${allHistory.length}条记录，处理后${interactiveHistory.length}条`);
      
      messages = messages.concat(interactiveHistory);
      
      // 添加当前用户消息
      messages.push({
        role: "user",
        content: userMessage
      });
      
      return messages;
    }

    // 调用聊天API
    async function callChatAPI(messages) {
      const baseChatEndpoint = getChatEndpoint(apiURL);
      
      // 根据不同API提供商构建请求
      let chatEndpoint, headers, requestBody;
      
      try {
        const url = new URL(apiURL);
        
        if (url.hostname === 'generativelanguage.googleapis.com') {
          // Google Gemini API
          chatEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;
          headers = {
            'Content-Type': 'application/json'
          };
          
          // 转换消息格式为Gemini格式
          const contents = [];
          let systemPrompt = '';
          
          // 先收集系统消息
          messages.forEach(msg => {
            if (msg.role === 'system') {
              systemPrompt += (systemPrompt ? '\n' : '') + msg.content;
            }
          });
          
          console.log('🔧 Gemini API系统提示长度:', systemPrompt.length);
          if (systemPrompt.length > 0) {
            console.log('🔧 Gemini API系统提示预览:', systemPrompt.substring(0, 200) + (systemPrompt.length > 200 ? '...' : ''));
          }
          
          // 转换用户和助手消息
          messages.forEach(msg => {
            if (msg.role === 'user') {
              let userContent = msg.content;
              // 将系统提示添加到第一个用户消息中
              if (systemPrompt && contents.length === 0) {
                userContent = systemPrompt + '\n\n' + userContent;
                systemPrompt = ''; // 标记已添加
              }
              contents.push({
                role: 'user',
                parts: [{ text: userContent }]
              });
            } else if (msg.role === 'assistant') {
              contents.push({
                role: 'model',
                parts: [{ text: msg.content }]
              });
            }
          });
          
          requestBody = JSON.stringify({
            contents: contents,
            generationConfig: {
              temperature: 0.7,
              maxOutputTokens: 800,
              topK: 40,
              topP: 0.95
            },
            safetySettings: [
              {
                category: "HARM_CATEGORY_HARASSMENT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_HATE_SPEECH", 
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              }
            ]
          });
        } else {
          // OpenAI/DeepSeek格式
          chatEndpoint = baseChatEndpoint;
          headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          };
          
          requestBody = JSON.stringify({
            model: selectedModel,
            messages: messages,
            max_tokens: 800,
            temperature: 0.7,
            stream: false // 群聊暂不使用流式，避免复杂度
          });
        }
      } catch (e) {
        // 默认使用OpenAI格式
        chatEndpoint = baseChatEndpoint;
        headers = {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        };
        
        requestBody = JSON.stringify({
          model: selectedModel,
          messages: messages,
          max_tokens: 800,
          temperature: 0.7,
          stream: false
        });
      }
      
      const response = await fetchWithRetry(chatEndpoint, {
        method: 'POST',
        headers: headers,
        body: requestBody,
        timeout: 25000 // 群聊请求使用25秒超时
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const url = new URL(apiURL);
      
      if (url.hostname === 'generativelanguage.googleapis.com') {
        // 处理Gemini API响应
        const data = await response.json();
        let aiReply = '';
        
        // 检查是否有错误
        if (data.error) {
          throw new Error(`Gemini API错误: ${data.error.message} (${data.error.code})`);
        }
        
        if (data.candidates && data.candidates.length > 0) {
          const candidate = data.candidates[0];
          
          // 检查是否被安全过滤器阻止
          if (candidate.finishReason === 'SAFETY') {
            aiReply = '抱歉，由于安全策略，我无法回复这个问题。';
          } else if (candidate.finishReason === 'RECITATION') {
            aiReply = '抱歉，检测到可能的版权内容，无法提供回复。';
          } else if (candidate.content && candidate.content.parts) {
            aiReply = candidate.content.parts.map(part => part.text || '').join('').trim();
          }
        }
        
        return aiReply || 'Gemini API未返回有效内容';
      } else {
        // 处理OpenAI格式响应
        const data = await response.json();
        return data.choices?.[0]?.message?.content || data.reply || data.response || 'AI未返回内容';
      }
    }

    // 事件监听
    
    // 聊天列表相关事件
    newChatBtn.onclick = createNewChat;
    newGroupChatBtn.onclick = createNewGroupChat;
    
    backBtn.onclick = () => {
      // 保存当前聊天数据再返回
      saveCurrentChatData();
      showChatList();
    };

    // 群聊角色管理事件
    addRoleBtn.onclick = addRole;
    
    // 角色编辑弹窗事件
    closeRoleEditModal.onclick = () => {
      roleEditModal.style.display = 'none';
    };
    
    cancelRoleEditBtn.onclick = () => {
      roleEditModal.style.display = 'none';
    };
    
    saveRoleEditBtn.onclick = saveRoleEdit;
    
    modalRolePresetSelect.onchange = handleModalRolePresetChange;
    
    // 点击弹窗外部关闭
    roleEditModal.onclick = (e) => {
      if (e.target === roleEditModal) {
        roleEditModal.style.display = 'none';
      }
    };

    // 聊天界面相关事件
    settingsBtn.onclick = () => {
      settingsPanel.classList.toggle('show');
      // 如果设置面板正在显示，则隐藏其他面板
      if (settingsPanel.classList.contains('show')) {
        emojiPanel.classList.remove('show');
        rolePanel.classList.remove('show');
        userPanel.classList.remove('show');
      }
    };

    roleBtn.onclick = () => {
      rolePanel.classList.toggle('show');
      // 如果角色设定面板正在显示，则隐藏其他面板
      if (rolePanel.classList.contains('show')) {
        userPanel.classList.remove('show');
        settingsPanel.classList.remove('show');
        emojiPanel.classList.remove('show');
      }
    };

    userBtn.onclick = () => {
      userPanel.classList.toggle('show');
      // 如果用户设定面板正在显示，则隐藏其他所有面板
      if (userPanel.classList.contains('show')) {
        rolePanel.classList.remove('show');
        settingsPanel.classList.remove('show');
        emojiPanel.classList.remove('show');
      }
    };

    emojiBtn.onclick = () => {
      emojiPanel.classList.toggle('show');
      // 如果表情面板正在显示，则隐藏其他面板
      if (emojiPanel.classList.contains('show')) {
        settingsPanel.classList.remove('show');
        rolePanel.classList.remove('show');
        userPanel.classList.remove('show');
        // 确保默认情绪是选中状态
        currentEmotion = 'happy';
        document.querySelectorAll('.emotion-tab').forEach(tab => {
          tab.classList.remove('active');
          if (tab.dataset.emotion === 'happy') {
            tab.classList.add('active');
          }
        });
        updateEmojiGallery();
      }
    };

    // 表情包相关事件监听
    document.querySelectorAll('.emotion-tab').forEach(tab => {
      tab.onclick = () => switchEmotion(tab.dataset.emotion);
    });

    addEmojiBtn.onclick = addEmoji;

    closeEmojiBtn.onclick = () => {
      emojiPanel.classList.remove('show');
    };

    newEmojiInput.onkeydown = function(e) {
      if (e.key === 'Enter') addEmoji();
    };

    // AI设置相关事件监听
    const aiSettingsBtn = document.getElementById('aiSettingsBtn');
    const aiSettingsPanel = document.getElementById('aiSettingsPanel');
    const contextLengthInput = document.getElementById('contextLengthInput');
    const responseDelayInput = document.getElementById('responseDelayInput');
    const aiPromptInput = document.getElementById('aiPromptInput');
    const promptCharCount = document.getElementById('promptCharCount');
    const saveAISettingsBtn = document.getElementById('saveAISettingsBtn');
    const closeAISettingsBtn = document.getElementById('closeAISettingsBtn');

    aiSettingsBtn.onclick = () => {
      // 如果面板已经显示，则隐藏
      if (aiSettingsPanel.classList.contains('show')) {
        aiSettingsPanel.classList.remove('show');
        return;
      }
      
      // 显示AI设置面板，隐藏其他面板
      aiSettingsPanel.classList.add('show');
      settingsPanel.classList.remove('show');
      emojiPanel.classList.remove('show');
      rolePanel.classList.remove('show');
      userPanel.classList.remove('show');
      
      // 加载当前设置值到输入框
      contextLengthInput.value = aiContextLength;
      responseDelayInput.value = aiResponseDelay;
      aiPromptInput.value = aiCustomPrompt;
      updatePromptCharCount();
      console.log('打开AI设置面板，当前上下文长度:', aiContextLength, '响应延迟:', aiResponseDelay, '预设提示词长度:', aiCustomPrompt.length);
    };

    saveAISettingsBtn.onclick = () => {
      const newContextLength = parseInt(contextLengthInput.value);
      const newResponseDelay = parseInt(responseDelayInput.value);
      const newCustomPrompt = aiPromptInput.value.trim();
      
      if (newContextLength >= 1 && newContextLength <= 50 && newResponseDelay >= 0 && newResponseDelay <= 60) {
        aiContextLength = newContextLength;
        aiResponseDelay = newResponseDelay;
        aiCustomPrompt = newCustomPrompt;
        localStorage.setItem('aiContextLength', aiContextLength.toString());
        localStorage.setItem('aiResponseDelay', aiResponseDelay.toString());
        localStorage.setItem('aiCustomPrompt', aiCustomPrompt);
        aiSettingsPanel.classList.remove('show');
        console.log('AI设置已保存，上下文长度:', aiContextLength, '响应延迟:', aiResponseDelay, '预设提示词长度:', aiCustomPrompt.length);
        console.log('🔧 预设提示词内容:', aiCustomPrompt || '(空)');
        
        // 显示成功提示
        const successMsg = document.createElement('div');
        successMsg.style.cssText = `
          position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
          background: #4CAF50; color: white; padding: 16px 24px; border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10000; font-size: 16px;
        `;
        successMsg.innerHTML = `✅ AI设置已保存！<br>上下文长度: ${aiContextLength} 个气泡<br>响应间隔: ${aiResponseDelay} 秒<br>预设提示词: ${aiCustomPrompt ? '已设置' : '未设置'}`;
        document.body.appendChild(successMsg);
        
        setTimeout(() => {
          if (successMsg.parentNode) {
            successMsg.parentNode.removeChild(successMsg);
          }
        }, 2000);
        
      } else {
        alert('上下文气泡个数必须在1-50之间，响应间隔必须在0-60秒之间！');
      }
    };

    closeAISettingsBtn.onclick = () => {
      aiSettingsPanel.classList.remove('show');
    };

    // 快速设置AI配置的全局函数
    window.setAIConfig = function(contextLength, responseDelay) {
      contextLengthInput.value = contextLength;
      responseDelayInput.value = responseDelay;
    };

    // 更新字符计数
    function updatePromptCharCount() {
      const count = aiPromptInput.value.length;
      promptCharCount.textContent = `${count}/2000`;
      if (count > 1800) {
        promptCharCount.style.color = '#ff4d4f';
      } else if (count > 1500) {
        promptCharCount.style.color = '#fa8c16';
      } else {
        promptCharCount.style.color = '#666';
      }
    }

    // 设置预设提示词模板
    window.setPromptTemplate = function(templateType) {
      const templates = {
        professional: `请保持专业、准确和有帮助的回复风格。
- 提供清晰、结构化的答案
- 使用专业术语时请适当解释
- 如果不确定答案，请诚实说明
- 回复要简洁明了，避免冗余`,
        
        friendly: `请保持友善、轻松和亲切的对话风格。
- 使用温暖、友好的语气
- 适当使用表情符号和轻松的表达
- 主动关心用户的感受
- 回复要自然流畅，像朋友聊天一样`,
        
        creative: `请发挥创意和想象力，提供富有创造性的回复。
- 使用生动、形象的语言描述
- 鼓励创新思维和独特观点
- 适当使用比喻、故事等修辞手法
- 激发用户的创造力和灵感`,
        
        teacher: `请以耐心的教师身份进行指导和解答。
- 循序渐进地解释复杂概念
- 提供具体的例子和实践建议
- 鼓励用户思考和提问
- 根据用户水平调整解释深度`,
        
        clear: ''
      };
      
      const template = templates[templateType];
      if (template !== undefined) {
        aiPromptInput.value = template;
        updatePromptCharCount();
        
        // 显示设置成功提示
        const templateNames = {
          professional: '专业助手',
          friendly: '友善聊天',
          creative: '创意写作',
          teacher: '教学指导',
          clear: '清空提示词'
        };
        
        const tipMsg = document.createElement('div');
        tipMsg.style.cssText = `
          position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
          background: #1890ff; color: white; padding: 12px 20px; border-radius: 6px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 10000; font-size: 14px;
        `;
        tipMsg.innerHTML = `📝 已设置为: ${templateNames[templateType]}`;
        document.body.appendChild(tipMsg);
        
        setTimeout(() => {
          if (tipMsg.parentNode) {
            tipMsg.parentNode.removeChild(tipMsg);
          }
        }, 1500);
      }
    };

    // 预设提示词输入框事件监听
    aiPromptInput.addEventListener('input', updatePromptCharCount);

    // 用户表情包相关事件监听
    userEmojiBtn.onclick = () => {
      if (userEmojiPanel.classList.contains('show')) {
        hideUserEmojiPanel();
      } else {
        showUserEmojiPanel();
      }
    };

    userEmojiClose.onclick = () => {
      hideUserEmojiPanel();
    };

    // 点击面板外部关闭表情包面板
    document.addEventListener('click', (e) => {
      if (userEmojiPanel.classList.contains('show') && 
          !userEmojiPanel.contains(e.target) && 
          !userEmojiBtn.contains(e.target)) {
        hideUserEmojiPanel();
      }
    });

    // 用户表情包功能函数
    function showUserEmojiPanel() {
      // 隐藏其他面板
      hideAllPanels();
      
      // 显示表情包面板
      userEmojiPanel.classList.add('show');
      
      // 加载表情包
      loadUserEmojis();
    }

    function hideUserEmojiPanel() {
      userEmojiPanel.classList.remove('show');
    }

    function hideAllPanels() {
      // 隐藏所有设置面板
      const panels = [
        document.getElementById('settingsPanel'),
        document.getElementById('userPanel'),
        document.getElementById('rolePanel'),
        document.getElementById('emojiPanel'),
        document.getElementById('aiSettingsPanel')
      ];
      
      panels.forEach(panel => {
        if (panel) {
          panel.classList.remove('show');
        }
      });
    }

    function loadUserEmojis() {
      userEmojiGrid.innerHTML = '';
      
      // 确保表情包数据存在
      if (!emojiData || Object.keys(emojiData).length === 0) {
        showEmptyEmojiState();
        return;
      }
      
      // 收集所有表情包（不分类）
      const allEmojis = [];
      Object.values(emojiData).forEach(emotionEmojis => {
        if (Array.isArray(emotionEmojis)) {
          allEmojis.push(...emotionEmojis);
        }
      });
      
      if (allEmojis.length === 0) {
        showEmptyEmojiState();
        return;
      }
      
      // 创建表情包项目
      allEmojis.forEach((emojiUrl, index) => {
        const emojiItem = document.createElement('div');
        emojiItem.className = 'user-emoji-item';
        emojiItem.innerHTML = `<img src="${emojiUrl}" alt="表情包" loading="lazy" onerror="this.parentNode.style.display='none';">`;
        
        // 点击发送表情包
        emojiItem.onclick = () => {
          sendUserEmoji(emojiUrl);
          hideUserEmojiPanel();
        };
        
        userEmojiGrid.appendChild(emojiItem);
      });
    }

    function showEmptyEmojiState() {
      userEmojiGrid.innerHTML = `
        <div class="user-emoji-empty">
          <span class="icon">😊</span>
          <div>暂无表情包</div>
          <div style="font-size: 12px; color: #999; margin-top: 4px;">
            请先在表情包设置中添加表情包
          </div>
        </div>
      `;
    }

    function sendUserEmoji(emojiUrl) {
      if (!currentChatId) {
        alert('请先选择一个聊天！');
        return;
      }
      
      // 生成消息ID和时间戳
      const messageId = generateId();
      const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      
      // 创建表情包消息气泡
      const msgDiv = createEmojiMessage('user', emojiUrl, messageId, timestamp);
      
      // 添加到聊天记录
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (currentChat) {
        const messageData = {
          id: messageId,
          type: 'emoji',
          content: emojiUrl,
          timestamp: timestamp,
          sender: 'user'
        };
        
        currentChat.chatDisplay.push(messageData);
        currentChat.lastMessage = '[表情包]';
        currentChat.lastTime = timestamp;
        
        // 保存数据
        saveCurrentChatData();
        renderChatList();
        
        console.log('用户发送表情包:', emojiUrl);
      }
      
      // 滚动到底部
      setTimeout(() => {
        chatBody.scrollTop = chatBody.scrollHeight;
      }, 100);
    }

    // 创建表情包消息的专用函数
    function createEmojiMessage(role, emojiUrl, messageId, timestamp, roleId = null, roleName = null) {
      const currentChat = chatList.find(c => c.id === currentChatId);
      const isGroupChat = currentChat && currentChat.type === 'group';
      
      const msgDiv = document.createElement('div');
      msgDiv.className = 'msg ' + role + (isGroupChat ? ' group' : '');
      msgDiv.setAttribute('data-message-id', messageId);
      
      // 设置角色ID和名称属性，用于CSS选择器判断连续消息
      if (isGroupChat && role === 'ai' && roleId) {
        msgDiv.setAttribute('data-role-id', roleId);
        msgDiv.setAttribute('data-role-name', roleName || '');
      }
      
      // 群聊中添加角色名称显示
      if (isGroupChat && role === 'ai' && roleName) {
        // 群聊中每个AI消息都显示角色名称
        const roleNameDiv = document.createElement('div');
        roleNameDiv.className = 'role-name';
        roleNameDiv.textContent = roleName;
        msgDiv.appendChild(roleNameDiv);
      }
      
      // 创建头像元素
      const avatar = document.createElement('img');
      avatar.className = 'avatar';
      
      if (role === 'ai') {
        if (isGroupChat && roleId) {
          // 群聊中根据角色ID获取头像
          const roleData = currentChat.roles.find(r => r.id === roleId);
          avatar.src = roleData ? (roleData.avatar || DEFAULT_AI_AVATAR) : DEFAULT_AI_AVATAR;
        } else {
          avatar.src = aiAvatar;
        }
        avatar.alt = roleName || 'AI头像';
      } else {
        avatar.src = userAvatar;
        avatar.alt = '用户头像';
      }
      
      // 头像加载失败时使用默认头像
      avatar.onerror = function() {
        this.src = role === 'ai' ? DEFAULT_AI_AVATAR : DEFAULT_USER_AVATAR;
      };
      
      // 创建气泡容器
      const bubbleContainer = document.createElement('div');
      bubbleContainer.className = 'bubble-container emoji-container-wrapper';
      
      // 创建表情包气泡
      const bubble = document.createElement('div');
      bubble.className = 'bubble emoji-bubble';
      
      // 创建表情包容器，确保正方形显示
      const emojiContainer = document.createElement('div');
      emojiContainer.className = 'emoji-container';
      emojiContainer.style.cssText = 'width: 120px; height: 120px; border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center; background: #f0f0f0; flex-shrink: 0;';
      
      const emojiImg = document.createElement('img');
      emojiImg.src = emojiUrl;
      emojiImg.alt = '表情包';
      emojiImg.style.cssText = 'max-width: 100%; max-height: 100%; object-fit: cover; border-radius: 6px;';
      emojiImg.onerror = function() {
        emojiContainer.innerHTML = '<div style="color: #999; font-size: 12px;">表情包加载失败</div>';
      };
      
      emojiContainer.appendChild(emojiImg);
      bubble.appendChild(emojiContainer);
      
      // 创建独立的时间元素
      const timeElement = document.createElement('div');
      timeElement.className = 'msg-time';
      const timeSpan = document.createElement('span');
      timeSpan.textContent = timestamp;
      timeElement.appendChild(timeSpan);
      
      // 将气泡添加到容器
      bubbleContainer.appendChild(bubble);
      
      msgDiv.appendChild(avatar);
      msgDiv.appendChild(bubbleContainer);
      
      // 添加消息操作菜单
      const msgMenu = document.createElement('div');
      msgMenu.className = 'msg-menu';
      msgMenu.innerHTML = `
        <div class="msg-menu-item" data-action="reply" data-message-id="${messageId}">回复</div>
        <div class="msg-menu-item" data-action="forward" data-message-id="${messageId}">转发</div>
        <div class="msg-menu-item danger" data-action="delete" data-message-id="${messageId}">删除</div>
      `;
      
      // 为菜单项添加点击事件监听器
      msgMenu.addEventListener('click', function(event) {
        event.stopPropagation();
        
        const menuItem = event.target.closest('.msg-menu-item');
        if (menuItem) {
          const action = menuItem.getAttribute('data-action');
          const msgId = menuItem.getAttribute('data-message-id');
          
          switch(action) {
            case 'reply':
              window.replyToMsg(msgId);
              break;
            case 'forward':
              window.forwardMsg(msgId);
              break;
            case 'delete':
              window.deleteMsg(msgId);
              break;
          }
          
          hideMsgMenu();
        }
      });
      
      msgDiv.appendChild(msgMenu);
      
      // 添加长按事件监听器
      addLongPressListener(msgDiv, bubble);
      
      // 添加到聊天界面
      chatBody.appendChild(timeElement);
      chatBody.appendChild(msgDiv);
      
      return msgDiv;
    }

    // 为消息添加长按事件监听器
    function addLongPressListener(msgDiv, bubble) {
      let longPressTimer;
      let startX, startY;
      
      const handleStart = (e) => {
        // 记录初始位置
        if (e.type === 'mousedown') {
          startX = e.clientX;
          startY = e.clientY;
        } else if (e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        }
        
        longPressTimer = setTimeout(() => {
          showMsgMenu(msgDiv, e);
        }, 500); // 500ms长按
      };
      
      const handleMove = (e) => {
        let currentX, currentY;
        if (e.type === 'mousemove') {
          currentX = e.clientX;
          currentY = e.clientY;
        } else if (e.type === 'touchmove') {
          currentX = e.touches[0].clientX;
          currentY = e.touches[0].clientY;
        }
        
        // 如果移动距离超过10px，取消长按
        const distance = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
        if (distance > 10) {
          clearTimeout(longPressTimer);
        }
      };
      
      const handleEnd = () => {
        clearTimeout(longPressTimer);
      };
      
      // 桌面端
      bubble.addEventListener('mousedown', handleStart);
      bubble.addEventListener('mousemove', handleMove);
      bubble.addEventListener('mouseup', handleEnd);
      bubble.addEventListener('mouseleave', handleEnd);
      
      // 移动端
      bubble.addEventListener('touchstart', handleStart);
      bubble.addEventListener('touchmove', handleMove);
      bubble.addEventListener('touchend', handleEnd);
      bubble.addEventListener('touchcancel', handleEnd);
    }

    // 转发模态框事件监听器
    const forwardModal = document.getElementById('forwardModal');
    const forwardClose = document.getElementById('forwardClose');
    const forwardCancel = document.getElementById('forwardCancel');
    const forwardConfirm = document.getElementById('forwardConfirm');
    const forwardSearchInput = document.getElementById('forwardSearchInput');

    forwardClose.onclick = hideForwardModal;
    forwardCancel.onclick = hideForwardModal;
    forwardConfirm.onclick = executeForward;

    // 搜索功能
    forwardSearchInput.oninput = function() {
      renderForwardChatList(this.value);
    };

    // 点击模态框背景关闭
    forwardModal.onclick = function(e) {
      if (e.target === forwardModal) {
        hideForwardModal();
      }
    };

    // 多选工具栏事件监听器
    const multiForwardBtn = document.getElementById('multiForwardBtn');
    const multiDeleteBtn = document.getElementById('multiDeleteBtn');
    const multiCancelBtn = document.getElementById('multiCancelBtn');

    if (multiForwardBtn) {
      multiForwardBtn.onclick = multiForward;
    }
    if (multiDeleteBtn) {
      multiDeleteBtn.onclick = multiDelete;
    }
    if (multiCancelBtn) {
      multiCancelBtn.onclick = exitMultiSelectMode;
    }

    // 聊天记录模态框事件监听器
    const chatRecordModal = document.getElementById('chatRecordModal');
    const chatRecordClose = document.getElementById('chatRecordClose');

    if (chatRecordClose) {
      chatRecordClose.onclick = hideChatRecordModal;
    }

    // 点击模态框背景关闭
    if (chatRecordModal) {
      chatRecordModal.onclick = function(e) {
        if (e.target === chatRecordModal) {
          hideChatRecordModal();
        }
      };
    }

    // 消息操作相关函数
    
    // 显示消息操作菜单
    function showMsgMenu(msgDiv, event) {
      // 先隐藏所有菜单
      hideMsgMenu();
      
      // 隐藏所有其他菜单（额外保险）
      document.querySelectorAll('.msg-menu').forEach(menu => {
        menu.style.display = 'none';
      });
      
      // 移除所有选中状态
      document.querySelectorAll('.msg.selected').forEach(msg => {
        msg.classList.remove('selected');
      });
      
      // 选中当前消息
      msgDiv.classList.add('selected');
      currentSelectedMessage = msgDiv;
      
      // 显示菜单
      const menu = msgDiv.querySelector('.msg-menu');
      menu.style.display = 'block';
      
      // 定位菜单 - 相对于消息气泡定位
      const bubble = msgDiv.querySelector('.bubble');
      const bubbleRect = bubble.getBoundingClientRect();
      const msgRect = msgDiv.getBoundingClientRect();
      const chatBodyRect = chatBody.getBoundingClientRect();
      
      // 重置菜单样式
      menu.style.left = '';
      menu.style.right = '';
      menu.style.top = '';
      menu.style.bottom = '';
      menu.style.transform = '';
      
      // 计算菜单在消息div内的相对位置
      const isUserMsg = msgDiv.classList.contains('user');
      
             if (isUserMsg) {
         // 用户消息气泡在右侧，菜单显示在气泡上方居中
         menu.style.right = '10px';
         menu.style.top = '-55px';
         // 调整箭头位置
         menu.style.setProperty('--arrow-position', '80%');
       } else {
         // AI消息气泡在左侧，菜单显示在气泡上方居中 
         // 考虑头像宽度(移动端50px/桌面端45px)和间距(8px)
         menu.style.left = '48px';
         menu.style.top = '-55px';
         // 调整箭头位置
         menu.style.setProperty('--arrow-position', '30%');
       }
      
      // 显示菜单后检查是否超出屏幕边界
      setTimeout(() => {
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // 水平边界检查
        if (menuRect.left < 10) {
          menu.style.left = '10px';
          menu.style.right = '';
        } else if (menuRect.right > viewportWidth - 10) {
          menu.style.right = '10px';
          menu.style.left = '';
        }
        
        // 垂直边界检查 - 如果菜单超出顶部，显示在气泡下方
        if (menuRect.top < 10) {
          menu.style.top = '10px';
        }
      }, 0);
      
      // 点击其他地方隐藏菜单
      setTimeout(() => {
        document.addEventListener('click', handleDocumentClick, { once: true });
      }, 100);
    }
    
    // 处理文档点击事件
    function handleDocumentClick(event) {
      const clickedElement = event.target;
      
      // 检查是否点击了消息菜单或其内部元素
      const isMenuClick = clickedElement.closest('.msg-menu');
      
      // 检查是否点击了当前选中的消息气泡
      const isSelectedMsgClick = currentSelectedMessage && currentSelectedMessage.contains(clickedElement);
      
      // 如果不是点击菜单、不是点击选中的消息，则隐藏菜单
      if (!isMenuClick && !isSelectedMsgClick) {
        hideMsgMenu();
      } else {
        // 如果点击的是菜单或选中的消息，重新添加点击监听器
        setTimeout(() => {
          document.addEventListener('click', handleDocumentClick, { once: true });
        }, 10);
      }
    }

    // 隐藏消息菜单
    function hideMsgMenu() {
      document.querySelectorAll('.msg-menu').forEach(menu => {
        menu.style.display = 'none';
      });
      document.querySelectorAll('.msg.selected').forEach(msg => {
        msg.classList.remove('selected');
      });
      currentSelectedMessage = null;
    }
    
    // 检查是否是最后一个用户消息
    function isLastUserMsg(messageId) {
      // 从DOM中找到最后一个用户消息
      const allUserMessages = document.querySelectorAll('.msg.user');
      if (allUserMessages.length === 0) {
        return false;
      }
      
      // 获取最后一个用户消息的ID
      const lastUserMessage = allUserMessages[allUserMessages.length - 1];
      const lastMessageId = lastUserMessage.getAttribute('data-message-id');
      
      return lastMessageId === messageId;
    }
    
    // 更新重新生成按钮的显示状态
    function updateRegenerateButtons() {
      // 隐藏所有重新生成按钮
      document.querySelectorAll('[data-action="regenerate"]').forEach(btn => {
        btn.style.display = 'none';
      });
      
      // 从DOM中找到最后一个用户消息并显示其重新生成按钮
      const allUserMessages = document.querySelectorAll('.msg.user');
      if (allUserMessages.length > 0) {
        // 获取最后一个用户消息
        const lastUserMessage = allUserMessages[allUserMessages.length - 1];
        const messageId = lastUserMessage.getAttribute('data-message-id');
        
        if (messageId) {
          const regenerateBtn = document.querySelector(`[data-action="regenerate"][data-message-id="${messageId}"]`);
          if (regenerateBtn) {
            regenerateBtn.style.display = 'block';
          }
        }
      }
    }
    
    // 重新生成消息
    window.regenerateMsg = function(messageId) {
      if (confirm('确定要重新生成回复吗？这将删除该消息之后的所有回复。')) {
        const currentChat = chatList.find(c => c.id === currentChatId);
        if (!currentChat) return;
        
        // 找到要重新生成的用户消息
        const msgIndex = currentChat.chatDisplay.findIndex(msg => msg.id === messageId);
        if (msgIndex === -1) return;
        
        const userMessage = currentChat.chatDisplay[msgIndex];
        if (userMessage.role !== 'user') return;
        
        // 删除该用户消息之后的所有消息（包括AI回复）
        const messagesToDelete = currentChat.chatDisplay.slice(msgIndex + 1);
        
        // 从界面删除这些消息
        messagesToDelete.forEach(msg => {
          const msgDiv = document.querySelector(`[data-message-id="${msg.id}"]`);
          if (msgDiv) {
            // 删除时间元素
            const timeElement = msgDiv.previousElementSibling;
            if (timeElement && timeElement.classList.contains('msg-time')) {
              timeElement.remove();
            }
            msgDiv.remove();
          }
        });
        
        // 从chatDisplay中删除这些消息
        currentChat.chatDisplay = currentChat.chatDisplay.slice(0, msgIndex + 1);
        
        // 重新构建conversationHistory（删除对应的消息）
        if (window.conversationHistory) {
          // 由于conversationHistory没有ID，需要根据内容和时间戳匹配删除
          // 简单的方法是重新构建整个conversationHistory
          window.conversationHistory = [];
          currentChat.chatDisplay.forEach(msg => {
            if (msg.role === 'user') {
              window.conversationHistory.push({
                role: 'user',
                content: msg.content
              });
            } else if (msg.role === 'ai') {
              window.conversationHistory.push({
                role: 'assistant',
                content: msg.content
              });
            }
          });
        }
        
        // 重新生成AI回复
        regenerateAIResponse(userMessage.content, currentChat);
        
        // 更新重新生成按钮状态
        updateRegenerateButtons();
        
        // 保存聊天数据
        saveChatList();
      }
    };
    
    // 重新生成AI回复
    async function regenerateAIResponse(userText, chat) {
      // 直接处理AI回复，不需要重新添加用户消息
      if (chat.type === 'group') {
        // 群聊模式：多角色回复
        await handleGroupChatReply(userText, chat);
      } else {
        // 单聊模式：单角色回复
        await handleSingleChatReply(userText, chat);
      }
    }

    // 删除消息
    window.deleteMsg = function(messageId) {
      if (confirm('确定要删除这条消息吗？')) {
        const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
        if (msgDiv) {
          // 删除界面元素
          const timeElement = msgDiv.previousElementSibling;
          if (timeElement && timeElement.classList.contains('msg-time')) {
            timeElement.remove();
          }
          msgDiv.remove();
          
          // 从聊天记录中删除
          const currentChat = chatList.find(c => c.id === currentChatId);
          if (currentChat) {
            currentChat.chatDisplay = currentChat.chatDisplay.filter(msg => msg.id !== messageId);
            // 也要从对话历史中删除对应的消息
            // 这里需要根据消息内容匹配删除，因为conversationHistory没有ID
            saveChatList();
            // 更新重新生成按钮状态
            updateRegenerateButtons();
           }
         }
       }
     };
    
    // 回复消息
    window.replyToMsg = function(messageId) {
      const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
      if (msgDiv) {
        const bubble = msgDiv.querySelector('.bubble');
        const content = bubble.textContent || bubble.innerText;
        const role = msgDiv.classList.contains('ai') ? 'ai' : 'user';
        const roleName = msgDiv.getAttribute('data-role-name') || '';
        
        replyToMessage = {
          id: messageId,
          content: content,
          role: role,
          fromName: role === 'user' ? (userName || '用户') : (roleName || 'AI')
        };
        
        // 显示回复状态
        showReplyStatus();
        
        // 聚焦到输入框
        chatInput.focus();
      }
    };
    
    // 显示回复状态
    function showReplyStatus() {
      // 移除已有的回复状态
      const existingReply = document.querySelector('.reply-status');
      if (existingReply) {
        existingReply.remove();
      }
      
      if (replyToMessage) {
        const replyStatus = document.createElement('div');
        replyStatus.className = 'reply-status';
        replyStatus.style.cssText = `
          background: #f0f0f0; padding: 12px 16px;
          border-left: 3px solid #1890ff; font-size: 12px; color: #666;
          display: flex; justify-content: space-between; align-items: center;
        `;
        
        replyStatus.innerHTML = `
          <div>
            <div style="color: #1890ff; font-weight: bold;">回复 ${replyToMessage.fromName}</div>
            <div>${replyToMessage.content.length > 30 ? replyToMessage.content.substring(0, 30) + '...' : replyToMessage.content}</div>
          </div>
          <button onclick="cancelReply()" style="background: none; border: none; color: #999; cursor: pointer; font-size: 16px;">×</button>
        `;
        
        // 插入到chat-footer上方
        const chatFooter = chatInput.parentNode;
        chatFooter.parentNode.insertBefore(replyStatus, chatFooter);
      }
    }
    
    // 取消回复
    window.cancelReply = function() {
      replyToMessage = null;
      const replyStatus = document.querySelector('.reply-status');
      if (replyStatus) {
        replyStatus.remove();
      }
    };
    
    // 转发消息
    window.forwardMsg = function(messageId) {
      const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
      if (msgDiv) {
        const bubble = msgDiv.querySelector('.bubble');
        const avatar = msgDiv.querySelector('.msg-avatar');
        let content = '';
        
        // 处理不同类型的消息内容
        const forwardMessage = bubble.querySelector('.forward-message');
        const emojiContainer = bubble.querySelector('.emoji-container');
        const chatRecord = bubble.querySelector('.chat-record');
        
        if (chatRecord) {
          // 聊天记录消息
          const recordTitle = chatRecord.querySelector('.chat-record-title span:last-child');
          content = recordTitle ? recordTitle.textContent : '[聊天记录]';
        } else if (forwardMessage) {
          // 转发消息
          const forwardContent = forwardMessage.querySelector('.forward-content');
          content = forwardContent ? forwardContent.textContent : '';
        } else if (emojiContainer) {
          // 表情包消息
          content = '[表情包]';
        } else {
          // 普通文本消息
          const replyReference = bubble.querySelector('.reply-reference');
          if (replyReference) {
            // 移除回复引用后获取内容
            const tempDiv = bubble.cloneNode(true);
            const tempReply = tempDiv.querySelector('.reply-reference');
            if (tempReply) tempReply.remove();
            content = tempDiv.textContent || tempDiv.innerText;
          } else {
            content = bubble.textContent || bubble.innerText;
          }
        }
        
        const role = msgDiv.classList.contains('ai') ? 'ai' : 'user';
        const roleId = msgDiv.getAttribute('data-role-id') || '';
        const roleName = msgDiv.getAttribute('data-role-name') || '';
        
        // 获取头像
        let avatarSrc = '';
        if (avatar) {
          avatarSrc = avatar.src;
        } else {
          avatarSrc = role === 'user' ? (userAvatar || DEFAULT_USER_AVATAR) : (aiAvatar || DEFAULT_AI_AVATAR);
        }
        
        // 获取显示名称（保持与界面一致）
        let displayName = '';
        if (role === 'user') {
          displayName = userName || '用户';
        } else {
          const currentChat = chatList.find(c => c.id === currentChatId);
          if (currentChat && currentChat.type === 'group') {
            displayName = roleName || 'AI';
          } else {
            displayName = roleName || currentChat?.roleName || 'AI';
          }
        }
        
        forwardMessage = {
          id: messageId,
          content: content.trim(),
          role: role,
          roleId: roleId,
          fromName: displayName,
          avatar: avatarSrc,
          chatName: chatList.find(c => c.id === currentChatId)?.name || '当前聊天'
        };
        
        showForwardModal();
      }
    };

    // 显示转发模态框
    function showForwardModal() {
      if (!forwardMessage && forwardMessages.length === 0) return;
      
      const forwardModal = document.getElementById('forwardModal');
      const forwardPreviewContent = document.getElementById('forwardPreviewContent');
      const forwardChatList = document.getElementById('forwardChatList');
      const forwardSearchInput = document.getElementById('forwardSearchInput');
      
      // 显示转发内容预览
      let previewContent = '';
      if (forwardMessages.length > 0) {
        // 多条消息预览
        previewContent = `共${forwardMessages.length}条消息：\n`;
        forwardMessages.forEach((msg, index) => {
          const msgPreview = msg.content.length > 50 ? msg.content.substring(0, 50) + '...' : msg.content;
          previewContent += `${index + 1}. ${msg.fromName}: ${msgPreview}\n`;
        });
        if (previewContent.length > 200) {
          previewContent = previewContent.substring(0, 200) + '...';
        }
      } else if (forwardMessage) {
        // 单条消息预览
        previewContent = forwardMessage.content.length > 100 ? 
          forwardMessage.content.substring(0, 100) + '...' : forwardMessage.content;
      }
      
      forwardPreviewContent.textContent = previewContent;
      
      // 重置搜索和选择
      forwardSearchInput.value = '';
      selectedForwardChats = [];
      
      // 渲染聊天列表（排除当前聊天）
      renderForwardChatList();
      
      // 显示模态框
      forwardModal.classList.add('show');
    }
    
    // 渲染转发聊天列表
    function renderForwardChatList(searchTerm = '') {
      const forwardChatList = document.getElementById('forwardChatList');
      const filteredChats = chatList.filter(chat => {
        if (chat.id === currentChatId) return false; // 排除当前聊天
        if (searchTerm) {
          return chat.name.toLowerCase().includes(searchTerm.toLowerCase());
        }
        return true;
      });
      
      if (filteredChats.length === 0) {
        forwardChatList.innerHTML = '<div style="text-align: center; color: #999; padding: 40px;">没有可转发的聊天</div>';
        return;
      }
      
      forwardChatList.innerHTML = filteredChats.map(chat => {
        const isSelected = selectedForwardChats.includes(chat.id);
        const chatTypeText = chat.type === 'group' ? '群聊' : '单聊';
        const avatarSrc = chat.avatar || (chat.type === 'group' ? DEFAULT_AI_AVATAR : (chat.aiAvatar || DEFAULT_AI_AVATAR));
        
        return `
          <div class="forward-chat-item ${isSelected ? 'selected' : ''}" onclick="toggleForwardChat('${chat.id}')">
            <img class="forward-chat-avatar" src="${avatarSrc}" alt="头像" onerror="this.src='${DEFAULT_AI_AVATAR}'">
            <div class="forward-chat-info">
              <div class="forward-chat-name">${chat.name}</div>
              <div class="forward-chat-desc">${chatTypeText} • ${chat.lastTime || '最近'}</div>
            </div>
            <div class="forward-checkbox ${isSelected ? 'checked' : ''}"></div>
          </div>
        `;
      }).join('');
      
      updateForwardConfirmButton();
    }
    
    // 切换选择聊天
    window.toggleForwardChat = function(chatId) {
      const index = selectedForwardChats.indexOf(chatId);
      if (index > -1) {
        selectedForwardChats.splice(index, 1);
      } else {
        selectedForwardChats.push(chatId);
      }
      
      // 重新渲染列表
      const searchTerm = document.getElementById('forwardSearchInput').value;
      renderForwardChatList(searchTerm);
    };
    
    // 更新确认按钮状态
    function updateForwardConfirmButton() {
      const confirmBtn = document.getElementById('forwardConfirm');
      confirmBtn.disabled = selectedForwardChats.length === 0;
      confirmBtn.textContent = selectedForwardChats.length > 0 ? 
        `发送给 ${selectedForwardChats.length} 个聊天` : '发送';
    }
    
    // 执行转发
    function executeForward() {
      if ((!forwardMessage && forwardMessages.length === 0) || selectedForwardChats.length === 0) return;
      
      selectedForwardChats.forEach(chatId => {
        const targetChat = chatList.find(c => c.id === chatId);
        if (targetChat) {
          if (forwardMessages.length > 0) {
            // 多条消息转发 - 创建聊天记录
            const chatRecordData = {
              messages: forwardMessages.map(msg => ({
                id: msg.id,
                content: msg.content,
                fromName: msg.fromName,
                role: msg.role,
                roleId: msg.roleId,
                timestamp: msg.timestamp,
                avatar: msg.avatar
              })),
              fromChat: forwardMessages[0].chatName
            };
            
            const chatRecordMsgData = {
              id: generateId(),
              role: 'user', // 转发的消息显示为用户发送
              content: `聊天记录 - ${forwardMessages.length}条消息`,
              timestamp: formatMessageTime(),
              type: 'chatRecord',
              chatRecordData: chatRecordData
            };
            
            if (!targetChat.chatDisplay) {
              targetChat.chatDisplay = [];
            }
            targetChat.chatDisplay.push(chatRecordMsgData);
            
            // 更新最后消息显示聊天记录
            targetChat.lastMessage = `[聊天记录] ${forwardMessages.length}条消息`;
            targetChat.lastTime = formatMessageTime();
          } else if (forwardMessage) {
            // 单条消息转发
            const forwardMsgData = {
              id: generateId(),
              role: 'user', // 转发的消息显示为用户发送
              content: forwardMessage.content,
              timestamp: formatMessageTime(),
              type: 'forward',
              forwardFrom: {
                chatName: forwardMessage.chatName,
                fromName: forwardMessage.fromName,
                role: forwardMessage.role
              }
            };
            
            if (!targetChat.chatDisplay) {
              targetChat.chatDisplay = [];
            }
            targetChat.chatDisplay.push(forwardMsgData);
            
            // 更新最后消息
            targetChat.lastMessage = `[转发] ${forwardMessage.content.substring(0, 20)}...`;
            targetChat.lastTime = formatMessageTime();
          }
          
          // 准备AI回复内容
          let combinedForwardContent = '';
          if (forwardMessages.length > 0) {
            // 多条消息聊天记录，AI回复格式
            combinedForwardContent = `[用户转发了一个聊天记录，包含${forwardMessages.length}条消息：\n` + 
              forwardMessages.map(msg => `${msg.fromName}: ${msg.content}`).join('\n') + '\n]';
          } else if (forwardMessage) {
            // 单条消息转发，AI回复格式
            combinedForwardContent = `[用户转发了来自${forwardMessage.fromName}的消息：${forwardMessage.content}]`;
          }
          
          // 如果转发到当前聊天，立即显示并触发AI回复
          if (chatId === currentChatId) {
            // 重新加载当前聊天显示转发的消息
            const currentChat = chatList.find(c => c.id === chatId);
            if (currentChat) {
              loadChatData(currentChat);
            }
            
            if (combinedForwardContent.trim()) {
              // 将转发的消息内容添加到待处理队列
              pendingMessages.push({
                text: combinedForwardContent,
                chat: targetChat,
                timestamp: Date.now(),
                isForwarded: true
              });
              
              // 立即处理AI回复
              if (aiResponseDelay === 0) {
                setTimeout(() => processMessages(), 100); // 短暂延迟确保UI更新完成
              } else {
                startResponseTimer();
              }
            }
          } else {
            // 如果转发到其他聊天，为该聊天添加AI回复任务
            if (combinedForwardContent.trim()) {
              // 为目标聊天创建待处理消息
              if (!targetChat.pendingMessages) {
                targetChat.pendingMessages = [];
              }
              
              targetChat.pendingMessages.push({
                text: combinedForwardContent,
                timestamp: Date.now(),
                isForwarded: true
              });
              
              // 目标聊天会在切换时由AI模型真正回复，这里不生成预设回复
            }
          }
        }
      });
      
      // 保存聊天列表
      saveChatList();
      
      // 重新渲染聊天列表
      renderChatList();
      
      // 关闭转发模态框
      hideForwardModal();
      
      // 显示成功提示
      const successMsg = document.createElement('div');
      successMsg.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: #4CAF50; color: white; padding: 16px 24px; border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10000; font-size: 16px;
      `;
      
      const messageCount = forwardMessages.length > 0 ? forwardMessages.length : 1;
      successMsg.innerHTML = `✅ 已转发${messageCount}条消息到 ${selectedForwardChats.length} 个聊天`;
      document.body.appendChild(successMsg);
      
      setTimeout(() => {
        if (successMsg.parentNode) {
          successMsg.parentNode.removeChild(successMsg);
        }
      }, 2000);
    }
    
    // 隐藏转发模态框
    function hideForwardModal() {
      const forwardModal = document.getElementById('forwardModal');
      forwardModal.classList.remove('show');
      selectedForwardChats = [];
      forwardMessage = null;
      forwardMessages = [];
    }



    // 多选功能相关函数

    // 开始多选模式
    window.startMultiSelect = function(messageId) {
      isMultiSelectMode = true;
      selectedMessages = [];
      
      // 选中触发多选的消息
      if (messageId) {
        selectedMessages.push(messageId);
        const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
        if (msgDiv) {
          msgDiv.classList.add('selected');
        }
      }
      
      // 为聊天界面添加多选模式样式
      const chatContainer = document.querySelector('.chat-container');
      if (chatContainer) {
        chatContainer.classList.add('multi-select-mode');
      }
      
      // 为所有消息添加点击事件
      addMultiSelectListeners();
      
      // 显示多选工具栏
      showMultiSelectToolbar();
      
      // 更新工具栏信息
      updateMultiSelectInfo();
    };

    // 为消息添加多选点击监听器
    function addMultiSelectListeners() {
      const allMessages = document.querySelectorAll('.msg');
      allMessages.forEach(msgDiv => {
        const messageId = msgDiv.getAttribute('data-message-id');
        if (messageId && !msgDiv.hasAttribute('data-multi-select-listener')) {
          msgDiv.setAttribute('data-multi-select-listener', 'true');
          msgDiv.addEventListener('click', handleMultiSelectClick);
        }
      });
    }

    // 处理多选模式下的消息点击
    function handleMultiSelectClick(event) {
      if (!isMultiSelectMode) return;
      
      event.stopPropagation();
      event.preventDefault();
      
      const msgDiv = event.currentTarget;
      const messageId = msgDiv.getAttribute('data-message-id');
      
      if (!messageId) return;
      
      // 切换选中状态
      const index = selectedMessages.indexOf(messageId);
      if (index > -1) {
        selectedMessages.splice(index, 1);
        msgDiv.classList.remove('selected');
      } else {
        selectedMessages.push(messageId);
        msgDiv.classList.add('selected');
      }
      
      // 更新工具栏信息
      updateMultiSelectInfo();
      
      // 如果没有选中任何消息，退出多选模式
      if (selectedMessages.length === 0) {
        exitMultiSelectMode();
      }
    }

    // 显示多选工具栏
    function showMultiSelectToolbar() {
      const toolbar = document.getElementById('multiSelectToolbar');
      if (toolbar) {
        toolbar.classList.add('show');
      }
    }

    // 隐藏多选工具栏
    function hideMultiSelectToolbar() {
      const toolbar = document.getElementById('multiSelectToolbar');
      if (toolbar) {
        toolbar.classList.remove('show');
      }
    }

    // 更新多选信息
    function updateMultiSelectInfo() {
      const infoElement = document.getElementById('multiSelectInfo');
      if (infoElement) {
        infoElement.textContent = `已选择 ${selectedMessages.length} 条消息`;
      }
      
      // 更新按钮状态
      const forwardBtn = document.getElementById('multiForwardBtn');
      const deleteBtn = document.getElementById('multiDeleteBtn');
      
      if (forwardBtn) {
        forwardBtn.disabled = selectedMessages.length === 0;
      }
      if (deleteBtn) {
        deleteBtn.disabled = selectedMessages.length === 0;
      }
    }

    // 退出多选模式
    function exitMultiSelectMode() {
      isMultiSelectMode = false;
      selectedMessages = [];
      
      // 移除多选模式样式
      const chatContainer = document.querySelector('.chat-container');
      if (chatContainer) {
        chatContainer.classList.remove('multi-select-mode');
      }
      
      // 移除所有选中状态
      document.querySelectorAll('.msg.selected').forEach(msg => {
        msg.classList.remove('selected');
      });
      
      // 移除点击监听器
      const allMessages = document.querySelectorAll('.msg[data-multi-select-listener]');
      allMessages.forEach(msgDiv => {
        msgDiv.removeAttribute('data-multi-select-listener');
        msgDiv.removeEventListener('click', handleMultiSelectClick);
      });
      
      // 隐藏工具栏
      hideMultiSelectToolbar();
    }

    // 多选转发
    function multiForward() {
      if (selectedMessages.length === 0) return;
      
      // 构建多条转发消息
      forwardMessages = [];
      
      selectedMessages.forEach(messageId => {
        const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
        if (msgDiv) {
          const bubble = msgDiv.querySelector('.bubble');
          const avatar = msgDiv.querySelector('.msg-avatar');
          let content = '';
          
          // 处理不同类型的消息内容
          const forwardMessage = bubble.querySelector('.forward-message');
          const emojiContainer = bubble.querySelector('.emoji-container');
          const chatRecord = bubble.querySelector('.chat-record');
          
          if (chatRecord) {
            // 聊天记录消息
            const recordTitle = chatRecord.querySelector('.chat-record-title span:last-child');
            content = recordTitle ? recordTitle.textContent : '[聊天记录]';
          } else if (forwardMessage) {
            // 转发消息
            const forwardContent = forwardMessage.querySelector('.forward-content');
            content = forwardContent ? forwardContent.textContent : '';
          } else if (emojiContainer) {
            // 表情包消息
            content = '[表情包]';
          } else {
            // 普通文本消息
            const replyReference = bubble.querySelector('.reply-reference');
            if (replyReference) {
              // 移除回复引用后获取内容
              const tempDiv = bubble.cloneNode(true);
              const tempReply = tempDiv.querySelector('.reply-reference');
              if (tempReply) tempReply.remove();
              content = tempDiv.textContent || tempDiv.innerText;
            } else {
              content = bubble.textContent || bubble.innerText;
            }
          }
          
          const role = msgDiv.classList.contains('ai') ? 'ai' : 'user';
          const roleId = msgDiv.getAttribute('data-role-id') || '';
          const roleName = msgDiv.getAttribute('data-role-name') || '';
          
          // 获取头像
          let avatarSrc = '';
          if (avatar) {
            avatarSrc = avatar.src;
          } else {
            // 根据角色获取默认头像
            avatarSrc = role === 'user' ? (userAvatar || DEFAULT_USER_AVATAR) : (aiAvatar || DEFAULT_AI_AVATAR);
          }
          
          // 获取显示名称（保持与界面一致）
          let displayName = '';
          if (role === 'user') {
            displayName = userName || '用户';
          } else {
            // AI消息，检查是否是群聊
            const currentChat = chatList.find(c => c.id === currentChatId);
            if (currentChat && currentChat.type === 'group') {
              displayName = roleName || 'AI';
            } else {
              displayName = roleName || currentChat?.roleName || 'AI';
            }
          }
          
          // 查找消息时间
          let timestamp = formatMessageTime();
          let prevElement = msgDiv.previousElementSibling;
          if (prevElement && prevElement.classList.contains('msg-time')) {
            const timeSpan = prevElement.querySelector('span');
            if (timeSpan) {
              timestamp = timeSpan.textContent;
            }
          }
          
          forwardMessages.push({
            id: messageId,
            content: content.trim(),
            role: role,
            roleId: roleId,
            fromName: displayName,
            avatar: avatarSrc,
            timestamp: timestamp,
            chatName: chatList.find(c => c.id === currentChatId)?.name || '当前聊天'
          });
        }
      });
      
      // 设置forwardMessage为多条消息的合并版本
      if (forwardMessages.length > 0) {
        forwardMessage = {
          content: forwardMessages.map(msg => msg.content).join('\n'),
          chatName: forwardMessages[0].chatName,
          fromName: forwardMessages.length === 1 ? forwardMessages[0].fromName : '多位用户',
          role: 'multi'
        };
        
        showForwardModal();
      }
      
      // 退出多选模式
      exitMultiSelectMode();
    }

    // 多选删除
    function multiDelete() {
      if (selectedMessages.length === 0) return;
      
      if (confirm(`确定要删除选中的 ${selectedMessages.length} 条消息吗？`)) {
        selectedMessages.forEach(messageId => {
          const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
          if (msgDiv) {
            // 删除界面元素
            const timeElement = msgDiv.previousElementSibling;
            if (timeElement && timeElement.classList.contains('msg-time')) {
              timeElement.remove();
            }
            msgDiv.remove();
            
            // 从聊天记录中删除
            const currentChat = chatList.find(c => c.id === currentChatId);
            if (currentChat) {
              currentChat.chatDisplay = currentChat.chatDisplay.filter(msg => msg.id !== messageId);
            }
          }
        });
        
        // 保存聊天列表
        saveChatList();
        
        // 退出多选模式
        exitMultiSelectMode();
      }
    }

    // 聊天记录相关函数

    // 显示聊天记录详情
    window.showChatRecordDetail = function(chatRecordData) {
      const chatRecordModal = document.getElementById('chatRecordModal');
      const chatRecordModalBody = document.getElementById('chatRecordModalBody');
      const chatRecordModalTitle = document.querySelector('.chat-record-modal-title');
      
      if (!chatRecordModal || !chatRecordModalBody) return;
      
      // 更新模态框标题
      if (chatRecordModalTitle) {
        chatRecordModalTitle.textContent = `${chatRecordData.fromChat}的聊天记录`;
      }
      
      // 生成详细的聊天记录内容
      const detailHtml = chatRecordData.messages.map(msg => `
        <div class="chat-record-detail-item">
          <img class="chat-record-detail-avatar" src="${msg.avatar || DEFAULT_USER_AVATAR}" alt="${msg.fromName}" onerror="this.src='${DEFAULT_USER_AVATAR}'">
          <div class="chat-record-detail-content">
            <div class="chat-record-detail-sender">${msg.fromName}</div>
            <div class="chat-record-detail-text">${msg.content}</div>
            <div class="chat-record-detail-time">${msg.timestamp || formatMessageTime()}</div>
          </div>
        </div>
      `).join('');
      
      chatRecordModalBody.innerHTML = detailHtml;
      chatRecordModal.classList.add('show');
    };

    // 隐藏聊天记录模态框
    function hideChatRecordModal() {
      const chatRecordModal = document.getElementById('chatRecordModal');
      if (chatRecordModal) {
        chatRecordModal.classList.remove('show');
      }
    }

    // 更新现有消息菜单，添加多选选项
    function updateExistingMenus() {
      const allMenus = document.querySelectorAll('.msg-menu');
      allMenus.forEach(menu => {
        const forwardItem = menu.querySelector('[data-action="forward"]');
        const deleteItem = menu.querySelector('[data-action="delete"]');
        const multiSelectItem = menu.querySelector('[data-action="multiSelect"]');
        
        // 如果还没有多选选项，则添加
        if (forwardItem && deleteItem && !multiSelectItem) {
          const messageId = forwardItem.getAttribute('data-message-id');
          const multiSelectDiv = document.createElement('div');
          multiSelectDiv.className = 'msg-menu-item';
          multiSelectDiv.setAttribute('data-action', 'multiSelect');
          multiSelectDiv.setAttribute('data-message-id', messageId);
          multiSelectDiv.textContent = '多选';
          
          // 在删除按钮前插入多选选项
          deleteItem.parentNode.insertBefore(multiSelectDiv, deleteItem);
          
          // 为菜单添加事件委托
          if (!menu.hasAttribute('data-updated')) {
            menu.setAttribute('data-updated', 'true');
            menu.addEventListener('click', function(event) {
              const menuItem = event.target.closest('.msg-menu-item');
              if (menuItem && menuItem.getAttribute('data-action') === 'multiSelect') {
                event.stopPropagation();
                const msgId = menuItem.getAttribute('data-message-id');
                window.startMultiSelect(msgId);
                hideMsgMenu();
              }
            });
          }
        }
      });
    }

    // 在消息加载完成后更新菜单
    function updateMenusAfterLoad() {
      setTimeout(() => {
        updateExistingMenus();
        updateRegenerateButtons();
      }, 100);
    }

    // 文件上传事件监听器
    
    // 表情包文件上传
    uploadEmojiBtn.onclick = () => {
      emojiFileInput.click();
    };
    
    emojiFileInput.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        handleImageUpload(file, null, true);
        e.target.value = ''; // 清空input以允许重复选择同一文件
      }
    };
    
    // AI头像文件上传
    uploadAiAvatarBtn.onclick = () => {
      aiAvatarFileInput.click();
    };
    
    aiAvatarFileInput.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        handleImageUpload(file, aiAvatarInput, false);
        e.target.value = '';
      }
    };
    
    // 用户头像文件上传
    uploadUserAvatarBtn.onclick = () => {
      userAvatarFileInput.click();
    };
    
    userAvatarFileInput.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        handleImageUpload(file, userAvatarInput, false);
        e.target.value = '';
      }
    };
    
    // 群聊角色头像文件上传
    uploadModalRoleAvatarBtn.onclick = () => {
      modalRoleAvatarFileInput.click();
    };
    
    modalRoleAvatarFileInput.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        handleImageUpload(file, modalRoleAvatarInput, false);
        e.target.value = '';
      }
    };

    // 群聊角色视频通话画面文件上传
    const uploadModalRoleVideoBtn = document.getElementById('uploadModalRoleVideoBtn');
    const modalRoleVideoFileInput = document.getElementById('modalRoleVideoFileInput');
    const modalRoleVideoInput = document.getElementById('modalRoleVideoInput');
    
    if (uploadModalRoleVideoBtn && modalRoleVideoFileInput && modalRoleVideoInput) {
      uploadModalRoleVideoBtn.onclick = () => {
        // 检测是否为移动设备
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
          // 移动端显示选择菜单
          showMobileVideoUploadMenu(modalRoleVideoFileInput);
        } else {
          // 桌面端直接打开文件选择器
          modalRoleVideoFileInput.click();
        }
      };
      
      modalRoleVideoFileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (file) {
          if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
            handleVideoCallMediaUpload(file, modalRoleVideoInput);
          } else {
            alert('请选择图片或视频文件');
          }
          e.target.value = '';
        }
      };
    }

    // 预览群聊角色视频通话画面按钮
    const previewModalRoleVideoBtn = document.getElementById('previewModalRoleVideoBtn');
    if (previewModalRoleVideoBtn) {
      previewModalRoleVideoBtn.onclick = () => {
        const videoUrl = document.getElementById('modalRoleVideoInput').value.trim();
        const roleName = document.getElementById('modalRoleNameInput').value.trim() || '角色';
        previewVideoCallMedia(videoUrl, roleName);
      };
    }

    // 单聊AI视频通话画面文件上传
    const uploadAiVideoBtn = document.getElementById('uploadAiVideoBtn');
    const aiVideoFileInput = document.getElementById('aiVideoFileInput');
    const aiVideoInput = document.getElementById('aiVideoInput');
    
    if (uploadAiVideoBtn && aiVideoFileInput && aiVideoInput) {
      uploadAiVideoBtn.onclick = () => {
        // 检测是否为移动设备
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
          // 移动端显示选择菜单
          showMobileVideoUploadMenu(aiVideoFileInput);
        } else {
          // 桌面端直接打开文件选择器
          aiVideoFileInput.click();
        }
      };
      
      aiVideoFileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (file) {
          if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
            handleVideoCallMediaUpload(file, aiVideoInput);
          } else {
            alert('请选择图片或视频文件');
          }
          e.target.value = '';
        }
      };
    }

    // 预览AI视频通话画面按钮
    const previewAiVideoBtn = document.getElementById('previewAiVideoBtn');
    if (previewAiVideoBtn) {
      previewAiVideoBtn.onclick = () => {
        const videoUrl = document.getElementById('aiVideoInput').value.trim();
        const roleName = document.getElementById('roleNameInput').value.trim() || '助手';
        previewVideoCallMedia(videoUrl, roleName);
      };
    }

    // 拖拽上传功能
    const emojiDropArea = document.getElementById('emojiDropArea');
    
    // 防止默认的拖拽行为
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      emojiDropArea.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    // 高亮拖拽区域
    ['dragenter', 'dragover'].forEach(eventName => {
      emojiDropArea.addEventListener(eventName, highlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      emojiDropArea.addEventListener(eventName, unhighlight, false);
    });
    
    function highlight(e) {
      emojiDropArea.classList.add('dragover');
    }
    
    function unhighlight(e) {
      emojiDropArea.classList.remove('dragover');
    }
    
    // 处理文件拖拽
    emojiDropArea.addEventListener('drop', handleDrop, false);
    
    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      if (files.length > 0) {
        const file = files[0];
        if (file.type.startsWith('image/')) {
          handleImageUpload(file, null, true);
        } else {
          alert('请拖拽图片文件');
        }
      }
    }
    
    // 点击拖拽区域也可以选择文件
    emojiDropArea.addEventListener('click', () => {
      emojiFileInput.click();
    });

    // 头像URL输入预览功能
    function setupAvatarPreview(inputElement) {
      inputElement.addEventListener('blur', function() {
        const url = this.value.trim();
        if (url && (url.startsWith('http') || url.startsWith('data:image'))) {
          // 验证是否为有效图片URL
          const img = new Image();
          img.onload = function() {
            addImagePreview(inputElement, url);
          };
          img.onerror = function() {
            // 如果不是有效图片，移除预览
            const previewContainer = inputElement.parentNode.querySelector('.preview-container');
            if (previewContainer) {
              previewContainer.remove();
            }
          };
          img.src = url;
        } else if (!url) {
          // 如果输入框为空，移除预览
          const previewContainer = inputElement.parentNode.querySelector('.preview-container');
          if (previewContainer) {
            previewContainer.remove();
          }
        }
      });
    }

    // 为所有头像输入框设置预览功能
    setupAvatarPreview(aiAvatarInput);
    setupAvatarPreview(userAvatarInput);
    setupAvatarPreview(modalRoleAvatarInput);

    testBtn.onclick = testConnection;
    
    refreshModelsBtn.onclick = () => {
      refreshModelsBtn.disabled = true;
      refreshModelsBtn.textContent = '刷新中...';
      fetchModels().finally(() => {
        refreshModelsBtn.disabled = false;
        refreshModelsBtn.textContent = '刷新模型';
      });
    };
    
    directChatTestBtn.onclick = directChatTest;

    // 硅基流动API连接助手
    const siliconflowApiHelperBtn = document.getElementById('siliconflowApiHelperBtn');
    if (siliconflowApiHelperBtn) {
      siliconflowApiHelperBtn.onclick = showSiliconflowApiHelper;
    }

    // 调试模型按钮 - 显示所有原始数据
    document.getElementById('debugModelsBtn').onclick = async () => {
      const useApiUrl = apiUrlInput.value.trim();
      const useApiKey = apiKeyInput.value.trim();
      
      if (!useApiUrl || !useApiKey) {
        showTestResult('请先填写API地址和秘钥', 'error');
        return;
      }

      const debugBtn = document.getElementById('debugModelsBtn');
      debugBtn.disabled = true;
      debugBtn.textContent = '调试中...';
      
      try {
        const baseUrl = getApiBaseUrl(useApiUrl);
        let modelsUrl;
        
        if (baseUrl.includes('/v1')) {
          modelsUrl = `${baseUrl}/models`;
        } else {
          modelsUrl = `${baseUrl}/v1/models`;
        }
        
        console.log('🔍 调试模式 - 请求URL:', modelsUrl);
        
        const response = await fetchWithRetry(modelsUrl, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${useApiKey}`,
            'Content-Type': 'application/json'
          },
          timeout: 15000 // 调试模式使用15秒超时
        });

        if (response.ok) {
          const data = await response.json();
          console.log('🔍 调试模式 - 原始响应数据:', data);
          
          // 显示原始数据的预览
          const preview = JSON.stringify(data, null, 2);
          const truncatedPreview = preview.length > 500 ? preview.substring(0, 500) + '...' : preview;
          
          showTestResult(`
            <div>调试完成！原始数据已输出到控制台</div>
            <details style="margin-top: 10px;">
              <summary>原始数据预览 (点击展开)</summary>
              <pre style="background: #f5f5f5; padding: 10px; border-radius: 4px; overflow: auto; max-height: 200px; font-size: 11px;">${truncatedPreview}</pre>
            </details>
          `, 'info');
          
          // 尝试解析并显示所有模型（不进行过滤）
          let allModels = [];
          if (data.data && Array.isArray(data.data)) {
            allModels = data.data;
          } else if (data.models && Array.isArray(data.models)) {
            allModels = data.models;
          } else if (Array.isArray(data)) {
            allModels = data;
          }
          
          if (allModels.length > 0) {
            availableModels = allModels.filter(model => model.id).sort((a, b) => a.id.localeCompare(b.id));
            updateModelSelect();
            console.log('🔍 调试模式 - 所有可用模型:', availableModels);
            showTestResult(`调试模式：显示所有 ${availableModels.length} 个模型（未过滤）`, 'success');
          }
        } else {
          const errorText = await response.text();
          console.log('🔍 调试模式 - 请求失败:', response.status, errorText);
          showTestResult(`调试失败: ${response.status} - ${errorText}`, 'error');
        }
      } catch (error) {
        console.log('🔍 调试模式 - 异常:', error);
        showTestResult(`调试异常: ${error.message}`, 'error');
      } finally {
        debugBtn.disabled = false;
        debugBtn.textContent = '🔍 调试模型';
      }
    };

    modelSelect.onchange = updateModelInfo;
    
    rolePresetSelect.onchange = handleRolePresetChange;
    userPresetSelect.onchange = handleUserPresetChange;
    
    // 预设管理事件监听器
    saveRolePresetBtn.onclick = () => saveRolePreset('main');
    manageRolePresetsBtn.onclick = () => managePresets('role', 'main');
    saveUserPresetBtn.onclick = saveUserPreset;
    manageUserPresetsBtn.onclick = () => managePresets('user', 'main');
    saveModalRolePresetBtn.onclick = () => saveRolePreset('modal');
    manageModalRolePresetsBtn.onclick = () => managePresets('role', 'modal');
    
    // 预设管理弹窗事件
    closePresetManageModal.onclick = () => {
      presetManageModal.style.display = 'none';
    };
    closePresetManageBtn.onclick = () => {
      presetManageModal.style.display = 'none';
    };
    presetManageModal.onclick = (e) => {
      if (e.target === presetManageModal) {
        presetManageModal.style.display = 'none';
      }
    };
    
    // 保存预设弹窗事件
    closeSavePresetModal.onclick = () => {
      savePresetModal.style.display = 'none';
    };
    cancelSavePresetBtn.onclick = () => {
      savePresetModal.style.display = 'none';
    };
    confirmSavePresetBtn.onclick = confirmSavePreset;
    savePresetModal.onclick = (e) => {
      if (e.target === savePresetModal) {
        savePresetModal.style.display = 'none';
      }
    };
    
    // API配置管理事件监听器
    loadApiBtn.onclick = loadSelectedApiConfig;
    deleteApiBtn.onclick = deleteSelectedApiConfig;
    newApiConfigBtn.onclick = newApiConfig;
    saveAsNewBtn.onclick = saveAsNewApiConfig;
    updateCurrentBtn.onclick = updateCurrentApiConfig;
    
    // 配置名称输入框变化时更新按钮状态
    apiConfigNameInput.oninput = updateApiConfigButtons;
    
    // 识图API事件监听器
    testVisionBtn.onclick = testVisionConnection;
    refreshVisionModelsBtn.onclick = refreshVisionModels;
    debugVisionModelsBtn.onclick = debugVisionModels;
    visionModelSelect.onchange = function() {
      selectedVisionModel = this.value;
    };
    visionApiUrlInput.oninput = function() {
      visionApiURL = this.value.trim();
    };
    visionApiKeyInput.oninput = function() {
      visionApiKey = this.value.trim();
    };
    
    // 已保存配置选择框变化时更新按钮状态
    savedApiSelect.onchange = updateApiConfigButtons;

    cancelBtn.onclick = () => {
      loadSettings(); // 恢复原来的值
      settingsPanel.classList.remove('show');
      testResult.innerHTML = '';
    };

    saveRoleBtn.onclick = saveRoleSettings;

    cancelRoleBtn.onclick = () => {
      // 恢复当前聊天的角色设定值
      if (currentChatId) {
        const chat = chatList.find(c => c.id === currentChatId);
        if (chat) {
          roleNameInput.value = chat.roleName || '';
          roleDescInput.value = chat.roleDescription || '';
          aiAvatarInput.value = chat.aiAvatar === DEFAULT_AI_AVATAR ? '' : (chat.aiAvatar || '');
        }
      }
      rolePanel.classList.remove('show');
    };

    // 用户设定相关事件
    const saveUserBtn = document.getElementById('saveUserBtn');
    const cancelUserBtn = document.getElementById('cancelUserBtn');

    saveUserBtn.onclick = saveUserSettings;

    cancelUserBtn.onclick = () => {
      // 恢复当前聊天的用户设定值
      if (currentChatId) {
        const chat = chatList.find(c => c.id === currentChatId);
        if (chat) {
          userNameInput.value = chat.userName || '';
          userDescInput.value = chat.userDescription || '';
          userAvatarInput.value = chat.userAvatar === DEFAULT_USER_AVATAR ? '' : (chat.userAvatar || '');
        }
      }
      userPanel.classList.remove('show');
    };

    clearChatBtn.onclick = () => {
      if (confirm('确定要清空当前聊天记录吗？')) {
        clearChat();
        settingsPanel.classList.remove('show');
        rolePanel.classList.remove('show');
      }
    };

    exportChatBtn.onclick = exportChatHistory;

    importChatBtn.onclick = importChatHistory;

    importFileInput.onchange = handleFileImport;

    sendBtn.onclick = sendMsg;

    chatInput.onkeydown = function(e) {
      if (e.key === 'Enter') sendMsg();
    };

    // 初始化应用
    init();
    
    // 位置功能事件监听器
    locationBtn.onclick = showLocationModal;
    locationModalClose.onclick = hideLocationModal;
    locationCancelBtn.onclick = hideLocationModal;
    locationSendBtn.onclick = sendLocationMessage;
    
    // 位置输入框事件监听器
    locationNameInput.oninput = updateLocationPreview;
    locationAddressInput.oninput = updateLocationPreview;
    
    // 位置图片上传事件监听器
    locationImageUpload.onclick = () => {
      locationImageInput.click();
    };
    
    locationImageInput.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        handleLocationImageUpload(file);
      }
    };
    
    // 点击弹窗背景关闭
    locationModal.onclick = (e) => {
      if (e.target === locationModal) {
        hideLocationModal();
      }
    };
    
    // 转账功能事件监听器
    transferBtn.onclick = showTransferModal;
    transferModalClose.onclick = hideTransferModal;
    transferCancelBtn.onclick = hideTransferModal;
    transferSendBtn.onclick = sendTransferMessage;
    
    // 转账输入框事件监听器
    transferAmountInput.oninput = updateTransferPreview;
    transferNoteInput.oninput = updateTransferPreview;
    
    // 点击弹窗背景关闭
    transferModal.onclick = (e) => {
      if (e.target === transferModal) {
        hideTransferModal();
      }
    };
    
    // 图片上传相关事件监听器
    imageBtn.onclick = function() {
      imageFileInput.click();
    };
    
    imageFileInput.onchange = function(e) {
      const file = e.target.files[0];
      if (file) {
        // 可以添加文本描述的功能
        const userText = prompt('请输入对这张图片的描述（可选）：', '');
        sendImageMessage(file, userText || '');
        // 清空文件输入框
        this.value = '';
      }
    };
    
    // 初始化表情包数据验证
    function initEmojiData() {
      // 验证表情包数据是否完整
      const requiredEmotions = ['happy', 'sad', 'angry', 'confused', 'love'];
      let needsReset = false;
      
      if (!emojiData || typeof emojiData !== 'object') {
        needsReset = true;
      } else {
        for (const emotion of requiredEmotions) {
          if (!emojiData[emotion] || !Array.isArray(emojiData[emotion]) || emojiData[emotion].length === 0) {
            needsReset = true;
            break;
          }
        }
      }
      
      if (needsReset) {
        emojiData = JSON.parse(JSON.stringify(DEFAULT_EMOJIS));
        localStorage.setItem('aiChatEmojis', JSON.stringify(emojiData));
      }
    }
    
    // 执行表情包数据初始化
    initEmojiData();

    // 如果没有配置API，显示设置面板
    if (!apiURL || !apiKey || !selectedModel) {
      if (chatList.length === 0) {
        // 如果没有聊天记录，创建一个新聊天并显示设置
        createNewChat();
      settingsPanel.classList.add('show');
      }
    }

    // 获取频率文本
    function getFrequencyText(frequency) {
      const frequencies = {
        'always': '每次都回复',
        'often': '经常回复',
        'sometimes': '偶尔回复',
        'rarely': '很少回复'
      };
      return frequencies[frequency] || '每次都回复';
    }

    // 添加角色
    function addRole() {
      if (!currentChatId) return;
      
      currentEditingRoleIndex = -1;
      roleEditTitle.textContent = '添加角色';
      
      // 清空表单
      modalRolePresetSelect.value = '';
      modalRoleNameInput.value = '';
      modalRoleDescInput.value = '';
      modalRoleAvatarInput.value = '';
      modalRoleFrequencySelect.value = 'always';
      
      roleEditModal.style.display = 'flex';
    }

    // 编辑角色
    function editRole(roleIndex) {
      if (!currentChatId) return;
      
      const chat = chatList.find(c => c.id === currentChatId);
      if (!chat || !chat.roles[roleIndex]) return;
      
      currentEditingRoleIndex = roleIndex;
      roleEditTitle.textContent = '编辑角色';
      
      const role = chat.roles[roleIndex];
      modalRolePresetSelect.value = '';
      modalRoleNameInput.value = role.name || '';
      modalRoleDescInput.value = role.description || '';
      modalRoleAvatarInput.value = role.avatar || '';
      modalRoleVideoInput.value = role.videoCallMedia || '';
      modalRoleFrequencySelect.value = role.frequency || 'always';
      
      roleEditModal.style.display = 'flex';
    }

    // 删除角色
    function deleteRole(roleIndex) {
      if (!currentChatId) return;
      
      const chat = chatList.find(c => c.id === currentChatId);
      if (!chat || !chat.roles[roleIndex]) return;
      
      if (confirm(`确定要删除角色"${chat.roles[roleIndex].name}"吗？`)) {
        chat.roles.splice(roleIndex, 1);
        updateRolesList(chat);
        saveChatList();
      }
    }

    // 保存角色编辑
    function saveRoleEdit() {
      if (!currentChatId) return;
      
      const chat = chatList.find(c => c.id === currentChatId);
      if (!chat) return;
      
      const roleName = modalRoleNameInput.value.trim();
      const roleDesc = modalRoleDescInput.value.trim();
      const roleAvatar = modalRoleAvatarInput.value.trim() || DEFAULT_AI_AVATAR;
      const roleVideo = modalRoleVideoInput.value.trim() || roleAvatar;
      const roleFrequency = modalRoleFrequencySelect.value;
      
      if (!roleName) {
        alert('请输入角色姓名');
        return;
      }
      
      const roleData = {
        id: currentEditingRoleIndex >= 0 ? chat.roles[currentEditingRoleIndex].id : generateId(),
        name: roleName,
        description: roleDesc,
        avatar: roleAvatar,
        videoCallMedia: roleVideo,
        frequency: roleFrequency
      };
      
      if (currentEditingRoleIndex >= 0) {
        // 编辑现有角色
        chat.roles[currentEditingRoleIndex] = roleData;
      } else {
        // 添加新角色
        chat.roles.push(roleData);
      }
      
      updateRolesList(chat);
      saveChatList();
      closeRoleEditModal.click();
    }

    // 处理角色预设选择（弹窗版本）
    function handleModalRolePresetChange() {
      const selectedPreset = modalRolePresetSelect.value;
      if (selectedPreset && rolePresets[selectedPreset]) {
        modalRoleNameInput.value = rolePresets[selectedPreset].name;
        modalRoleDescInput.value = rolePresets[selectedPreset].description;
      }
    }

    // ==================== 朋友圈功能 ====================
    
    // 初始化朋友圈
    function initMoments() {
      // 加载朋友圈数据
      const savedMoments = localStorage.getItem('aiChatMoments');
      if (savedMoments) {
        try {
          moments = JSON.parse(savedMoments);
        } catch (e) {
          console.error('朋友圈数据解析失败:', e);
          moments = [];
        }
      }
      
      // 加载朋友圈设置
      loadMomentsSettings();
      
      // 更新用户信息显示
      updateMomentsUserInfo();
      
      // 初始化可见性选项
      updateVisibilityOptions();
      
      // 渲染朋友圈列表
      renderMoments();
    }
    
    // 保存朋友圈数据
    function saveMoments() {
      localStorage.setItem('aiChatMoments', JSON.stringify(moments));
    }
    
    // 更新用户信息显示
    function updateMomentsUserInfo() {
      const currentUserName = userName || '我';
      const currentUserAvatar = userAvatar || DEFAULT_USER_AVATAR;
      
      // 使用设置中的标题，如果没有则使用默认格式
      const displayTitle = momentsSettings.title || (currentUserName + '的朋友圈');
      momentsUserName.textContent = displayTitle;
      
      momentsUserAvatar.src = currentUserAvatar;
      publishAvatar.src = currentUserAvatar;
      
      // 更新封面背景
      updateMomentsCover();
    }
    
    // 显示朋友圈界面
    function showMoments() {
      chatListView.classList.remove('active');
      chatView.classList.remove('active');
      momentsView.classList.add('active');
      
      // 清除拍一拍计时器
      if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
      }
      
      // 更新用户信息
      updateMomentsUserInfo();
      
      // 渲染朋友圈
      renderMoments();
    }
    
    // 隐藏朋友圈界面
    function hideMoments() {
      momentsView.classList.remove('active');
      chatListView.classList.add('active');
    }
    
    // 渲染朋友圈列表
    function renderMoments() {
      if (moments.length === 0) {
        momentsList.innerHTML = `
          <div style="text-align: center; padding: 60px 20px; color: #999;">
            <div style="font-size: 60px; margin-bottom: 20px;">📸</div>
            <div style="font-size: 16px;">还没有朋友圈动态</div>
          </div>
        `;
        return;
      }
      
      // 按时间倒序排列
      const sortedMoments = [...moments].sort((a, b) => b.timestamp - a.timestamp);
      
      momentsList.innerHTML = sortedMoments.map(moment => {
        return renderMomentItem(moment);
      }).join('');
      
      // 绑定事件
      bindMomentEvents();
    }
    
    // 渲染单个朋友圈动态
    function renderMomentItem(moment) {
      const timeText = formatTime(moment.timestamp);
      const images = moment.images || [];
      const comments = moment.comments || [];
      const likes = moment.likes || 0;
      const isLiked = moment.isLiked || false;
      
      // 生成图片网格
      let imagesHtml = '';
      if (images.length > 0) {
        const gridClass = getImageGridClass(images.length);
        imagesHtml = `
          <div class="moment-images ${gridClass}">
            ${images.map((img, index) => `
              <img class="moment-image" src="${img}" alt="图片${index + 1}" onclick="previewImage('${img}')">
            `).join('')}
          </div>
        `;
      }
      
      // 生成评论
      let commentsHtml = '';
      if (comments.length > 0 || true) { // 总是显示评论区，即使没有评论
        const displayComments = comments.slice(0, 3); // 默认显示前3条评论
        const hasMoreComments = comments.length > 3;
        
        commentsHtml = `
          <div class="moment-comments show" id="comments-${moment.id}">
            <div class="comments-header">
              <div class="comments-title">评论 ${comments.length}</div>
              ${hasMoreComments ? `<button class="comments-toggle" onclick="toggleComments('${moment.id}')" id="toggle-${moment.id}">展开全部</button>` : ''}
            </div>
            <div class="comments-list ${hasMoreComments ? 'collapsed' : ''}" id="list-${moment.id}">
              ${comments.map(comment => renderCommentItem(comment, moment.id)).join('')}
            </div>
            <div class="comment-input-area">
              <div id="reply-indicator-${moment.id}" class="reply-indicator" style="display: none;">
                <span id="reply-text-${moment.id}">正在回复...</span>
                <button class="cancel-reply" onclick="cancelReply('${moment.id}')">取消</button>
              </div>
              <div class="comment-input-container">
                <textarea class="comment-input" id="comment-input-${moment.id}" placeholder="写评论..." 
                  onkeydown="handleCommentKeydown(event, '${moment.id}')"
                  oninput="handleCommentInput(event, '${moment.id}')"></textarea>
                <button class="comment-send-btn" onclick="sendComment('${moment.id}')" id="send-${moment.id}">发送</button>
                <div class="mention-suggestions" id="mentions-${moment.id}"></div>
              </div>
            </div>
          </div>
        `;
      }
      
      return `
        <div class="moment-item" data-moment-id="${moment.id}">
          <div class="moment-header">
            <img class="moment-avatar" src="${moment.avatar}" alt="${moment.author}头像">
            <div class="moment-author-info">
              <div class="moment-author">${moment.author}</div>
            </div>
          </div>
          
          ${moment.content ? `<div class="moment-content-text">${moment.content}</div>` : ''}
          
          ${imagesHtml}
          
          <div class="moment-footer">
            <div class="moment-time">${timeText}</div>
            <div class="moment-actions">
              <button class="moment-like-btn ${isLiked ? 'liked' : ''}" onclick="toggleLike('${moment.id}')">
                <span>${isLiked ? '❤️' : '🤍'}</span>
                <span>${likes > 0 ? likes : ''}</span>
              </button>
              <button class="moment-comment-btn" onclick="commentMoment('${moment.id}')">
                <span>💬</span>
                <span>评论</span>
              </button>
            </div>
          </div>
          
          ${commentsHtml}
        </div>
      `;
    }
    
    // 获取图片网格样式类
    function getImageGridClass(count) {
      switch (count) {
        case 1: return 'single';
        case 2: return 'two';
        case 3: return 'three';
        case 4: return 'four';
        case 5: return 'five';
        case 6: return 'six';
        case 7: return 'seven';
        case 8: return 'eight';
        case 9: return 'nine';
        default: return 'three';
      }
    }
    
    // 渲染单个评论
    function renderCommentItem(comment, momentId) {
      const timeText = formatTime(comment.timestamp);
      let commentText = comment.text;
      
      // 处理回复
      if (comment.replyTo) {
        commentText = `<span class="comment-reply">回复 ${comment.replyTo}:</span> ${commentText}`;
      }
      
      // 处理@提及
      commentText = commentText.replace(/@(\w+)/g, '<span class="comment-mention">@$1</span>');
      
      return `
        <div class="moment-comment" data-comment-id="${comment.id}">
          <span class="comment-author" onclick="replyToComment('${momentId}', '${comment.id}', '${comment.author}')">${comment.author}:</span>
          <span class="comment-text">${commentText}</span>
          <span class="comment-time">${timeText}</span>
          <div class="comment-actions">
            <button class="reply-btn" onclick="replyToComment('${momentId}', '${comment.id}', '${comment.author}')">回复</button>
          </div>
        </div>
      `;
    }
    
    // 格式化时间
    function formatTime(timestamp) {
      const now = new Date();
      const date = new Date(timestamp);
      const diff = now - date;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (minutes < 1) {
        return '刚刚';
      } else if (minutes < 60) {
        return `${minutes}分钟前`;
      } else if (hours < 24) {
        return `${hours}小时前`;
      } else if (days < 7) {
        return `${days}天前`;
      } else {
        const month = date.getMonth() + 1;
        const day = date.getDate();
        return `${month}月${day}日`;
      }
    }
    
    // 显示发布弹窗
    function showPublishModal() {
      publishModal.classList.add('show');
      publishTextarea.value = '';
      selectedImages = [];
      currentVisibleRoles = [];
      renderPublishImages();
      updateVisibilityOptions();
      publishTextarea.focus();
    }
    
    // 隐藏发布弹窗
    function hidePublishModal() {
      publishModal.classList.remove('show');
      publishTextarea.value = '';
      selectedImages = [];
      currentVisibleRoles = [];
    }
    
    // 更新可见性选项
    function updateVisibilityOptions() {
      const allRoles = getAllRoles();
      
      let optionsHtml = '';
      
      // 如果没有选择任何角色，默认选择第一个角色
      if (currentVisibleRoles.includes('all') || currentVisibleRoles.length === 0) {
        currentVisibleRoles = allRoles.length > 0 ? [allRoles[0].id] : [];
      }
      
      // 添加各个角色选项
      allRoles.forEach(role => {
        const isSelected = currentVisibleRoles.includes(role.id);
        optionsHtml += `
          <div class="visibility-option ${isSelected ? 'selected' : ''}" data-visibility="${role.id}">
            ${role.name}
          </div>
        `;
      });
      
      if (allRoles.length === 0) {
        optionsHtml = '<div class="visibility-option disabled">暂无角色</div>';
      }
      
      visibilityOptions.innerHTML = optionsHtml;
      
      // 绑定点击事件
      visibilityOptions.querySelectorAll('.visibility-option:not(.disabled)').forEach(option => {
        option.onclick = () => toggleVisibility(option.dataset.visibility);
      });
    }
    
    // 获取所有角色
    function getAllRoles() {
      const roles = [];
      const roleNameMap = new Map(); // 用于去重相同名称的角色
      
      // 从所有聊天中收集角色
      chatList.forEach(chat => {
        if (chat.type === 'group' && chat.roles) {
          chat.roles.forEach(role => {
            // 使用角色名称去重，避免同一个角色出现多次
            if (!roleNameMap.has(role.name)) {
              roleNameMap.set(role.name, true);
              roles.push({
                id: role.id,
                name: role.name,
                description: role.description,
                avatar: role.avatar
              });
            }
          });
        } else if (chat.type === 'single' && chat.roleName) {
          // 使用角色名称去重，避免同一个角色的多个单聊产生重复标签
          if (!roleNameMap.has(chat.roleName)) {
            roleNameMap.set(chat.roleName, true);
            const roleId = `single_${chat.id}`;
            roles.push({
              id: roleId,
              name: chat.roleName,
              description: chat.roleDescription,
              avatar: chat.aiAvatar
            });
          }
        }
      });
      
      // 按角色名称排序
      return roles.sort((a, b) => a.name.localeCompare(b.name));
    }
    
    // 切换可见性选择
    function toggleVisibility(visibility) {
      const index = currentVisibleRoles.indexOf(visibility);
      if (index >= 0) {
        // 如果已选中，则取消选择
        currentVisibleRoles.splice(index, 1);
        // 如果没有选中任何角色，默认选择第一个可用角色
        if (currentVisibleRoles.length === 0) {
          const allRoles = getAllRoles();
          if (allRoles.length > 0) {
            currentVisibleRoles = [allRoles[0].id];
          }
        }
      } else {
        // 如果未选中，则添加选择
        currentVisibleRoles.push(visibility);
      }
      
      updateVisibilityOptions();
    }
    
    // 添加图片
    function addImages() {
      momentImageInput.click();
    }
    
    // 处理图片选择
    function handleImageSelect(event) {
      const files = Array.from(event.target.files);
      if (files.length === 0) return;
      
      // 限制最多9张图片
      const remainingSlots = 9 - selectedImages.length;
      const filesToProcess = files.slice(0, remainingSlots);
      
      filesToProcess.forEach(file => {
        if (file.type.startsWith('image/') && file.size <= 10 * 1024 * 1024) {
          const reader = new FileReader();
          reader.onload = (e) => {
            selectedImages.push(e.target.result);
            renderPublishImages();
          };
          reader.readAsDataURL(file);
        }
      });
      
      // 清空文件输入
      event.target.value = '';
    }
    
    // 渲染发布图片
    function renderPublishImages() {
      let imagesHtml = '';
      
      // 显示已选择的图片
      selectedImages.forEach((img, index) => {
        imagesHtml += `
          <div class="publish-image-item has-image">
            <img src="${img}" alt="图片${index + 1}">
            <button class="publish-image-remove" onclick="removeImage(${index})">×</button>
          </div>
        `;
      });
      
      // 如果少于9张，显示添加按钮
      if (selectedImages.length < 9) {
        imagesHtml += `
          <div class="publish-image-item" onclick="addImages()">
            <div class="publish-add-image">+</div>
          </div>
        `;
      }
      
      publishImagesContainer.innerHTML = imagesHtml;
    }
    
    // 移除图片
    function removeImage(index) {
      selectedImages.splice(index, 1);
      renderPublishImages();
    }
    
    // 发布朋友圈
    function publishMoment() {
      const content = publishTextarea.value.trim();
      
      if (!content && selectedImages.length === 0) {
        alert('请输入文字或选择图片');
        return;
      }
      
      const moment = {
        id: generateId(),
        author: userName || '我',
        avatar: userAvatar || DEFAULT_USER_AVATAR,
        content: content,
        images: [...selectedImages],
        timestamp: Date.now(),
        visibleTo: [...currentVisibleRoles],
        likes: 0,
        isLiked: false,
        comments: []
      };
      
      moments.unshift(moment);
      saveMoments();
      hidePublishModal();
      renderMoments();
      
      // 生成AI评论
      setTimeout(() => generateAIComments(moment.id), 2000);
    }
    
    // 生成AI评论
    async function generateAIComments(momentId) {
      const moment = moments.find(m => m.id === momentId);
      if (!moment) return;
      
      const allRoles = getAllRoles();
      let visibleRoles = [];
      
      // 直接根据选择的角色ID筛选可见角色
      visibleRoles = allRoles.filter(role => moment.visibleTo.includes(role.id));
      
      // 如果没有找到任何可见角色，可能是旧数据包含'all'，则使用所有角色
      if (visibleRoles.length === 0 && moment.visibleTo.includes('all')) {
        visibleRoles = allRoles;
      }
      
      console.log('👁️ 朋友圈可见角色:', visibleRoles.map(r => r.name));
      
             // 检查API配置
       if (!apiURL || !apiKey || !selectedModel) {
         console.log('❌ API配置不完整，无法生成朋友圈评论');
         return;
       }
       
       // 根据用户设置的评论模式选择角色
       let commentingRoles = [];
       const commentMode = momentsSettings.commentMode || 'smart';
       
       console.log('📋 朋友圈评论模式:', commentMode);
       
       switch (commentMode) {
         case 'none':
           // 关闭AI评论
           console.log('🚫 AI评论已关闭');
           return;
           
         case 'all':
           // 所有可见角色都评论
           commentingRoles = [...visibleRoles];
           console.log('👥 所有可见角色参与评论:', commentingRoles.map(r => r.name));
           break;
           
         case 'random':
           // 随机选择1-3个角色
           commentingRoles = visibleRoles
             .sort(() => Math.random() - 0.5)
             .slice(0, Math.floor(Math.random() * 3) + 1);
           console.log('🎲 随机选择评论角色:', commentingRoles.map(r => r.name));
           break;
           
         case 'smart':
         default:
           // 智能选择评论角色：根据角色数量和内容相关性
           if (visibleRoles.length <= 3) {
             // 如果可见角色不超过3个，全部参与评论
             commentingRoles = [...visibleRoles];
             console.log('👥 智能模式-所有可见角色参与评论:', commentingRoles.map(r => r.name));
           } else {
             // 如果角色较多，使用智能选择策略
             const contentLower = moment.content.toLowerCase();
             
             // 优先选择被提及的角色
             const mentionedRoles = visibleRoles.filter(role => 
               contentLower.includes(role.name.toLowerCase())
             );
             
             // 随机选择其他角色，确保至少有2-4个角色评论
             const otherRoles = visibleRoles.filter(role => 
               !mentionedRoles.includes(role)
             );
             
             // 计算需要的额外角色数量
             const minCommenters = Math.min(2, visibleRoles.length);
             const maxCommenters = Math.min(4, visibleRoles.length);
             const targetCount = Math.floor(Math.random() * (maxCommenters - minCommenters + 1)) + minCommenters;
             
             commentingRoles = [...mentionedRoles];
             
             // 如果被提及的角色不够，随机添加其他角色
             if (commentingRoles.length < targetCount) {
               const shuffledOthers = otherRoles.sort(() => Math.random() - 0.5);
               const needed = targetCount - commentingRoles.length;
               commentingRoles.push(...shuffledOthers.slice(0, needed));
             }
             
             console.log('🧠 智能选择评论角色:', {
               total: visibleRoles.length,
               mentioned: mentionedRoles.map(r => r.name),
               selected: commentingRoles.map(r => r.name),
               target: targetCount
             });
           }
           break;
       }
       
       for (const role of commentingRoles) {
        try {
          // 构建评论请求
                     const messages = [
             { 
               role: 'system', 
               content: `你是${role.name}。角色设定：${role.description}\n请始终保持这个角色的身份、性格和说话方式。` 
             },
                            { 
                 role: 'user', 
                 content: `用户在朋友圈发布了以下内容："${moment.content}"${moment.images.length > 0 ? `并且发布了${moment.images.length}张图片。` : ''}\n请以${role.name}的身份和语气，对这条朋友圈进行简短的评论回复（限制在50字以内）。要符合角色的性格特点。\n\n注意：如果你想发多条评论，可以用反斜杠 \\ 分隔不同的评论内容。` 
               }
           ];
           
           console.log(`📤 为角色 ${role.name} 生成朋友圈评论...`);
           const response = await callChatAPI(messages);
           
                       if (response && response.trim()) {
              // 处理反斜杠分隔的多个评论
              const commentTexts = response.trim().split('\\').map(text => text.trim()).filter(text => text.length > 0);
              
              console.log(`✅ 角色 ${role.name} 生成了 ${commentTexts.length} 条评论:`, commentTexts);
              
              // 为每个评论文本创建单独的评论
              commentTexts.forEach((text, index) => {
                const newComment = {
                  id: generateId(),
                  author: role.name,
                  avatar: role.avatar || DEFAULT_AI_AVATAR,
                  text: text,
                  timestamp: Date.now() + index * 100 // 稍微错开时间戳
                };
                
                moment.comments.push(newComment);
              });
              
              saveMoments();
              renderMoments();
            } else {
              console.log(`❌ 角色 ${role.name} 评论生成失败，API返回空响应`);
            }
        } catch (error) {
          console.error(`角色 ${role.name} 评论失败:`, error);
        }
        
        // 随机延迟1-5秒再评论下一个
        await new Promise(resolve => setTimeout(resolve, Math.random() * 4000 + 1000));
      }
    }
    
    // 切换点赞
    function toggleLike(momentId) {
      const moment = moments.find(m => m.id === momentId);
      if (!moment) return;
      
      moment.isLiked = !moment.isLiked;
      moment.likes += moment.isLiked ? 1 : -1;
      moment.likes = Math.max(0, moment.likes);
      
      saveMoments();
      renderMoments();
    }
    
    // 评论朋友圈（点击评论按钮时聚焦到输入框）
    function commentMoment(momentId) {
      const commentInput = document.getElementById(`comment-input-${momentId}`);
      if (commentInput) {
        commentInput.focus();
        
        // 滚动到评论区
        const commentsSection = document.getElementById(`comments-${momentId}`);
        if (commentsSection) {
          commentsSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    }
    
    // 预览图片
    function previewImage(src) {
      imagePreviewContent.src = src;
      imagePreviewModal.classList.add('show');
    }
    
    // 绑定朋友圈事件
    function bindMomentEvents() {
      // 绑定评论输入框的事件
      document.querySelectorAll('.comment-input').forEach(input => {
        input.addEventListener('input', function() {
          const momentId = this.id.replace('comment-input-', '');
          handleCommentInput({ target: this }, momentId);
        });
        
        input.addEventListener('keydown', function(e) {
          const momentId = this.id.replace('comment-input-', '');
          handleCommentKeydown(e, momentId);
        });
      });
    }
    
    // 切换评论展开/收起
    function toggleComments(momentId) {
      const commentsList = document.getElementById(`list-${momentId}`);
      const toggleBtn = document.getElementById(`toggle-${momentId}`);
      
      if (commentsList.classList.contains('collapsed')) {
        commentsList.classList.remove('collapsed');
        toggleBtn.textContent = '收起';
      } else {
        commentsList.classList.add('collapsed');
        toggleBtn.textContent = '展开全部';
      }
    }
    
    // 回复评论
    function replyToComment(momentId, commentId, authorName) {
      const replyIndicator = document.getElementById(`reply-indicator-${momentId}`);
      const replyText = document.getElementById(`reply-text-${momentId}`);
      const commentInput = document.getElementById(`comment-input-${momentId}`);
      
      currentReplyTo = { momentId, commentId, authorName };
      
      replyIndicator.style.display = 'flex';
      replyText.textContent = `正在回复 ${authorName}`;
      commentInput.placeholder = `回复 ${authorName}...`;
      commentInput.focus();
    }
    
    // 取消回复
    function cancelReply(momentId) {
      const replyIndicator = document.getElementById(`reply-indicator-${momentId}`);
      const commentInput = document.getElementById(`comment-input-${momentId}`);
      
      currentReplyTo = null;
      replyIndicator.style.display = 'none';
      commentInput.placeholder = '写评论...';
    }
    
    // 发送评论
    function sendComment(momentId) {
      const commentInput = document.getElementById(`comment-input-${momentId}`);
      const content = commentInput.value.trim();
      
      if (!content) return;
      
      const moment = moments.find(m => m.id === momentId);
      if (!moment) return;
      
      const comment = {
        id: generateId(),
        author: userName || '我',
        avatar: userAvatar || DEFAULT_USER_AVATAR,
        text: content,
        timestamp: Date.now()
      };
      
      let replyToRoleName = null;
      
      // 如果是回复
      if (currentReplyTo && currentReplyTo.momentId === momentId) {
        comment.replyTo = currentReplyTo.authorName;
        comment.replyToId = currentReplyTo.commentId;
        replyToRoleName = currentReplyTo.authorName;
        
        console.log('📝 用户回复了评论:', {
          replyTo: currentReplyTo.authorName,
          content: content
        });
      }
      
      moment.comments.push(comment);
      saveMoments();
      renderMoments();
      
      // 清空输入
      commentInput.value = '';
      cancelReply(momentId);
      
      // 生成AI回复
      setTimeout(() => {
        // 首先处理@提及的角色
        generateAIReplies(momentId, content);
        
        // 然后处理被回复的角色（如果不是用户自己且没有被@提及）
        if (replyToRoleName && replyToRoleName !== (userName || '我')) {
          const mentions = content.match(/@(\w+)/g);
          const mentionedNames = mentions ? mentions.map(m => m.substring(1)) : [];
          
          // 如果被回复的角色没有被@提及，则自动触发该角色的回复
          if (!mentionedNames.includes(replyToRoleName)) {
            console.log('🎯 自动触发被回复角色的回复:', replyToRoleName);
            generateDirectRoleReply(momentId, content, replyToRoleName);
          }
        }
      }, 1000);
    }
    
    // 处理评论输入
    function handleCommentInput(event, momentId) {
      const input = event.target;
      const value = input.value;
      const cursorPos = input.selectionStart;
      
      // 检查是否输入了@
      const beforeCursor = value.substring(0, cursorPos);
      const atMatch = beforeCursor.match(/@(\w*)$/);
      
      if (atMatch) {
        const query = atMatch[1].toLowerCase();
        showMentionSuggestions(momentId, query, input);
      } else {
        hideMentionSuggestions(momentId);
      }
      
      // 自动调整高度
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 80) + 'px';
    }
    
    // 处理评论按键
    function handleCommentKeydown(event, momentId) {
      const mentionsEl = document.getElementById(`mentions-${momentId}`);
      
      if (mentionsEl.classList.contains('show')) {
        if (event.key === 'ArrowDown') {
          event.preventDefault();
          selectedMentionIndex = Math.min(selectedMentionIndex + 1, mentionSuggestions.length - 1);
          updateMentionSelection(momentId);
        } else if (event.key === 'ArrowUp') {
          event.preventDefault();
          selectedMentionIndex = Math.max(selectedMentionIndex - 1, 0);
          updateMentionSelection(momentId);
        } else if (event.key === 'Enter' && selectedMentionIndex >= 0) {
          event.preventDefault();
          selectMention(momentId, selectedMentionIndex);
        } else if (event.key === 'Escape') {
          hideMentionSuggestions(momentId);
        }
      } else if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendComment(momentId);
      }
    }
    
    // 显示@提及建议
    function showMentionSuggestions(momentId, query, input) {
      const allRoles = getAllRoles();
      const filteredRoles = allRoles.filter(role => 
        role.name.toLowerCase().includes(query)
      );
      
      if (filteredRoles.length === 0) {
        hideMentionSuggestions(momentId);
        return;
      }
      
      mentionSuggestions = filteredRoles;
      selectedMentionIndex = 0;
      
      const mentionsEl = document.getElementById(`mentions-${momentId}`);
      mentionsEl.innerHTML = filteredRoles.map((role, index) => `
        <div class="mention-item ${index === 0 ? 'selected' : ''}" data-index="${index}" onclick="selectMention('${momentId}', ${index})">
          <img class="mention-avatar" src="${role.avatar}" alt="${role.name}">
          <span class="mention-name">${role.name}</span>
        </div>
      `).join('');
      
      mentionsEl.classList.add('show');
    }
    
    // 隐藏@提及建议
    function hideMentionSuggestions(momentId) {
      const mentionsEl = document.getElementById(`mentions-${momentId}`);
      mentionsEl.classList.remove('show');
      mentionSuggestions = [];
      selectedMentionIndex = -1;
    }
    
    // 更新@提及选择
    function updateMentionSelection(momentId) {
      const mentionsEl = document.getElementById(`mentions-${momentId}`);
      const items = mentionsEl.querySelectorAll('.mention-item');
      
      items.forEach((item, index) => {
        if (index === selectedMentionIndex) {
          item.classList.add('selected');
        } else {
          item.classList.remove('selected');
        }
      });
    }
    
    // 选择@提及
    function selectMention(momentId, index) {
      const role = mentionSuggestions[index];
      if (!role) return;
      
      const input = document.getElementById(`comment-input-${momentId}`);
      const value = input.value;
      const cursorPos = input.selectionStart;
      
      // 查找@位置
      const beforeCursor = value.substring(0, cursorPos);
      const atMatch = beforeCursor.match(/@(\w*)$/);
      
      if (atMatch) {
        const newValue = value.substring(0, atMatch.index) + `@${role.name} ` + value.substring(cursorPos);
        input.value = newValue;
        
        // 设置光标位置
        const newCursorPos = atMatch.index + role.name.length + 2;
        input.setSelectionRange(newCursorPos, newCursorPos);
      }
      
      hideMentionSuggestions(momentId);
      input.focus();
    }
    
    // 生成AI回复（处理@提及）
    async function generateAIReplies(momentId, content) {
      console.log('🔍 开始生成AI回复，内容:', content);
      
      // 检查是否有@某个角色
      const mentions = content.match(/@(\w+)/g);
      if (!mentions) {
        console.log('❌ 没有找到@提及');
        return;
      }
      
      console.log('👥 找到@提及:', mentions);
      
      const moment = moments.find(m => m.id === momentId);
      if (!moment) {
        console.log('❌ 找不到对应的朋友圈动态');
        return;
      }
      
      const allRoles = getAllRoles();
      console.log('🎭 所有可用角色:', allRoles.map(r => r.name));
      
      // 检查API配置
      if (!apiURL || !apiKey || !selectedModel) {
        console.log('❌ API配置不完整，无法生成回复');
        console.log('API配置状态:', { apiURL: !!apiURL, apiKey: !!apiKey, selectedModel: !!selectedModel });
        alert('请先在设置中配置API信息才能使用AI角色回复功能');
        return;
      }
      
      console.log('✅ API配置完整:', { apiURL, selectedModel });
      
      for (const mention of mentions) {
        const roleName = mention.substring(1); // 去掉@符号
        const role = allRoles.find(r => r.name === roleName);
        
        if (role) {
          console.log(`🤖 正在为角色 ${role.name} 生成@回复...`);
          
          try {
            const messages = [
              { 
                role: 'system', 
                content: `你是${role.name}。角色设定：${role.description}
                
重要格式要求：
1. 用（）包裹动作描述
2. 严格遵循使用反斜线\\分隔句子的要求，每个句子控制在50字以内
3. 回复输出示例格式：第一句话\\第二句话\\第三句话

请始终保持这个角色的身份、性格和说话方式。` 
              },
              { 
                role: 'user', 
                content: `用户在朋友圈评论中@了你，内容是："${content}"\n请以${role.name}的身份和语气，对这个@你的评论进行简短回复（限制在30字以内）。要符合角色的性格特点。

示例：
用户@评论：@小雪 你好可爱
回复：(害羞)谢谢夸奖\\人家会不好意思的

严格按照格式要求回复。` 
              }
            ];
            
            console.log('📤 发送API请求...');
            const response = await callChatAPI(messages);
            
            console.log('📥 收到API响应:', response);
            
            if (response && response.trim()) {
              // 处理反斜杠分隔的多个回复
              const replyTexts = response.trim().split('\\').map(text => text.trim()).filter(text => text.length > 0);
              
              console.log(`✅ 角色 ${role.name} 生成了 ${replyTexts.length} 条@回复:`, replyTexts);
              
              // 为每个回复文本创建单独的评论
              replyTexts.forEach((text, index) => {
                const newComment = {
                  id: generateId(),
                  author: role.name,
                  avatar: role.avatar || DEFAULT_AI_AVATAR,
                  text: text,
                  timestamp: Date.now() + index * 100, // 稍微错开时间戳
                  replyTo: userName || '我'
                };
                
                moment.comments.push(newComment);
              });
              
              console.log('✅ 添加新@回复评论');
              
              saveMoments();
              renderMoments();
              
              // 显示成功提示
              console.log(`✨ 角色 ${role.name} 已回复@评论`);
            } else {
              console.log('❌ API返回空响应');
            }
          } catch (error) {
            console.error(`❌ 角色 ${role.name} @回复失败:`, error);
            
            // 添加错误处理的提示
            if (error.message.includes('API')) {
              alert(`AI角色回复失败：${error.message}\n请检查API配置是否正确`);
            }
          }
          
          // 延迟回复
          await new Promise(resolve => setTimeout(resolve, 2000));
        } else {
          console.log(`❌ 找不到角色: ${roleName}`);
        }
      }
    }
    
    // 生成直接角色回复（处理直接回复角色评论的情况）
    async function generateDirectRoleReply(momentId, content, roleName) {
      console.log('🎯 开始生成直接角色回复:', { roleName, content });
      
      const moment = moments.find(m => m.id === momentId);
      if (!moment) {
        console.log('❌ 找不到对应的朋友圈动态');
        return;
      }
      
      const allRoles = getAllRoles();
      const role = allRoles.find(r => r.name === roleName);
      
      if (!role) {
        console.log(`❌ 找不到角色: ${roleName}`);
        return;
      }
      
      // 检查API配置
      if (!apiURL || !apiKey || !selectedModel) {
        console.log('❌ API配置不完整，无法生成角色回复');
        return;
      }
      
      console.log(`🤖 正在为角色 ${role.name} 生成直接回复...`);
      
      try {
        const messages = [
          { 
            role: 'system', 
            content: `你是${role.name}。角色设定：${role.description}
            
重要格式要求：
1. 用（）包裹动作描述
2. 严格遵循使用反斜线\\分隔句子的要求，每个句子控制在50字以内
3. 回复输出示例格式：第一句话\\第二句话\\第三句话

请始终保持这个角色的身份、性格和说话方式。` 
          },
          { 
            role: 'user', 
            content: `用户回复了你的朋友圈评论，内容是："${content}"\n请以${role.name}的身份和语气，对用户的回复进行简短的回应（限制在30字以内）。要符合角色的性格特点，表现出被回复时的反应。

示例：
用户回复：你说得对
回复：(开心)是吧\\我也这么觉得

严格按照格式要求回复。` 
          }
        ];
        
        console.log('📤 发送直接回复API请求...');
        const response = await callChatAPI(messages);
        
        console.log('📥 收到直接回复API响应:', response);
        
        if (response && response.trim()) {
          // 处理反斜杠分隔的多个回复
          const replyTexts = response.trim().split('\\').map(text => text.trim()).filter(text => text.length > 0);
          
          console.log(`✅ 角色 ${role.name} 生成了 ${replyTexts.length} 条直接回复:`, replyTexts);
          
          // 为每个回复文本创建单独的评论
          replyTexts.forEach((text, index) => {
            const newComment = {
              id: generateId(),
              author: role.name,
              avatar: role.avatar || DEFAULT_AI_AVATAR,
              text: text,
              timestamp: Date.now() + index * 100 + 1500, // 稍微延迟，让它看起来像是在用户评论后回复的
              replyTo: userName || '我'
            };
            
            moment.comments.push(newComment);
          });
          
          console.log('✅ 添加新直接回复评论');
          
          saveMoments();
          renderMoments();
          
          // 显示成功提示
          console.log(`✨ 角色 ${role.name} 已直接回复用户`);
        } else {
          console.log('❌ 直接回复API返回空响应');
        }
      } catch (error) {
        console.error(`❌ 角色 ${role.name} 直接回复失败:`, error);
      }
    }
    
    // 测试AI回复功能
    async function testAIReply() {
      const testContent = publishTextarea.value.trim() || "测试朋友圈内容";
      const allRoles = getAllRoles();
      
      if (allRoles.length === 0) {
        alert('没有找到任何角色！请先创建聊天并设置角色。');
        return;
      }
      
      if (!apiURL || !apiKey || !selectedModel) {
        alert('请先配置API设置！');
        return;
      }
      
      const testRole = allRoles[0]; // 使用第一个角色测试
      console.log('🧪 测试AI回复功能...');
      console.log('测试角色:', testRole);
      console.log('测试内容:', testContent);
      
      try {
        const messages = [
          { 
            role: 'system', 
            content: `你是${testRole.name}。角色设定：${testRole.description}\n请始终保持这个角色的身份、性格和说话方式。` 
          },
                     { 
             role: 'user', 
             content: `用户在朋友圈发布了以下内容："${testContent}"\n请以${testRole.name}的身份和语气，对这条朋友圈进行简短的评论回复（限制在50字以内）。要符合角色的性格特点。\n\n注意：如果你想发多条评论，可以用反斜杠 \\ 分隔不同的评论内容。` 
           }
        ];
        
        console.log('📤 发送测试请求...');
        const response = await callChatAPI(messages);
        
        if (response && response.trim()) {
          // 处理反斜杠分隔的多个回复
          const testTexts = response.trim().split('\\').map(text => text.trim()).filter(text => text.length > 0);
          
          if (testTexts.length > 1) {
            alert(`✅ AI回复测试成功！\n\n角色: ${testRole.name}\n生成了 ${testTexts.length} 条回复:\n\n${testTexts.map((text, i) => `${i + 1}. ${text}`).join('\n\n')}`);
          } else {
            alert(`✅ AI回复测试成功！\n\n角色: ${testRole.name}\n回复: ${testTexts[0]}`);
          }
          console.log('✅ 测试成功:', testTexts);
        } else {
          alert('❌ AI回复测试失败：API返回空响应');
          console.log('❌ 测试失败：空响应');
        }
      } catch (error) {
        console.error('❌ 测试失败:', error);
        alert(`❌ AI回复测试失败：\n${error.message}`);
      }
    }
    
    // ==================== 朋友圈设置功能 ====================
    
    // 加载朋友圈设置
    function loadMomentsSettings() {
      const savedSettings = localStorage.getItem('aiChatMomentsSettings');
      if (savedSettings) {
        try {
          momentsSettings = JSON.parse(savedSettings);
          // 确保新的设置项存在
          if (!momentsSettings.commentMode) {
            momentsSettings.commentMode = 'smart';
          }
        } catch (e) {
          console.error('朋友圈设置解析失败:', e);
          momentsSettings = {
            title: '我的朋友圈',
            coverImage: '',
            commentMode: 'smart'
          };
        }
      }
    }
    
    // 保存朋友圈设置
    function saveMomentsSettingsData() {
      localStorage.setItem('aiChatMomentsSettings', JSON.stringify(momentsSettings));
    }
    
    // 更新朋友圈封面
    function updateMomentsCover() {
      const momentsHeader = document.querySelector('.moments-header');
      if (momentsSettings.coverImage) {
        momentsHeader.style.backgroundImage = `url('${momentsSettings.coverImage}')`;
      } else {
        // 恢复默认背景
        momentsHeader.style.backgroundImage = `url('${getDefaultCoverUrl()}')`;
      }
    }
    
    // 显示朋友圈设置弹窗
    function showMomentsSettings() {
      // 初始化设置表单
      momentsTitle.value = momentsSettings.title || '我的朋友圈';
      momentsCoverUrl.value = momentsSettings.coverImage || '';
      momentsCommentMode.value = momentsSettings.commentMode || 'smart';
      
      // 更新预览
      updateCoverPreview();
      
      momentsSettingsModal.classList.add('show');
    }
    
    // 隐藏朋友圈设置弹窗
    function hideMomentsSettings() {
      momentsSettingsModal.classList.remove('show');
    }
    
    // 更新封面预览
    function updateCoverPreview() {
      const previewUrl = momentsCoverUrl.value.trim() || momentsSettings.coverImage;
      if (previewUrl) {
        momentsCoverPreview.style.backgroundImage = `url('${previewUrl}')`;
        momentsCoverPreview.textContent = '';
      } else {
        momentsCoverPreview.style.backgroundImage = `url('${getDefaultCoverUrl()}')`;
        momentsCoverPreview.textContent = '默认封面';
      }
    }
    
    // 上传封面图片
    function uploadMomentsCover() {
      momentsCoverFileInput.click();
    }
    
    // 处理封面图片文件选择
    function handleMomentsCoverSelect(event) {
      const file = event.target.file || event.target.files[0];
      if (!file) return;
      
      if (file.type.startsWith('image/') && file.size <= 10 * 1024 * 1024) {
        const reader = new FileReader();
        reader.onload = (e) => {
          momentsCoverUrl.value = e.target.result;
          updateCoverPreview();
        };
        reader.readAsDataURL(file);
      } else {
        alert('请选择有效的图片文件（最大10MB）');
      }
      
      // 清空文件输入
      event.target.value = '';
    }
    
    // 重置为默认封面
    function resetMomentsCover() {
      momentsCoverUrl.value = '';
      updateCoverPreview();
    }
    
    // 获取当前封面URL
    function getCurrentCoverUrl() {
      const momentsHeader = document.querySelector('.moments-header');
      const currentStyle = window.getComputedStyle(momentsHeader);
      const backgroundImage = currentStyle.backgroundImage;
      
      if (backgroundImage && backgroundImage !== 'none') {
        // 提取URL
        const urlMatch = backgroundImage.match(/url\(['"]?([^'"]+)['"]?\)/);
        if (urlMatch && urlMatch[1]) {
          return urlMatch[1];
        }
      }
      
      // 如果没有设置背景图，返回当前设置的封面或默认封面
      return momentsSettings.coverImage || getDefaultCoverUrl();
    }
    
    // 将当前封面设为默认封面
    function setCurrentAsDefault() {
      // 优先使用用户设置的封面，如果没有则使用当前显示的封面
      let currentCoverUrl = momentsSettings.coverImage;
      
      if (!currentCoverUrl) {
        // 如果没有自定义封面，获取当前显示的封面
        currentCoverUrl = getCurrentCoverUrl();
      }
      
      // 如果当前封面就是默认封面，则提示用户
      if (currentCoverUrl === getDefaultCoverUrl()) {
        alert('当前封面已经是默认封面了！');
        return;
      }
      
      const displayUrl = currentCoverUrl.length > 60 ? currentCoverUrl.substring(0, 60) + '...' : currentCoverUrl;
      
      if (confirm(`确定要将当前封面设为朋友圈默认封面吗？\n\n当前封面: ${displayUrl}\n\n设置后，所有新用户和重置封面时都会使用这个图片。`)) {
        // 更新所有默认封面引用
        updateDefaultCoverReferences(currentCoverUrl);
        alert('✅ 已将当前封面设为默认封面！\n\n现在重置封面时会使用这个图片作为默认封面。');
      }
    }
    
    // 更新代码中的默认封面引用
    function updateDefaultCoverReferences(newDefaultUrl) {
      console.log('新的默认封面URL:', newDefaultUrl);
      
      // 保存新的默认封面URL到localStorage
      localStorage.setItem('aiChatDefaultMomentsCover', newDefaultUrl);
      
      // 更新当前页面的默认行为
      window.defaultMomentsCoverUrl = newDefaultUrl;
      
      // 如果当前没有自定义封面，立即应用新默认封面
      if (!momentsSettings.coverImage) {
        const momentsHeader = document.querySelector('.moments-header');
        momentsHeader.style.backgroundImage = `url('${newDefaultUrl}')`;
        updateCoverPreview();
      }
    }
    
    // 获取默认封面URL
    function getDefaultCoverUrl() {
      return localStorage.getItem('aiChatDefaultMomentsCover') || 'https://i.postimg.cc/7Lr42Xqf/IMG-20250618-215711.jpg';
    }
    
    // 保存朋友圈设置
    function saveMomentsSettingsForm() {
      const newTitle = momentsTitle.value.trim() || '我的朋友圈';
      const newCoverImage = momentsCoverUrl.value.trim();
      const newCommentMode = momentsCommentMode.value || 'smart';
      
      momentsSettings.title = newTitle;
      momentsSettings.coverImage = newCoverImage;
      momentsSettings.commentMode = newCommentMode;
      
      saveMomentsSettingsData();
      updateMomentsUserInfo();
      hideMomentsSettings();
      
      // 显示保存成功提示
      alert('朋友圈设置已保存！');
    }
    
    // ==================== 朋友圈设置功能结束 ====================
    
    // 绑定朋友圈相关事件
    momentsBtn.onclick = showMoments;
    momentsBackBtn.onclick = hideMoments;
    momentsSettingsBtn.onclick = showMomentsSettings;
    publishText.onclick = showPublishModal;
    momentsPublishArea.onclick = showPublishModal;
    publishModalClose.onclick = hidePublishModal;
    publishCancel.onclick = hidePublishModal;
    publishConfirm.onclick = publishMoment;
    document.getElementById('testAIReply').onclick = testAIReply;
    momentImageInput.onchange = handleImageSelect;
    addImageBtn.onclick = addImages;
    imagePreviewClose.onclick = () => imagePreviewModal.classList.remove('show');
    
    // 朋友圈设置事件
    momentsSettingsClose.onclick = hideMomentsSettings;
    cancelMomentsSettings.onclick = hideMomentsSettings;
    saveMomentsSettings.onclick = saveMomentsSettingsForm;
    uploadMomentsCoverBtn.onclick = uploadMomentsCover;
    resetMomentsCoverBtn.onclick = resetMomentsCover;
    document.getElementById('setAsDefaultBtn').onclick = setCurrentAsDefault;
    momentsCoverFileInput.onchange = handleMomentsCoverSelect;
    momentsCoverUrl.oninput = updateCoverPreview;
    
    // 点击背景关闭弹窗
    publishModal.onclick = (e) => {
      if (e.target === publishModal) {
        hidePublishModal();
      }
    };
    
    imagePreviewModal.onclick = (e) => {
      if (e.target === imagePreviewModal) {
        imagePreviewModal.classList.remove('show');
      }
    };
    
    momentsSettingsModal.onclick = (e) => {
      if (e.target === momentsSettingsModal) {
        hideMomentsSettings();
      }
    };
    
    // 初始化朋友圈
    initMoments();
    
    // 初始化默认封面
    setTimeout(() => {
      updateMomentsCover();
    }, 100);
    
    // ==================== 朋友圈功能结束 ====================
    
    // ==================== 主题设置功能 ====================
    
    // 主题设置相关变量
    let currentTheme = {
      headerColor: '#6DA3BD',
      chatBgColor: '#f5f5f5',
      chatBgImage: '',
      userBubbleColor: '#95EC69',
      aiBubbleColor: '#FFFFFF',
      fontFamily: '微软雅黑, Arial, sans-serif',
      fontColor: '#333333',
      headerBorderRadius: '10',
      headerOpacity: '1',
      headerShadow: 'normal',
      bubbleBorderRadius: '18',
      bubbleOpacity: '0.95',
      bubbleShadow: 'light',
      bubbleBorder: 'none'
    };
    
    // 自定义字体存储
    let customFonts = [];
    
    // 预设主题
    const themePresets = {
      default: {
        headerColor: '#6DA3BD',
        chatBgColor: '#f5f5f5',
        chatBgImage: '',
        userBubbleColor: '#95EC69',
        aiBubbleColor: '#FFFFFF',
        fontFamily: '微软雅黑, Arial, sans-serif',
        fontColor: '#333333',
        headerBorderRadius: '10',
        headerOpacity: '1',
        headerShadow: 'normal',
        bubbleBorderRadius: '18',
        bubbleOpacity: '0.95',
        bubbleShadow: 'light',
        bubbleBorder: 'none'
      },
      dark: {
        headerColor: '#2c3e50',
        chatBgColor: '#34495e',
        chatBgImage: '',
        userBubbleColor: '#3498db',
        aiBubbleColor: '#2c3e50',
        fontFamily: '微软雅黑, Arial, sans-serif',
        fontColor: '#ecf0f1',
        headerBorderRadius: '10',
        headerOpacity: '1',
        headerShadow: 'normal',
        bubbleBorderRadius: '18',
        bubbleOpacity: '0.95',
        bubbleShadow: 'light',
        bubbleBorder: 'none'
      },
      blue: {
        headerColor: '#3498db',
        chatBgColor: '#ebf3fd',
        chatBgImage: '',
        userBubbleColor: '#5dade2',
        aiBubbleColor: '#ffffff',
        fontFamily: '微软雅黑, Arial, sans-serif',
        fontColor: '#2c3e50',
        headerBorderRadius: '10',
        headerOpacity: '1',
        headerShadow: 'normal',
        bubbleBorderRadius: '18',
        bubbleOpacity: '0.95',
        bubbleShadow: 'light',
        bubbleBorder: 'none'
      },
      green: {
        headerColor: '#27ae60',
        chatBgColor: '#eafaf1',
        chatBgImage: '',
        userBubbleColor: '#58d68d',
        aiBubbleColor: '#ffffff',
        fontFamily: '微软雅黑, Arial, sans-serif',
        fontColor: '#1e8449',
        headerBorderRadius: '10',
        headerOpacity: '1',
        headerShadow: 'normal',
        bubbleBorderRadius: '18',
        bubbleOpacity: '0.95',
        bubbleShadow: 'light',
        bubbleBorder: 'none'
      },
      purple: {
        headerColor: '#8e44ad',
        chatBgColor: '#f4ecf7',
        chatBgImage: '',
        userBubbleColor: '#bb8fce',
        aiBubbleColor: '#ffffff',
        fontFamily: '微软雅黑, Arial, sans-serif',
        fontColor: '#6c3483',
        headerBorderRadius: '10',
        headerOpacity: '1',
        headerShadow: 'normal',
        bubbleBorderRadius: '18',
        bubbleOpacity: '0.95',
        bubbleShadow: 'light',
        bubbleBorder: 'none'
      },
      pink: {
        headerColor: '#e91e63',
        chatBgColor: '#fce4ec',
        chatBgImage: '',
        userBubbleColor: '#f48fb1',
        aiBubbleColor: '#ffffff',
        fontFamily: '微软雅黑, Arial, sans-serif',
        fontColor: '#ad1457',
        headerBorderRadius: '10',
        headerOpacity: '1',
        headerShadow: 'normal',
        bubbleBorderRadius: '18',
        bubbleOpacity: '0.95',
        bubbleShadow: 'light',
        bubbleBorder: 'none'
      }
    };
    
    // 加载主题设置
    function loadThemeSettings() {
      const savedTheme = localStorage.getItem('aiChatThemeSettings');
      if (savedTheme) {
        try {
          currentTheme = { ...currentTheme, ...JSON.parse(savedTheme) };
        } catch (e) {
          console.error('主题设置解析失败:', e);
        }
      }
      applyTheme(currentTheme);
    }
    
    // 保存主题设置
    function saveThemeSettings() {
      localStorage.setItem('aiChatThemeSettings', JSON.stringify(currentTheme));
    }
    
    // 应用主题
    function applyTheme(theme) {
      const root = document.documentElement;
      
      // 应用导航栏样式
      const headers = document.querySelectorAll('.chat-header, .chat-list-header');
      headers.forEach(header => {
        header.style.background = theme.headerColor;
        header.style.borderRadius = `${theme.headerBorderRadius}px ${theme.headerBorderRadius}px 0 0`;
        header.style.opacity = theme.headerOpacity;
        
        // 应用阴影
        const shadowMap = {
          'none': 'none',
          'light': '0 1px 3px rgba(0,0,0,0.1)',
          'normal': '0 2px 8px rgba(0,0,0,0.15)',
          'heavy': '0 4px 16px rgba(0,0,0,0.25)'
        };
        header.style.boxShadow = shadowMap[theme.headerShadow] || shadowMap.normal;
      });
      
      // 应用聊天背景
      const chatBodies = document.querySelectorAll('.chat-body');
      chatBodies.forEach(body => {
        body.style.backgroundColor = theme.chatBgColor;
        if (theme.chatBgImage) {
          body.style.backgroundImage = `url('${theme.chatBgImage}')`;
          body.style.backgroundSize = 'cover';
          body.style.backgroundPosition = 'center';
          body.style.backgroundRepeat = 'no-repeat';
        } else {
          body.style.backgroundImage = 'none';
        }
      });
      
      // 应用消息气泡样式
      const allBubbles = document.querySelectorAll('.bubble');
      allBubbles.forEach(bubble => {
        bubble.style.borderRadius = `${theme.bubbleBorderRadius}px`;
        
        // 应用阴影
        const shadowMap = {
          'none': 'none',
          'light': '0 1px 2px rgba(0,0,0,0.1)',
          'normal': '0 2px 4px rgba(0,0,0,0.1)',
          'heavy': '0 4px 8px rgba(0,0,0,0.15)'
        };
        bubble.style.boxShadow = shadowMap[theme.bubbleShadow] || shadowMap.light;
        
        // 应用边框
        const borderMap = {
          'none': 'none',
          'thin': '1px solid rgba(0,0,0,0.1)',
          'normal': '2px solid rgba(0,0,0,0.1)',
          'thick': '3px solid rgba(0,0,0,0.15)'
        };
        bubble.style.border = borderMap[theme.bubbleBorder] || borderMap.none;
      });
      
      // 应用用户气泡颜色
      const userBubbles = document.querySelectorAll('.msg.user .bubble');
      userBubbles.forEach(bubble => {
        bubble.style.background = `rgba(${hexToRgb(theme.userBubbleColor)}, ${theme.bubbleOpacity})`;
      });
      
      // 应用AI气泡颜色
      const aiBubbles = document.querySelectorAll('.msg.ai .bubble');
      aiBubbles.forEach(bubble => {
        bubble.style.background = `rgba(${hexToRgb(theme.aiBubbleColor)}, ${theme.bubbleOpacity})`;
      });
      
      // 应用字体设置
      document.body.style.fontFamily = theme.fontFamily;
      document.body.style.color = theme.fontColor;
      
      currentTheme = { ...theme };
    }
    
    // 十六进制颜色转RGB
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? 
        `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
        '255, 255, 255';
    }
    
    // 显示主题设置弹窗
    function showThemeSettings() {
      // 初始化表单值
      document.getElementById('headerColorInput').value = currentTheme.headerColor;
      document.getElementById('headerColorText').value = currentTheme.headerColor;
      document.getElementById('chatBgColorInput').value = currentTheme.chatBgColor;
      document.getElementById('chatBgColorText').value = currentTheme.chatBgColor;
      document.getElementById('userBubbleColorInput').value = currentTheme.userBubbleColor;
      document.getElementById('userBubbleColorText').value = currentTheme.userBubbleColor;
      document.getElementById('aiBubbleColorInput').value = currentTheme.aiBubbleColor;
      document.getElementById('aiBubbleColorText').value = currentTheme.aiBubbleColor;
      document.getElementById('chatBgImageInput').value = currentTheme.chatBgImage || '';
      document.getElementById('fontFamilySelect').value = currentTheme.fontFamily;
      document.getElementById('fontColorInput').value = currentTheme.fontColor;
      document.getElementById('fontColorText').value = currentTheme.fontColor;
      
      // 初始化样式设置
      document.getElementById('headerBorderRadiusSlider').value = currentTheme.headerBorderRadius;
      document.getElementById('headerBorderRadiusValue').textContent = currentTheme.headerBorderRadius + 'px';
      document.getElementById('headerOpacitySlider').value = currentTheme.headerOpacity;
      document.getElementById('headerOpacityValue').textContent = Math.round(currentTheme.headerOpacity * 100) + '%';
      document.getElementById('headerShadowSelect').value = currentTheme.headerShadow;
      
      document.getElementById('bubbleBorderRadiusSlider').value = currentTheme.bubbleBorderRadius;
      document.getElementById('bubbleBorderRadiusValue').textContent = currentTheme.bubbleBorderRadius + 'px';
      document.getElementById('bubbleOpacitySlider').value = currentTheme.bubbleOpacity;
      document.getElementById('bubbleOpacityValue').textContent = Math.round(currentTheme.bubbleOpacity * 100) + '%';
      document.getElementById('bubbleShadowSelect').value = currentTheme.bubbleShadow;
      document.getElementById('bubbleBorderSelect').value = currentTheme.bubbleBorder;
      
      updateThemePreview();
      document.getElementById('themeSettingsModal').style.display = 'flex';
    }
    
    // 隐藏主题设置弹窗
    function hideThemeSettings() {
      document.getElementById('themeSettingsModal').style.display = 'none';
    }
    
    // 更新主题预览
    function updateThemePreview() {
      const preview = document.getElementById('themePreview');
      const previewHeader = preview.querySelector('.preview-header');
      const previewChat = preview.querySelector('.preview-chat');
      const userBubble = preview.querySelector('.preview-bubble.user');
      const aiBubble = preview.querySelector('.preview-bubble.ai');
      
      // 获取当前表单值
      const headerColor = document.getElementById('headerColorInput').value;
      const chatBgColor = document.getElementById('chatBgColorInput').value;
      const userBubbleColor = document.getElementById('userBubbleColorInput').value;
      const aiBubbleColor = document.getElementById('aiBubbleColorInput').value;
      const fontFamily = document.getElementById('fontFamilySelect').value;
      const fontColor = document.getElementById('fontColorInput').value;
      
      const headerBorderRadius = document.getElementById('headerBorderRadiusSlider').value;
      const headerOpacity = document.getElementById('headerOpacitySlider').value;
      const bubbleBorderRadius = document.getElementById('bubbleBorderRadiusSlider').value;
      const bubbleOpacity = document.getElementById('bubbleOpacitySlider').value;
      
      // 应用到预览
      previewHeader.style.background = headerColor;
      previewHeader.style.borderRadius = `${headerBorderRadius}px ${headerBorderRadius}px 0 0`;
      previewHeader.style.opacity = headerOpacity;
      
      previewChat.style.background = chatBgColor;
      
      userBubble.style.background = `rgba(${hexToRgb(userBubbleColor)}, ${bubbleOpacity})`;
      userBubble.style.borderRadius = `${bubbleBorderRadius}px`;
      
      aiBubble.style.background = `rgba(${hexToRgb(aiBubbleColor)}, ${bubbleOpacity})`;
      aiBubble.style.borderRadius = `${bubbleBorderRadius}px`;
      
      preview.style.fontFamily = fontFamily;
      preview.style.color = fontColor;
    }
    
    // 应用预设主题
    function applyPresetTheme(presetName) {
      const preset = themePresets[presetName];
      if (preset) {
        // 更新颜色表单
        document.getElementById('headerColorInput').value = preset.headerColor;
        document.getElementById('headerColorText').value = preset.headerColor;
        document.getElementById('chatBgColorInput').value = preset.chatBgColor;
        document.getElementById('chatBgColorText').value = preset.chatBgColor;
        document.getElementById('userBubbleColorInput').value = preset.userBubbleColor;
        document.getElementById('userBubbleColorText').value = preset.userBubbleColor;
        document.getElementById('aiBubbleColorInput').value = preset.aiBubbleColor;
        document.getElementById('aiBubbleColorText').value = preset.aiBubbleColor;
        document.getElementById('chatBgImageInput').value = preset.chatBgImage || '';
        document.getElementById('fontFamilySelect').value = preset.fontFamily;
        document.getElementById('fontColorInput').value = preset.fontColor;
        document.getElementById('fontColorText').value = preset.fontColor;
        
        // 更新样式表单
        document.getElementById('headerBorderRadiusSlider').value = preset.headerBorderRadius;
        document.getElementById('headerBorderRadiusValue').textContent = preset.headerBorderRadius + 'px';
        document.getElementById('headerOpacitySlider').value = preset.headerOpacity;
        document.getElementById('headerOpacityValue').textContent = Math.round(preset.headerOpacity * 100) + '%';
        document.getElementById('headerShadowSelect').value = preset.headerShadow;
        
        document.getElementById('bubbleBorderRadiusSlider').value = preset.bubbleBorderRadius;
        document.getElementById('bubbleBorderRadiusValue').textContent = preset.bubbleBorderRadius + 'px';
        document.getElementById('bubbleOpacitySlider').value = preset.bubbleOpacity;
        document.getElementById('bubbleOpacityValue').textContent = Math.round(preset.bubbleOpacity * 100) + '%';
        document.getElementById('bubbleShadowSelect').value = preset.bubbleShadow;
        document.getElementById('bubbleBorderSelect').value = preset.bubbleBorder;
        
        // 更新预设按钮状态
        document.querySelectorAll('.theme-preset-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-theme="${presetName}"]`).classList.add('active');
        
        updateThemePreview();
      }
    }
    
    // 从表单获取主题设置
    function getThemeFromForm() {
      return {
        headerColor: document.getElementById('headerColorInput').value,
        chatBgColor: document.getElementById('chatBgColorInput').value,
        chatBgImage: document.getElementById('chatBgImageInput').value.trim(),
        userBubbleColor: document.getElementById('userBubbleColorInput').value,
        aiBubbleColor: document.getElementById('aiBubbleColorInput').value,
        fontFamily: document.getElementById('fontFamilySelect').value,
        fontColor: document.getElementById('fontColorInput').value,
        headerBorderRadius: document.getElementById('headerBorderRadiusSlider').value,
        headerOpacity: document.getElementById('headerOpacitySlider').value,
        headerShadow: document.getElementById('headerShadowSelect').value,
        bubbleBorderRadius: document.getElementById('bubbleBorderRadiusSlider').value,
        bubbleOpacity: document.getElementById('bubbleOpacitySlider').value,
        bubbleShadow: document.getElementById('bubbleShadowSelect').value,
        bubbleBorder: document.getElementById('bubbleBorderSelect').value
      };
    }
    
    // 应用主题并保存
    function applyAndSaveTheme() {
      const newTheme = getThemeFromForm();
      applyTheme(newTheme);
      saveThemeSettings();
      hideThemeSettings();
      alert('✅ 主题已应用并保存！');
    }
    
    // 重置为默认主题
    function resetToDefaultTheme() {
      if (confirm('确定要重置为默认主题吗？')) {
        applyPresetTheme('default');
        applyAndSaveTheme();
      }
    }
    
    // 上传聊天背景图片
    function uploadChatBackground() {
      document.getElementById('chatBgFileInput').click();
    }
    
    // 处理聊天背景图片选择
    function handleChatBgSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      if (file.type.startsWith('image/') && file.size <= 10 * 1024 * 1024) {
        const reader = new FileReader();
        reader.onload = (e) => {
          document.getElementById('chatBgImageInput').value = e.target.result;
          updateThemePreview();
        };
        reader.readAsDataURL(file);
      } else {
        alert('请选择有效的图片文件（最大10MB）');
      }
      
      event.target.value = '';
    }
    
    // 移除聊天背景
    function removeChatBackground() {
      document.getElementById('chatBgImageInput').value = '';
      updateThemePreview();
    }
    
    // 导入字体功能
    function importFont() {
      document.getElementById('fontFileInput').click();
    }
    
    // 处理字体文件选择
    function handleFontSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const validTypes = ['.ttf', '.otf', '.woff', '.woff2'];
      const fileName = file.name.toLowerCase();
      const isValidType = validTypes.some(type => fileName.endsWith(type));
      
      if (!isValidType) {
        alert('请选择有效的字体文件（.ttf, .otf, .woff, .woff2）');
        return;
      }
      
      // 提高文件大小限制到50MB
      if (file.size > 50 * 1024 * 1024) {
        const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
        alert(`字体文件过大（${fileSizeMB}MB），请选择小于50MB的文件\n\n建议：\n1. 使用字体压缩工具减小文件大小\n2. 选择.woff2格式的字体文件（压缩率更高）\n3. 考虑使用在线字体服务`);
        return;
      }
      
      // 显示文件大小信息
      const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
      console.log(`正在导入字体文件: ${fileName} (${fileSizeMB}MB)`);
      
      // 显示加载提示
      const loadingMsg = document.createElement('div');
      loadingMsg.id = 'fontLoadingMsg';
      loadingMsg.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 20px;
        border-radius: 8px;
        z-index: 10000;
        text-align: center;
        font-size: 16px;
      `;
      loadingMsg.innerHTML = `
        <div>正在导入字体文件...</div>
        <div style="margin-top: 10px; font-size: 14px; color: #ccc;">
          ${fileName} (${fileSizeMB}MB)
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #999;">
          大文件可能需要较长时间，请耐心等待
        </div>
      `;
      document.body.appendChild(loadingMsg);
      
      const reader = new FileReader();
      
      reader.onprogress = (e) => {
        if (e.lengthComputable) {
          const percentComplete = (e.loaded / e.total * 100).toFixed(1);
          const progressDiv = loadingMsg.querySelector('div:first-child');
          progressDiv.textContent = `正在读取文件... ${percentComplete}%`;
        }
      };
      
      reader.onload = (e) => {
        const fontData = e.target.result;
        const fontName = file.name.replace(/\.[^/.]+$/, "");
        
        // 更新加载提示
        const progressDiv = loadingMsg.querySelector('div:first-child');
        progressDiv.textContent = '正在加载字体...';
        
        // 创建字体样式
        const fontFace = new FontFace(fontName, `url(${fontData})`);
        
        fontFace.load().then((loadedFont) => {
          document.fonts.add(loadedFont);
          
          // 添加到自定义字体列表
          customFonts.push({
            name: fontName,
            data: fontData,
            size: file.size,
            fileName: fileName
          });
          
          // 保存自定义字体数据
          saveCustomFonts();
          
          // 更新字体选择器
          updateFontSelector();
          
          // 应用新字体
          document.getElementById('fontFamilySelect').value = fontName;
          updateThemePreview();
          
          // 移除加载提示
          document.body.removeChild(loadingMsg);
          
          alert(`✅ 字体 "${fontName}" 导入成功！\n文件大小: ${fileSizeMB}MB\n\n字体已添加到字体选择器中，您可以在主题设置中使用它。`);
          
          console.log(`✅ 字体导入成功: ${fontName} (${fileSizeMB}MB)`);
        }).catch((error) => {
          // 移除加载提示
          document.body.removeChild(loadingMsg);
          
          console.error('字体加载失败:', error);
          alert(`❌ 字体文件加载失败\n\n可能的原因:\n1. 字体文件损坏或格式不正确\n2. 浏览器内存不足\n3. 字体文件过于复杂\n\n建议:\n1. 尝试使用其他格式的字体文件\n2. 使用字体压缩工具优化文件\n3. 重启浏览器后重试`);
        });
      };
      
      reader.onerror = () => {
        // 移除加载提示
        if (document.getElementById('fontLoadingMsg')) {
          document.body.removeChild(loadingMsg);
        }
        alert('❌ 文件读取失败，请重试');
      };
      
      reader.readAsDataURL(file);
      event.target.value = '';
    }
    
    // 更新字体选择器
    function updateFontSelector() {
      const fontSelect = document.getElementById('fontFamilySelect');
      
      // 移除之前的自定义字体选项
      const customOptions = fontSelect.querySelectorAll('.custom-font');
      customOptions.forEach(option => option.remove());
      
      // 添加自定义字体选项
      customFonts.forEach(font => {
        const option = document.createElement('option');
        option.value = font.name;
        
        // 显示文件大小信息
        if (font.size) {
          const sizeMB = (font.size / (1024 * 1024)).toFixed(1);
          option.textContent = `${font.name} (自定义, ${sizeMB}MB)`;
        } else {
          option.textContent = font.name + ' (自定义)';
        }
        
        option.className = 'custom-font';
        option.title = `自定义字体: ${font.fileName || font.name}`;
        fontSelect.appendChild(option);
      });
    }
    
    // 保存自定义字体到localStorage
    function saveCustomFonts() {
      try {
        localStorage.setItem('aiChatCustomFonts', JSON.stringify(customFonts));
        console.log('✅ 自定义字体数据已保存，字体数量:', customFonts.length);
      } catch (error) {
        console.error('❌ 保存自定义字体失败:', error);
        // 如果保存失败，可能是数据过大，尝试清理或提示用户
        if (error.name === 'QuotaExceededError') {
          alert('字体数据过大，无法保存到浏览器存储中。建议删除一些较大的字体文件。');
        }
      }
    }
    
    // 从localStorage加载自定义字体
    function loadCustomFonts() {
      try {
        const savedFonts = localStorage.getItem('aiChatCustomFonts');
        if (savedFonts) {
          const fontsData = JSON.parse(savedFonts);
          console.log('🔄 正在加载自定义字体，数量:', fontsData.length);
          
          // 重新加载每个字体到document.fonts
          fontsData.forEach((fontInfo, index) => {
            if (fontInfo.data && fontInfo.name) {
              const fontFace = new FontFace(fontInfo.name, `url(${fontInfo.data})`);
              fontFace.load().then((loadedFont) => {
                document.fonts.add(loadedFont);
                console.log(`✅ 字体 ${fontInfo.name} 重新加载成功`);
              }).catch((error) => {
                console.error(`❌ 字体 ${fontInfo.name} 重新加载失败:`, error);
              });
            }
          });
          
          customFonts = fontsData;
          updateFontSelector();
          console.log('✅ 自定义字体数据加载完成');
        } else {
          console.log('ℹ️ 未找到保存的自定义字体数据');
        }
      } catch (error) {
        console.error('❌ 加载自定义字体失败:', error);
        customFonts = [];
      }
    }
    
    // 清除自定义字体
    function clearCustomFonts() {
      if (customFonts.length === 0) {
        alert('没有自定义字体需要清除');
        return;
      }
      
      // 计算总文件大小
      const totalSize = customFonts.reduce((sum, font) => sum + (font.size || 0), 0);
      const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(1);
      
      // 生成字体列表
      const fontList = customFonts.map(font => {
        const sizeMB = font.size ? `(${(font.size / (1024 * 1024)).toFixed(1)}MB)` : '';
        return `• ${font.name} ${sizeMB}`;
      }).join('\n');
      
      if (confirm(`确定要清除所有 ${customFonts.length} 个自定义字体吗？\n总大小: ${totalSizeMB}MB\n\n字体列表:\n${fontList}\n\n清除后将释放浏览器内存。`)) {
        customFonts.forEach(font => {
          // 从document.fonts中移除
          document.fonts.forEach(f => {
            if (f.family === font.name) {
              document.fonts.delete(f);
            }
          });
        });
        
        customFonts = [];
        
        // 清除localStorage中的字体数据
        localStorage.removeItem('aiChatCustomFonts');
        
        updateFontSelector();
        
        // 如果当前使用的是自定义字体，重置为默认字体
        const currentFont = document.getElementById('fontFamilySelect').value;
        if (!document.getElementById('fontFamilySelect').querySelector(`option[value="${currentFont}"]:not(.custom-font)`)) {
          document.getElementById('fontFamilySelect').value = '微软雅黑, Arial, sans-serif';
          updateThemePreview();
        }
        
        alert(`✅ 已清除所有自定义字体\n释放内存: ${totalSizeMB}MB`);
        console.log(`✅ 清除了 ${customFonts.length} 个自定义字体，释放内存 ${totalSizeMB}MB`);
      }
    }
    
    // 初始化主题设置事件监听
    function initThemeSettings() {
      // 主题设置按钮
      document.getElementById('themeBtn').onclick = showThemeSettings;
      document.getElementById('closeThemeSettingsModal').onclick = hideThemeSettings;
      document.getElementById('cancelThemeBtn').onclick = hideThemeSettings;
      document.getElementById('applyThemeBtn').onclick = applyAndSaveTheme;
      document.getElementById('previewThemeBtn').onclick = () => {
        applyTheme(getThemeFromForm());
      };
      document.getElementById('resetThemeBtn').onclick = resetToDefaultTheme;
      
      // 预设主题按钮
      document.querySelectorAll('.theme-preset-btn').forEach(btn => {
        btn.onclick = () => applyPresetTheme(btn.dataset.theme);
      });
      
      // 颜色输入同步
      const colorInputs = [
        'headerColor', 'chatBgColor', 'userBubbleColor', 'aiBubbleColor', 'fontColor'
      ];
      colorInputs.forEach(name => {
        const colorInput = document.getElementById(name + 'Input');
        const textInput = document.getElementById(name + 'Text');
        
        colorInput.oninput = () => {
          textInput.value = colorInput.value;
          updateThemePreview();
        };
        
        textInput.oninput = () => {
          if (/^#[0-9A-F]{6}$/i.test(textInput.value)) {
            colorInput.value = textInput.value;
            updateThemePreview();
          }
        };
      });
      
      // 样式滑块
      const styleSliders = [
        'headerBorderRadius', 'headerOpacity', 'bubbleBorderRadius', 'bubbleOpacity'
      ];
      styleSliders.forEach(name => {
        const slider = document.getElementById(name + 'Slider');
        const valueSpan = document.getElementById(name + 'Value');
        
        slider.oninput = (e) => {
          if (name.includes('Opacity')) {
            valueSpan.textContent = Math.round(e.target.value * 100) + '%';
          } else {
            valueSpan.textContent = e.target.value + 'px';
          }
          updateThemePreview();
        };
      });
      
      // 样式选择器
      const styleSelectors = ['headerShadow', 'bubbleShadow', 'bubbleBorder'];
      styleSelectors.forEach(name => {
        document.getElementById(name + 'Select').onchange = updateThemePreview;
      });
      
      // 字体相关
      document.getElementById('fontFamilySelect').onchange = updateThemePreview;
      document.getElementById('importFontBtn').onclick = importFont;
      document.getElementById('clearCustomFontsBtn').onclick = clearCustomFonts;
      document.getElementById('fontFileInput').onchange = handleFontSelect;
      document.getElementById('chatBgImageInput').oninput = updateThemePreview;
      
      // 背景图片相关
      document.getElementById('uploadChatBgBtn').onclick = uploadChatBackground;
      document.getElementById('removeChatBgBtn').onclick = removeChatBackground;
      document.getElementById('chatBgFileInput').onchange = handleChatBgSelect;
      
      // 点击背景关闭弹窗
      document.getElementById('themeSettingsModal').onclick = (e) => {
        if (e.target.id === 'themeSettingsModal') {
          hideThemeSettings();
        }
      };
    }
    
    // ==================== 主题设置功能结束 ====================
    
    // 初始化主题设置
    loadThemeSettings();
    initThemeSettings();
    
    // 确保字体选择器正确显示自定义字体
    updateFontSelector();

    // ==================== 拍一拍提醒功能开始 ====================

    // 重置活动计时器
    function resetActivityTimer() {
      lastActivityTime = Date.now();
      patReminderShown = false;
      
      // 清除现有计时器
      if (inactivityTimer) {
        clearTimeout(inactivityTimer);
      }
      
      // 设置新的计时器
      inactivityTimer = setTimeout(() => {
        showPatReminder();
      }, INACTIVITY_TIMEOUT);
    }

    // 显示拍一拍提醒
    function showPatReminder() {
      // 如果已经显示过或者不在聊天界面，则不显示
      if (patReminderShown || !currentChatId || !chatView.classList.contains('active')) {
        return;
      }
      
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (!currentChat) return;
      
      let roleName = '';
      let roleAvatar = '';
      
      if (currentChat.type === 'group') {
        // 群聊模式：随机选择一个角色
        const availableRoles = currentChat.roles.filter(role => role.enabled !== false);
        if (availableRoles.length === 0) return;
        
        const randomRole = availableRoles[Math.floor(Math.random() * availableRoles.length)];
        roleName = randomRole.name || '角色';
        roleAvatar = randomRole.avatar || DEFAULT_AI_AVATAR;
      } else {
        // 单聊模式
        roleName = currentChat.roleName || roleName || '助手';
        roleAvatar = currentChat.aiAvatar || aiAvatar || DEFAULT_AI_AVATAR;
      }
      
      // 设置弹窗内容
      patReminderAvatar.src = roleAvatar;
      patReminderText.textContent = `${roleName}拍了拍你`;
      
      // 显示弹窗
      patReminderModal.classList.add('show');
      patReminderShown = true;
      
      // 3秒后自动隐藏
      setTimeout(() => {
        hidePatReminder();
      }, 3000);
    }

    // 隐藏拍一拍提醒
    function hidePatReminder() {
      patReminderModal.classList.remove('show');
      // 重置计时器，准备下次提醒
      resetActivityTimer();
    }

    // 监听用户活动
    function setupActivityListeners() {
      const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'touchmove', 'click'];
      
      events.forEach(event => {
        document.addEventListener(event, resetActivityTimer, true);
      });
      
      // 特别监听聊天输入框
      if (chatInput) {
        chatInput.addEventListener('input', resetActivityTimer);
        chatInput.addEventListener('focus', resetActivityTimer);
      }
    }

    // 加载拍一拍消息
    function loadPatMessage(msg) {
      // 创建时间元素
      if (msg.timestamp) {
        const timeElement = document.createElement('div');
        timeElement.className = 'msg-time';
        const timeSpan = document.createElement('span');
        timeSpan.textContent = msg.timestamp;
        timeElement.appendChild(timeSpan);
        chatBody.appendChild(timeElement);
      }
      
      const patDiv = document.createElement('div');
      patDiv.className = 'pat-message';
      patDiv.innerHTML = `<div class="pat-message-content">${msg.content}</div>`;
      chatBody.appendChild(patDiv);
    }

    // 发送拍一拍消息
    function sendPatMessage(targetNameOrFullText, isUserPat = true) {
      if (!currentChatId) return;
      
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (!currentChat) return;
      
      let patText = '';
      if (isUserPat) {
        // 用户拍了角色
        patText = `你拍了拍${targetNameOrFullText}`;
      } else {
        // 角色拍了用户，如果传入的是完整文本就直接使用
        if (targetNameOrFullText.includes('拍了拍')) {
          patText = targetNameOrFullText;
        } else {
          patText = `${targetNameOrFullText}拍了拍你`;
        }
      }
      
      // 创建时间元素（微信风格）
      const timeElement = document.createElement('div');
      timeElement.className = 'msg-time';
      const timeSpan = document.createElement('span');
      timeSpan.textContent = formatMessageTime();
      timeElement.appendChild(timeSpan);
      
      // 创建拍一拍消息元素
      const patDiv = document.createElement('div');
      patDiv.className = 'pat-message';
      patDiv.innerHTML = `<div class="pat-message-content">${patText}</div>`;
      
      // 添加到聊天界面
      chatBody.appendChild(timeElement);
      chatBody.appendChild(patDiv);
      
      // 添加震动效果
      setTimeout(() => {
        const content = patDiv.querySelector('.pat-message-content');
        if (content) {
          content.classList.add('shake');
        }
      }, 100);
      
      // 滚动到底部
      chatBody.scrollTop = chatBody.scrollHeight;
      
      // 保存到聊天记录
      if (!currentChat.chatDisplay) {
        currentChat.chatDisplay = [];
      }
      
      const currentTimestamp = formatMessageTime();
      currentChat.chatDisplay.push({
        id: generateId(),
        type: 'pat',
        content: patText,
        timestamp: currentTimestamp,
        isUserPat: isUserPat,
        targetName: isUserPat ? targetNameOrFullText : (targetNameOrFullText.includes('拍了拍') ? targetNameOrFullText.split('拍了拍')[0] : targetNameOrFullText)
      });
      
      saveCurrentChatData();
      
      // 重置活动计时器
      resetActivityTimer();
    }

    // 处理角色回复拍一拍
    async function handleRolePatReply(roleId, roleName) {
      if (!currentChatId) return;
      
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (!currentChat) return;
      
      // 构建拍一拍的上下文
      const patContext = `用户拍了拍你，请根据你的角色设定做出回应。

重要格式要求：
1. 用（）包裹动作描述
2. 严格遵循使用反斜线\\分隔句子的要求，每个句子控制在50字以内
3. 回复输出示例格式：第一句话\\第二句话\\第三句话

你可以选择：
1. 拍回去（如：(轻轻拍回去)你也拍拍我呀\\我们一起玩）
2. 说一句话回应（如：(害羞地低下头)你怎么突然拍我\\人家会不好意思的）
3. 做出其他符合角色的反应

请保持角色的性格特点，严格按照格式要求回复。`;
      
      // 处理拍一拍回复
      await handlePatReply(patContext, currentChat, roleId, roleName);
    }

    // 处理拍一拍回复
    async function handlePatReply(patContext, chat, roleId, roleName) {
      try {
        // 构建正确的聊天API端点
        const baseChatEndpoint = getChatEndpoint(apiURL);
        
        // 构建包含角色设定和拍一拍上下文的消息
        const messages = buildMessages(patContext);
        
        // 根据不同API提供商构建请求
        let chatEndpoint, headers, requestBody;
        
        try {
          const url = new URL(apiURL);
          
          if (url.hostname === 'generativelanguage.googleapis.com') {
            // Google Gemini API
            chatEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;
            headers = {
              'Content-Type': 'application/json'
            };
            
            // 转换消息格式为Gemini格式
            const contents = [];
            let systemPrompt = '';
            
            // 先收集系统消息
            messages.forEach(msg => {
              if (msg.role === 'system') {
                systemPrompt += (systemPrompt ? '\n' : '') + msg.content;
              }
            });
            
            // 转换用户和助手消息
            messages.forEach(msg => {
              if (msg.role === 'user') {
                let userContent = msg.content;
                // 将系统提示添加到第一个用户消息中
                if (systemPrompt && contents.length === 0) {
                  userContent = systemPrompt + '\n\n' + userContent;
                  systemPrompt = ''; // 标记已添加
                }
                contents.push({
                  role: 'user',
                  parts: [{ text: userContent }]
                });
              } else if (msg.role === 'assistant') {
                contents.push({
                  role: 'model', 
                  parts: [{ text: msg.content }]
                });
              }
            });
            
            // 如果没有用户消息但有系统消息，创建一个默认用户消息
            if (contents.length === 0 && systemPrompt) {
              contents.push({
                role: 'user',
                parts: [{ text: systemPrompt + '\n\n' + patContext }]
              });
            }
            
            requestBody = JSON.stringify({
              contents: contents,
              generationConfig: {
                temperature: 0.8,
                maxOutputTokens: 200, // 拍一拍回复要简短
                topK: 40,
                topP: 0.95
              }
            });
          } else {
            // OpenAI/DeepSeek格式
            chatEndpoint = baseChatEndpoint;
            headers = {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            };
            
            requestBody = JSON.stringify({
              model: selectedModel,
              messages: messages,
              max_tokens: 200, // 拍一拍回复要简短
              temperature: 0.8,
              stream: false // 拍一拍回复不需要流式输出
            });
          }
        } catch (e) {
          // 默认使用OpenAI格式
          chatEndpoint = baseChatEndpoint;
          headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          };
          
          requestBody = JSON.stringify({
            model: selectedModel,
            messages: messages,
            max_tokens: 200,
            temperature: 0.8,
            stream: false
          });
        }
        
        const response = await fetchWithRetry(chatEndpoint, {
          method: 'POST',
          headers: headers,
          body: requestBody,
          timeout: 15000 // 拍一拍回复使用较短超时
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const url = new URL(apiURL);
        let aiReply = '';
        
        if (url.hostname === 'generativelanguage.googleapis.com') {
          // 处理Gemini API响应
          const data = await response.json();
          
          if (data.error) {
            throw new Error(`Gemini API错误: ${data.error.message}`);
          }
          
          if (data.candidates && data.candidates.length > 0) {
            const candidate = data.candidates[0];
            if (candidate.content && candidate.content.parts) {
              aiReply = candidate.content.parts.map(part => part.text || '').join('').trim();
            }
          }
        } else {
          // 处理OpenAI/DeepSeek响应
          const data = await response.json();
          if (data.choices && data.choices.length > 0) {
            aiReply = data.choices[0].message.content.trim();
          }
        }
        
        if (aiReply) {
          // 检查回复是否是拍一拍动作
          if (aiReply.includes('拍了拍') || aiReply.includes('拍拍')) {
            // 如果是拍一拍动作，作为拍一拍消息显示
            sendPatMessage(aiReply, false);
          } else {
            // 如果是普通回复，作为普通消息显示，支持气泡分割
            const thinkingMsg = roleName ? `${roleName}正在回复...` : '正在回复...';
            const aiMsgBubble = appendMsg('ai', thinkingMsg, true, roleId, roleName);
            
            // 使用handleNonStreamResponse处理分割
            await handleNonStreamResponse(aiReply, aiMsgBubble, roleId, roleName);
          }
          
          // 更新对话历史
          if (window.conversationHistory) {
            window.conversationHistory.push({
              role: "user",
              content: patContext
            });
            window.conversationHistory.push({
              role: "assistant", 
              content: aiReply
            });
          }
        } else {
          // 如果AI没有回复，使用随机拍一拍回应
          handleAIPatResponse(roleName);
        }
        
      } catch (error) {
        console.error('拍一拍回复错误:', error);
        // 发生错误时使用随机拍一拍回应
        handleAIPatResponse(roleName);
      }
    }

    // 处理AI回应拍一拍（保留原有的随机回应功能作为备用）
    function handleAIPatResponse(roleName) {
      if (!currentChatId) return;
      
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (!currentChat) return;
      
      // AI回应的随机行为
      const responses = [
        '拍了拍你',
        '拍了拍你的头',
        '拍了拍你并说"嘿嘿"',
        '拍了拍你的脸',
        '拍了拍你的肩膀',
        '拍了拍你并眨了眨眼',
        '拍了拍你的手',
        '轻轻拍了拍你'
      ];
      
      const randomAction = responses[Math.floor(Math.random() * responses.length)];
      const responseText = `${roleName}${randomAction}`;
      
      // 发送AI的拍一拍回应
      sendPatMessage(responseText, false);
    }

    // 处理头像双击事件
    function handleAvatarDoubleClick(avatar, roleId, roleName) {
      // 防止过快连续点击
      if (avatar.dataset.lastPatTime) {
        const lastTime = parseInt(avatar.dataset.lastPatTime);
        if (Date.now() - lastTime < 1000) { // 1秒内不能重复拍
          return;
        }
      }
      
      avatar.dataset.lastPatTime = Date.now().toString();
      
      // 添加头像震动效果
      avatar.style.animation = 'none';
      setTimeout(() => {
        avatar.style.animation = 'patBounce 0.6s ease-in-out';
      }, 10);
      
      // 发送拍一拍消息
      sendPatMessage(roleName || '角色', true);
      
      // 让角色根据设定回复拍一拍
      setTimeout(() => {
        handleRolePatReply(roleId, roleName);
      }, 1000 + Math.random() * 2000); // 1-3秒后回应
    }

    // 设置头像双击监听器
    function setupAvatarPatListeners() {
      // 使用事件委托监听所有头像的双击事件
      chatBody.addEventListener('dblclick', (e) => {
        const avatar = e.target.closest('.avatar');
        if (!avatar) return;
        
        const msgElement = avatar.closest('.msg');
        if (!msgElement || !msgElement.classList.contains('ai')) return;
        
        // 获取角色信息
        let roleId = msgElement.getAttribute('data-role-id');
        let roleName = msgElement.getAttribute('data-role-name');
        
        // 如果没有从属性获取到，尝试从角色名称元素获取
        if (!roleName) {
          const roleNameElement = msgElement.querySelector('.role-name');
          if (roleNameElement) {
            roleName = roleNameElement.textContent;
          }
        }
        
        // 如果还是没有名称，使用默认名称
        if (!roleName) {
          const currentChat = chatList.find(c => c.id === currentChatId);
          if (currentChat) {
            if (currentChat.type === 'group') {
              roleName = '角色';
            } else {
              roleName = currentChat.roleName || roleName || '助手';
            }
          } else {
            roleName = '助手';
          }
        }
        
        // 处理拍一拍
        handleAvatarDoubleClick(avatar, roleId, roleName);
      });
    }

    // 初始化拍一拍功能
    function initPatReminder() {
      // 设置关闭按钮事件
      patReminderClose.addEventListener('click', hidePatReminder);
      
      // 点击弹窗背景关闭
      patReminderModal.addEventListener('click', (e) => {
        if (e.target === patReminderModal) {
          hidePatReminder();
        }
      });
      
      // 设置活动监听器
      setupActivityListeners();
      
      // 设置头像双击监听器
      setupAvatarPatListeners();
      
      // 开始计时
      resetActivityTimer();
    }

    // ==================== 视频通话功能开始 ====================

    // 初始化视频通话功能
    function initVideoCall() {
      // 视频通话按钮点击事件
      videoCallBtn.addEventListener('click', startVideoCall);
      
      // 视频通话申请弹窗事件
      videoCallDeclineBtn.addEventListener('click', declineVideoCall);
      videoCallAcceptBtn.addEventListener('click', acceptVideoCall);
      
      // 视频通话界面事件
      videoCallSendBtn.addEventListener('click', sendVideoCallMessage);
      videoCallInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendVideoCallMessage();
        }
      });
      
      // 视频通话控制按钮
      videoCallMuteBtn.addEventListener('click', toggleMute);
      videoCallCameraBtn.addEventListener('click', toggleCamera);
      videoCallHangupBtn.addEventListener('click', hangupVideoCall);
      
      // 阻止视频通话界面的滚动
      videoCallModal.addEventListener('touchmove', (e) => {
        e.preventDefault();
      }, { passive: false });
    }

    // 开始视频通话
    function startVideoCall() {
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (!currentChat) {
        alert('请先选择一个聊天');
        return;
      }

      let roleData = null;
      let roleName = '';
      let roleAvatar = '';
      let roleVideo = '';
      let roleDescription = '';

      if (currentChat.type === 'group') {
        // 群聊模式：随机选择一个角色发起通话
        if (!currentChat.roles || currentChat.roles.length === 0) {
          alert('群聊中没有角色，无法发起视频通话');
          return;
        }
        roleData = currentChat.roles[Math.floor(Math.random() * currentChat.roles.length)];
        roleName = roleData.name;
        roleAvatar = roleData.avatar || DEFAULT_AI_AVATAR;
        roleVideo = roleData.videoCallMedia || roleAvatar;
        roleDescription = roleData.description || '';
      } else {
        // 单聊模式
        roleName = currentChat.roleName || '助手';
        roleAvatar = currentChat.aiAvatar || DEFAULT_AI_AVATAR;
        roleVideo = currentChat.aiVideo || roleAvatar;
        roleDescription = currentChat.roleDescription || '';
      }

      currentVideoCallRole = {
        id: roleData ? roleData.id : `single_${currentChat.id}`,
        name: roleName,
        avatar: roleAvatar,
        video: roleVideo,
        description: roleDescription,
        chatType: currentChat.type,
        fullRoleData: roleData, // 保存完整的角色数据以备后用
        currentChat: currentChat // 保存当前聊天数据以备后用
      };

      // 显示通话申请弹窗
      showVideoCallRequest(roleName, roleAvatar);
    }

    // 显示视频通话申请弹窗
    function showVideoCallRequest(roleName, roleAvatar) {
      videoCallRequestName.textContent = roleName;
      videoCallRequestAvatar.src = roleAvatar;
      videoCallRequestModal.classList.add('show');
      
      // 模拟AI发起通话的延迟
      setTimeout(() => {
        if (videoCallRequestModal.classList.contains('show')) {
          // 如果用户没有响应，自动接听
          acceptVideoCall();
        }
      }, 8000);
    }

    // 拒绝视频通话
    function declineVideoCall() {
      videoCallRequestModal.classList.remove('show');
      currentVideoCallRole = null;
      
      // 在聊天中显示拒绝消息
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (currentChat) {
        appendMsg('user', '已拒绝视频通话', false, null, null, null, null, null, false, null, false, null, 'text');
        saveCurrentChatData();
      }
    }

    // 接听视频通话
    function acceptVideoCall() {
      videoCallRequestModal.classList.remove('show');
      
      if (!currentVideoCallRole) return;
      
      // 显示视频通话界面
      showVideoCallInterface();
      
      // 开始计时
      startVideoCallTimer();
      
      // 在聊天中显示接听消息
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (currentChat) {
        appendMsg('user', '已接听视频通话', false, null, null, null, null, null, false, null, false, null, 'text');
        saveCurrentChatData();
      }
    }

    // 显示视频通话界面
    function showVideoCallInterface() {
      isVideoCallActive = true;
      
      // 设置角色信息
      videoCallUserName.textContent = currentVideoCallRole.name;
      videoCallUserAvatar.src = userAvatar || DEFAULT_USER_AVATAR;
      
      // 设置视频画面
      const videoUrl = currentVideoCallRole.video;
      
      // 检测是否为视频文件（支持URL和base64格式）
      const isVideo = videoUrl && (
        videoUrl.includes('.mp4') || 
        videoUrl.includes('.webm') || 
        videoUrl.includes('.mov') ||
        videoUrl.includes('.avi') ||
        videoUrl.includes('.mkv') ||
        videoUrl.startsWith('data:video/') // base64视频
      );
      
      if (isVideo) {
        console.log('🎥 检测到视频文件，开始设置视频播放:', videoUrl.substring(0, 50) + '...');
        
        // 显示视频
        videoCallMainVideo.style.display = 'block';
        videoCallMainImage.style.display = 'none';
        
        // 确保视频属性设置正确
        videoCallMainVideo.autoplay = true;
        videoCallMainVideo.loop = true;
        videoCallMainVideo.muted = true;
        videoCallMainVideo.playsInline = true; // 移动端内联播放
        videoCallMainVideo.controls = false; // 隐藏控制条
        
        // 设置视频源
        videoCallMainVideo.src = videoUrl;
        
        // 加载并播放视频
        videoCallMainVideo.load();
        
        // 监听视频事件
        videoCallMainVideo.addEventListener('loadstart', function() {
          console.log('🎥 视频开始加载');
        }, { once: true });
        
        videoCallMainVideo.addEventListener('loadedmetadata', function() {
          console.log('🎥 视频元数据加载完成，时长:', videoCallMainVideo.duration);
        }, { once: true });
        
        videoCallMainVideo.addEventListener('loadeddata', function() {
          console.log('🎥 视频数据加载完成，尝试播放');
          videoCallMainVideo.play().then(() => {
            console.log('✅ 视频播放成功');
          }).catch(error => {
            console.warn('⚠️ 视频自动播放失败:', error);
            // 如果自动播放失败，尝试静音播放
            videoCallMainVideo.muted = true;
            videoCallMainVideo.play().then(() => {
              console.log('✅ 静音视频播放成功');
            }).catch(e => {
              console.error('❌ 视频播放失败:', e);
            });
          });
        }, { once: true });
        
        videoCallMainVideo.addEventListener('playing', function() {
          console.log('🎥 视频正在播放');
        }, { once: true });
        
        // 处理视频加载错误
        videoCallMainVideo.addEventListener('error', function(e) {
          console.error('❌ 视频加载失败:', e, videoCallMainVideo.error);
          // 降级到图片显示
          videoCallMainVideo.style.display = 'none';
          videoCallMainImage.style.display = 'block';
          videoCallMainImage.src = videoUrl;
          console.log('🖼️ 降级到图片显示');
        }, { once: true });
        
      } else {
        // 显示图片
        videoCallMainImage.style.display = 'block';
        videoCallMainVideo.style.display = 'none';
        videoCallMainImage.src = videoUrl;
      }
      
      // 清空消息区域
      videoCallMessages.innerHTML = '';
      videoCallInput.value = '';
      
      // 显示视频通话模态框
      videoCallModal.classList.add('show');
      
      // 聚焦输入框
      setTimeout(() => {
        videoCallInput.focus();
      }, 300);
    }

    // 开始视频通话计时
    function startVideoCallTimer() {
      videoCallStartTime = Date.now();
      updateVideoCallDuration();
      
      videoCallTimer = setInterval(() => {
        updateVideoCallDuration();
      }, 1000);
    }

    // 更新视频通话时长显示
    function updateVideoCallDuration() {
      if (!videoCallStartTime) return;
      
      const elapsed = Math.floor((Date.now() - videoCallStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      videoCallDuration.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // 发送视频通话消息
    function sendVideoCallMessage() {
      const text = videoCallInput.value.trim();
      if (!text) return;
      
      // 清空输入框
      videoCallInput.value = '';
      
      // 在视频通话界面显示用户消息
      addVideoCallMessage(text, 'user');
      
      // 模拟AI回复
      setTimeout(() => {
        generateVideoCallAIReply(text);
      }, 1000 + Math.random() * 2000);
    }

    // 在视频通话界面添加消息
    function addVideoCallMessage(text, sender) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'video-call-message';
      
      if (sender === 'user') {
        messageDiv.style.marginLeft = 'auto';
        messageDiv.style.marginRight = '0';
        messageDiv.style.background = 'rgba(149, 236, 105, 0.9)';
        messageDiv.style.color = '#333';
      }
      
      messageDiv.textContent = text;
      videoCallMessages.appendChild(messageDiv);
      
      // 滚动到底部
      videoCallMessages.scrollTop = videoCallMessages.scrollHeight;
    }

    // 生成AI视频通话回复
    async function generateVideoCallAIReply(userMessage) {
      if (!currentVideoCallRole) return;
      
      try {
        console.log('🎭 视频通话AI回复 - 当前角色信息:', {
          name: currentVideoCallRole.name,
          description: currentVideoCallRole.description,
          chatType: currentVideoCallRole.chatType
        });
        
        // 构建角色系统提示词
        let systemPrompt = `你正在与用户进行视频通话。`;
        
        // 添加角色信息
        systemPrompt += `你是${currentVideoCallRole.name}。`;
        
        // 添加角色描述
        if (currentVideoCallRole.description && currentVideoCallRole.description.trim()) {
          systemPrompt += `\n\n角色设定：${currentVideoCallRole.description}`;
        }
        
        // 添加用户信息
        if (userName && userName.trim()) {
          systemPrompt += `\n\n用户姓名：${userName}`;
        }
        if (userDescription && userDescription.trim()) {
          systemPrompt += `\n用户信息：${userDescription}`;
        }
        
        // 添加自定义提示词
        if (aiCustomPrompt && aiCustomPrompt.trim()) {
          systemPrompt += `\n\n补充设定：${aiCustomPrompt}`;
        }
        
        // 添加视频通话特定指导和格式要求
        systemPrompt += `\n\n请注意：
1. 你正在进行视频通话，回复要简短自然（1-2句话）
2. 保持亲切友好的语调，就像真正的视频通话
3. 可以适当提及视频通话场景（如"看到你了"、"听得清楚吗"等）
4. 严格按照角色设定进行回复

重要格式要求：
1. 用（）包裹动作描述
2. 严格遵循使用反斜线\\分隔句子的要求，每个句子控制在50字以内
3. 回复输出示例格式：第一句话\\第二句话\\第三句话

示例：
用户：你好
AI回复：(挥手)你好呀\\看到你了呢

用户：听得清楚吗？
AI回复：(点头)听得很清楚\\视频也很清晰`;

        // 获取视频通话消息历史（最近的几条消息作为上下文）
        const videoCallHistory = [];
        const messageElements = videoCallMessages.querySelectorAll('.video-call-message');
        const maxHistory = Math.min(6, messageElements.length); // 最多取6条历史消息
        
        // 从最近的消息开始取，但要保持时间顺序
        const recentMessages = Array.from(messageElements).slice(-maxHistory);
        
        recentMessages.forEach(msgElement => {
          const isUser = msgElement.style.marginLeft === 'auto';
          const content = msgElement.textContent.trim();
          if (content) {
            videoCallHistory.push({
              role: isUser ? 'user' : 'assistant',
              content: content
            });
          }
        });

        console.log('🎭 视频通话系统提示词:', systemPrompt);

        // 构建视频通话上下文的消息
        const messages = [
          {
            role: 'system',
            content: systemPrompt
          },
          // 添加历史消息作为上下文
          ...videoCallHistory,
          // 当前用户消息
          {
            role: 'user',
            content: userMessage
          }
        ];
        
        console.log('🎭 视频通话消息上下文:', messages);
        
        // 发送API请求
        const response = await fetch(getChatEndpoint(apiURL), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: selectedModel,
            messages: messages,
            max_tokens: 100,
            temperature: 0.8
          })
        });
        
        if (!response.ok) {
          throw new Error(`API请求失败: ${response.status}`);
        }
        
        const data = await response.json();
        const aiReply = data.choices?.[0]?.message?.content?.trim() || '我听到了，继续聊吧~';
        
        // 处理反斜杠分割，显示多条消息
        const replyTexts = aiReply.split('\\').map(text => text.trim()).filter(text => text.length > 0);
        
        // 依次显示每条回复（有延迟）
        replyTexts.forEach((text, index) => {
          setTimeout(() => {
            addVideoCallMessage(text, 'ai');
          }, index * 1000); // 每条回复间隔1秒
        });
        
      } catch (error) {
        console.error('视频通话AI回复生成失败:', error);
        
        // 使用角色化的默认回复
        const roleName = currentVideoCallRole.name || '我';
        const defaultReplies = [
          '我听到了~',
          '是的，我明白',
          '继续说吧',
          '真的吗？',
          '我觉得也是',
          '哈哈，有意思',
          '我也这么想',
          '说得对',
          '听得很清楚呢',
          '看到你了~',
          '嗯嗯，然后呢？',
          '我在听着呢'
        ];
        
        const randomReply = defaultReplies[Math.floor(Math.random() * defaultReplies.length)];
        addVideoCallMessage(randomReply, 'ai');
      }
    }

    // 切换静音状态
    function toggleMute() {
      const isMuted = videoCallMuteBtn.textContent === '🔇';
      videoCallMuteBtn.textContent = isMuted ? '🔊' : '🔇';
      videoCallMuteBtn.title = isMuted ? '取消静音' : '静音';
    }

    // 切换摄像头状态
    function toggleCamera() {
      const isCameraOff = videoCallCameraBtn.textContent === '📷';
      videoCallCameraBtn.textContent = isCameraOff ? '📹' : '📷';
      videoCallCameraBtn.title = isCameraOff ? '关闭摄像头' : '开启摄像头';
      
      // 切换用户视频显示
      if (isCameraOff) {
        videoCallUserAvatar.style.opacity = '1';
      } else {
        videoCallUserAvatar.style.opacity = '0.3';
      }
    }

    // 预览视频通话画面
    function previewVideoCallMedia(videoUrl, roleName) {
      if (!videoUrl || videoUrl.trim() === '') {
        alert('请先设置视频通话画面');
        return;
      }
      
      // 创建预览模态框
      const previewModal = document.createElement('div');
      previewModal.className = 'modal-overlay';
      previewModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      `;
      
      const previewContent = document.createElement('div');
      previewContent.style.cssText = `
        background: #000;
        border-radius: 10px;
        padding: 20px;
        max-width: 90%;
        max-height: 90%;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
      `;
      
      // 标题
      const title = document.createElement('div');
      title.textContent = `${roleName || '角色'}的视频通话画面预览`;
      title.style.cssText = `
        color: white;
        font-size: 16px;
        margin-bottom: 15px;
        text-align: center;
      `;
      previewContent.appendChild(title);
      
      // 检测是否为视频文件
      const isVideo = videoUrl && (
        videoUrl.includes('.mp4') || 
        videoUrl.includes('.webm') || 
        videoUrl.includes('.mov') ||
        videoUrl.includes('.avi') ||
        videoUrl.includes('.mkv') ||
        videoUrl.startsWith('data:video/')
      );
      
      // 创建媒体元素
      let mediaElement;
      if (isVideo) {
        mediaElement = document.createElement('video');
        mediaElement.autoplay = true;
        mediaElement.loop = true;
        mediaElement.muted = true;
        mediaElement.playsInline = true;
        mediaElement.controls = true; // 预览时显示控制条
        mediaElement.style.cssText = `
          max-width: 400px;
          max-height: 300px;
          border-radius: 8px;
          background: #333;
        `;
        
        mediaElement.addEventListener('loadeddata', function() {
          mediaElement.play().catch(error => {
            console.warn('预览视频播放失败:', error);
          });
        });
        
        mediaElement.addEventListener('error', function(e) {
          console.error('预览视频加载失败:', e);
          alert('视频加载失败，请检查文件格式或网络连接');
        });
        
      } else {
        mediaElement = document.createElement('img');
        mediaElement.style.cssText = `
          max-width: 400px;
          max-height: 300px;
          border-radius: 8px;
          background: #333;
        `;
        
        mediaElement.addEventListener('error', function() {
          alert('图片加载失败，请检查链接是否有效');
        });
      }
      
      mediaElement.src = videoUrl;
      previewContent.appendChild(mediaElement);
      
      // 关闭按钮
      const closeBtn = document.createElement('button');
      closeBtn.textContent = '关闭';
      closeBtn.style.cssText = `
        margin-top: 15px;
        padding: 8px 20px;
        background: #666;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      `;
      
      closeBtn.addEventListener('mouseover', function() {
        this.style.background = '#777';
      });
      
      closeBtn.addEventListener('mouseout', function() {
        this.style.background = '#666';
      });
      
      closeBtn.onclick = function() {
        if (isVideo && mediaElement.src) {
          mediaElement.pause();
          mediaElement.src = '';
        }
        document.body.removeChild(previewModal);
      };
      
      previewContent.appendChild(closeBtn);
      previewModal.appendChild(previewContent);
      
      // 点击背景关闭
      previewModal.onclick = function(e) {
        if (e.target === previewModal) {
          closeBtn.click();
        }
      };
      
      document.body.appendChild(previewModal);
    }

    // 挂断视频通话
    function hangupVideoCall() {
      if (!isVideoCallActive) return;
      
      // 停止计时器
      if (videoCallTimer) {
        clearInterval(videoCallTimer);
        videoCallTimer = null;
      }
      
      // 停止并清理视频
      if (videoCallMainVideo.src) {
        videoCallMainVideo.pause();
        videoCallMainVideo.src = '';
        videoCallMainVideo.load(); // 清理缓存
      }
      
      // 隐藏视频元素
      videoCallMainVideo.style.display = 'none';
      videoCallMainImage.style.display = 'none';
      
      // 隐藏视频通话界面
      videoCallModal.classList.remove('show');
      
      // 重置状态
      isVideoCallActive = false;
      videoCallStartTime = null;
      
      // 重置按钮状态
      videoCallMuteBtn.textContent = '🔇';
      videoCallMuteBtn.title = '静音';
      videoCallCameraBtn.textContent = '📷';
      videoCallCameraBtn.title = '关闭摄像头';
      videoCallUserAvatar.style.opacity = '1';
      
      // 在聊天中显示通话结束消息
      const currentChat = chatList.find(c => c.id === currentChatId);
      if (currentChat && currentVideoCallRole) {
        const duration = videoCallDuration.textContent;
        appendMsg('user', `视频通话已结束，通话时长：${duration}`, false, null, null, null, null, null, false, null, false, null, 'text');
        saveCurrentChatData();
      }
      
      currentVideoCallRole = null;
    }

    // 保存和加载视频通话设置
    function saveVideoCallSettings(roleData) {
      if (roleData.videoCallMedia) {
        // 群聊角色保存
        const currentChat = chatList.find(c => c.id === currentChatId);
        if (currentChat && currentChat.type === 'group') {
          const roleIndex = currentChat.roles.findIndex(r => r.id === roleData.id);
          if (roleIndex !== -1) {
            currentChat.roles[roleIndex].videoCallMedia = roleData.videoCallMedia;
          }
        }
      } else {
        // 单聊保存
        const currentChat = chatList.find(c => c.id === currentChatId);
        if (currentChat && currentChat.type === 'single') {
          currentChat.aiVideo = roleData.aiVideo;
        }
      }
      saveCurrentChatData();
    }

    // ==================== 视频通话功能结束 ====================

    // 初始化视频通话功能
    initVideoCall();
    
    // 初始化拍一拍提醒功能
    initPatReminder();
  </script>
</body>
</html>